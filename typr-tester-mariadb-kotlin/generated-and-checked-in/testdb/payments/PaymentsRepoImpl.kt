/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.payments

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import testdb.orders.OrdersId
import testdb.payment_methods.PaymentMethodsId
import typr.kotlindsl.DeleteBuilder
import typr.kotlindsl.Dialect
import typr.kotlindsl.Fragment
import typr.kotlindsl.KotlinDbTypes
import typr.kotlindsl.SelectBuilder
import typr.kotlindsl.UpdateBuilder
import typr.kotlindsl.nullable
import typr.runtime.MariaTypes

class PaymentsRepoImpl() : PaymentsRepo {
  override fun delete(): DeleteBuilder<PaymentsFields, PaymentsRow> = DeleteBuilder.of("`payments`", PaymentsFields.structure, Dialect.MARIADB)

  override fun deleteById(
    paymentId: PaymentsId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from `payments` where `payment_id` = "), Fragment.encode(PaymentsId.pgType, paymentId), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    paymentIds: Array<PaymentsId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in paymentIds) { fragments.add(Fragment.encode(PaymentsId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("delete from `payments` where `payment_id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: PaymentsRow,
    c: Connection
  ): PaymentsRow = Fragment.interpolate(Fragment.lit("insert into `payments`(`order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`)\nvalues ("), Fragment.encode(OrdersId.pgType, unsaved.orderId), Fragment.lit(", "), Fragment.encode(PaymentMethodsId.pgType, unsaved.methodId), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.transactionId), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.numeric, unsaved.amount), Fragment.lit(", "), Fragment.encode(MariaTypes.char_, unsaved.currencyCode), Fragment.lit(", "), Fragment.encode(MariaTypes.text, unsaved.status), Fragment.lit(", "), Fragment.encode(MariaTypes.longtext.nullable(), unsaved.processorResponse), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.errorMessage), Fragment.lit(", "), Fragment.encode(MariaTypes.inet6.nullable(), unsaved.ipAddress), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime, unsaved.createdAt), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime.nullable(), unsaved.processedAt), Fragment.lit(")\nRETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`\n"))
    .updateReturning(PaymentsRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: PaymentsRowUnsaved,
    c: Connection
  ): PaymentsRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("`order_id`"))
    values.add(Fragment.interpolate(Fragment.encode(OrdersId.pgType, unsaved.orderId), Fragment.lit("")))
    columns.add(Fragment.lit("`method_id`"))
    values.add(Fragment.interpolate(Fragment.encode(PaymentMethodsId.pgType, unsaved.methodId), Fragment.lit("")))
    columns.add(Fragment.lit("`amount`"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.MariaTypes.numeric, unsaved.amount), Fragment.lit("")))
    unsaved.transactionId.visit(
      {  },
      { value -> columns.add(Fragment.lit("`transaction_id`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.currencyCode.visit(
      {  },
      { value -> columns.add(Fragment.lit("`currency_code`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.char_, value), Fragment.lit(""))) }
    );
    unsaved.status.visit(
      {  },
      { value -> columns.add(Fragment.lit("`status`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.text, value), Fragment.lit(""))) }
    );
    unsaved.processorResponse.visit(
      {  },
      { value -> columns.add(Fragment.lit("`processor_response`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.longtext.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.errorMessage.visit(
      {  },
      { value -> columns.add(Fragment.lit("`error_message`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.ipAddress.visit(
      {  },
      { value -> columns.add(Fragment.lit("`ip_address`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.inet6.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.createdAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`created_at`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.datetime, value), Fragment.lit(""))) }
    );
    unsaved.processedAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`processed_at`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.datetime.nullable(), value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into `payments`("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`\n"))
    return q.updateReturning(PaymentsRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<PaymentsFields, PaymentsRow> = SelectBuilder.of("`payments`", PaymentsFields.structure, PaymentsRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<PaymentsRow> = Fragment.interpolate(Fragment.lit("select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`\nfrom `payments`\n")).query(PaymentsRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    paymentId: PaymentsId,
    c: Connection
  ): PaymentsRow? = Fragment.interpolate(Fragment.lit("select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`\nfrom `payments`\nwhere `payment_id` = "), Fragment.encode(PaymentsId.pgType, paymentId), Fragment.lit("")).query(PaymentsRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    paymentIds: Array<PaymentsId>,
    c: Connection
  ): List<PaymentsRow> {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in paymentIds) { fragments.add(Fragment.encode(PaymentsId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at` from `payments` where `payment_id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).query(PaymentsRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    paymentIds: Array<PaymentsId>,
    c: Connection
  ): Map<PaymentsId, PaymentsRow> {
    val ret: MutableMap<PaymentsId, PaymentsRow> = mutableMapOf<PaymentsId, PaymentsRow>()
    selectByIds(paymentIds, c).forEach({ row -> ret.put(row.paymentId, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<PaymentsFields, PaymentsRow> = UpdateBuilder.of("`payments`", PaymentsFields.structure, PaymentsRow._rowParser, Dialect.MARIADB)

  override fun update(
    row: PaymentsRow,
    c: Connection
  ): Boolean {
    val paymentId: PaymentsId = row.paymentId
    return Fragment.interpolate(Fragment.lit("update `payments`\nset `order_id` = "), Fragment.encode(OrdersId.pgType, row.orderId), Fragment.lit(",\n`method_id` = "), Fragment.encode(PaymentMethodsId.pgType, row.methodId), Fragment.lit(",\n`transaction_id` = "), Fragment.encode(MariaTypes.varchar.nullable(), row.transactionId), Fragment.lit(",\n`amount` = "), Fragment.encode(KotlinDbTypes.MariaTypes.numeric, row.amount), Fragment.lit(",\n`currency_code` = "), Fragment.encode(MariaTypes.char_, row.currencyCode), Fragment.lit(",\n`status` = "), Fragment.encode(MariaTypes.text, row.status), Fragment.lit(",\n`processor_response` = "), Fragment.encode(MariaTypes.longtext.nullable(), row.processorResponse), Fragment.lit(",\n`error_message` = "), Fragment.encode(MariaTypes.varchar.nullable(), row.errorMessage), Fragment.lit(",\n`ip_address` = "), Fragment.encode(MariaTypes.inet6.nullable(), row.ipAddress), Fragment.lit(",\n`created_at` = "), Fragment.encode(MariaTypes.datetime, row.createdAt), Fragment.lit(",\n`processed_at` = "), Fragment.encode(MariaTypes.datetime.nullable(), row.processedAt), Fragment.lit("\nwhere `payment_id` = "), Fragment.encode(PaymentsId.pgType, paymentId), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: PaymentsRow,
    c: Connection
  ): PaymentsRow = Fragment.interpolate(Fragment.lit("INSERT INTO `payments`(`order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`)\nVALUES ("), Fragment.encode(OrdersId.pgType, unsaved.orderId), Fragment.lit(", "), Fragment.encode(PaymentMethodsId.pgType, unsaved.methodId), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.transactionId), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.numeric, unsaved.amount), Fragment.lit(", "), Fragment.encode(MariaTypes.char_, unsaved.currencyCode), Fragment.lit(", "), Fragment.encode(MariaTypes.text, unsaved.status), Fragment.lit(", "), Fragment.encode(MariaTypes.longtext.nullable(), unsaved.processorResponse), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.errorMessage), Fragment.lit(", "), Fragment.encode(MariaTypes.inet6.nullable(), unsaved.ipAddress), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime, unsaved.createdAt), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime.nullable(), unsaved.processedAt), Fragment.lit(")\nON DUPLICATE KEY UPDATE `order_id` = VALUES(`order_id`),\n`method_id` = VALUES(`method_id`),\n`transaction_id` = VALUES(`transaction_id`),\n`amount` = VALUES(`amount`),\n`currency_code` = VALUES(`currency_code`),\n`status` = VALUES(`status`),\n`processor_response` = VALUES(`processor_response`),\n`error_message` = VALUES(`error_message`),\n`ip_address` = VALUES(`ip_address`),\n`created_at` = VALUES(`created_at`),\n`processed_at` = VALUES(`processed_at`)\nRETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`"))
    .updateReturning(PaymentsRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<PaymentsRow>,
    c: Connection
  ): List<PaymentsRow> = Fragment.interpolate(Fragment.lit("INSERT INTO `payments`(`payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`)\nVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\nON DUPLICATE KEY UPDATE `order_id` = VALUES(`order_id`),\n`method_id` = VALUES(`method_id`),\n`transaction_id` = VALUES(`transaction_id`),\n`amount` = VALUES(`amount`),\n`currency_code` = VALUES(`currency_code`),\n`status` = VALUES(`status`),\n`processor_response` = VALUES(`processor_response`),\n`error_message` = VALUES(`error_message`),\n`ip_address` = VALUES(`ip_address`),\n`created_at` = VALUES(`created_at`),\n`processed_at` = VALUES(`processed_at`)\nRETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`"))
    .updateReturningEach(PaymentsRow._rowParser, unsaved)
  .runUnchecked(c)
}