/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.customer_status

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typr.kotlindsl.DeleteBuilder
import typr.kotlindsl.Dialect
import typr.kotlindsl.Fragment
import typr.kotlindsl.KotlinDbTypes
import typr.kotlindsl.SelectBuilder
import typr.kotlindsl.UpdateBuilder
import typr.runtime.MariaTypes

class CustomerStatusRepoImpl() : CustomerStatusRepo {
  override fun delete(): DeleteBuilder<CustomerStatusFields, CustomerStatusRow> = DeleteBuilder.of("`customer_status`", CustomerStatusFields.structure, Dialect.MARIADB)

  override fun deleteById(
    statusCode: CustomerStatusId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from `customer_status` where `status_code` = "), Fragment.encode(CustomerStatusId.pgType, statusCode), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    statusCodes: Array<CustomerStatusId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in statusCodes) { fragments.add(Fragment.encode(CustomerStatusId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("delete from `customer_status` where `status_code` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: CustomerStatusRow,
    c: Connection
  ): CustomerStatusRow = Fragment.interpolate(Fragment.lit("insert into `customer_status`(`status_code`, `description`, `is_active`)\nvalues ("), Fragment.encode(CustomerStatusId.pgType, unsaved.statusCode), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.description), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.bool, unsaved.isActive), Fragment.lit(")\nRETURNING `status_code`, `description`, `is_active`\n"))
    .updateReturning(CustomerStatusRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: CustomerStatusRowUnsaved,
    c: Connection
  ): CustomerStatusRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("`status_code`"))
    values.add(Fragment.interpolate(Fragment.encode(CustomerStatusId.pgType, unsaved.statusCode), Fragment.lit("")))
    columns.add(Fragment.lit("`description`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.description), Fragment.lit("")))
    unsaved.isActive.visit(
      {  },
      { value -> columns.add(Fragment.lit("`is_active`"))
      values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.MariaTypes.bool, value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into `customer_status`("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING `status_code`, `description`, `is_active`\n"))
    return q.updateReturning(CustomerStatusRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<CustomerStatusFields, CustomerStatusRow> = SelectBuilder.of("`customer_status`", CustomerStatusFields.structure, CustomerStatusRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<CustomerStatusRow> = Fragment.interpolate(Fragment.lit("select `status_code`, `description`, `is_active`\nfrom `customer_status`\n")).query(CustomerStatusRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    statusCode: CustomerStatusId,
    c: Connection
  ): CustomerStatusRow? = Fragment.interpolate(Fragment.lit("select `status_code`, `description`, `is_active`\nfrom `customer_status`\nwhere `status_code` = "), Fragment.encode(CustomerStatusId.pgType, statusCode), Fragment.lit("")).query(CustomerStatusRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    statusCodes: Array<CustomerStatusId>,
    c: Connection
  ): List<CustomerStatusRow> {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in statusCodes) { fragments.add(Fragment.encode(CustomerStatusId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("select `status_code`, `description`, `is_active` from `customer_status` where `status_code` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).query(CustomerStatusRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    statusCodes: Array<CustomerStatusId>,
    c: Connection
  ): Map<CustomerStatusId, CustomerStatusRow> {
    val ret: MutableMap<CustomerStatusId, CustomerStatusRow> = mutableMapOf<CustomerStatusId, CustomerStatusRow>()
    selectByIds(statusCodes, c).forEach({ row -> ret.put(row.statusCode, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<CustomerStatusFields, CustomerStatusRow> = UpdateBuilder.of("`customer_status`", CustomerStatusFields.structure, CustomerStatusRow._rowParser, Dialect.MARIADB)

  override fun update(
    row: CustomerStatusRow,
    c: Connection
  ): Boolean {
    val statusCode: CustomerStatusId = row.statusCode
    return Fragment.interpolate(Fragment.lit("update `customer_status`\nset `description` = "), Fragment.encode(MariaTypes.varchar, row.description), Fragment.lit(",\n`is_active` = "), Fragment.encode(KotlinDbTypes.MariaTypes.bool, row.isActive), Fragment.lit("\nwhere `status_code` = "), Fragment.encode(CustomerStatusId.pgType, statusCode), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: CustomerStatusRow,
    c: Connection
  ): CustomerStatusRow = Fragment.interpolate(Fragment.lit("INSERT INTO `customer_status`(`status_code`, `description`, `is_active`)\nVALUES ("), Fragment.encode(CustomerStatusId.pgType, unsaved.statusCode), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.description), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.bool, unsaved.isActive), Fragment.lit(")\nON DUPLICATE KEY UPDATE `description` = VALUES(`description`),\n`is_active` = VALUES(`is_active`)\nRETURNING `status_code`, `description`, `is_active`"))
    .updateReturning(CustomerStatusRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<CustomerStatusRow>,
    c: Connection
  ): List<CustomerStatusRow> = Fragment.interpolate(Fragment.lit("INSERT INTO `customer_status`(`status_code`, `description`, `is_active`)\nVALUES (?, ?, ?)\nON DUPLICATE KEY UPDATE `description` = VALUES(`description`),\n`is_active` = VALUES(`is_active`)\nRETURNING `status_code`, `description`, `is_active`"))
    .updateReturningEach(CustomerStatusRow._rowParser, unsaved)
  .runUnchecked(c)
}