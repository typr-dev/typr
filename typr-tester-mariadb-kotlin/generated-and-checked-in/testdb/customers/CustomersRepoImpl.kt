/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.customers

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import testdb.customer_status.CustomerStatusId
import typr.kotlindsl.DeleteBuilder
import typr.kotlindsl.Dialect
import typr.kotlindsl.Fragment
import typr.kotlindsl.SelectBuilder
import typr.kotlindsl.UpdateBuilder
import typr.kotlindsl.nullable
import typr.runtime.MariaTypes

class CustomersRepoImpl() : CustomersRepo {
  override fun delete(): DeleteBuilder<CustomersFields, CustomersRow> = DeleteBuilder.of("`customers`", CustomersFields.structure, Dialect.MARIADB)

  override fun deleteById(
    customerId: CustomersId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from `customers` where `customer_id` = "), Fragment.encode(CustomersId.pgType, customerId), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    customerIds: Array<CustomersId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in customerIds) { fragments.add(Fragment.encode(CustomersId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("delete from `customers` where `customer_id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: CustomersRow,
    c: Connection
  ): CustomersRow = Fragment.interpolate(Fragment.lit("insert into `customers`(`email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`)\nvalues ("), Fragment.encode(MariaTypes.varchar, unsaved.email), Fragment.lit(", "), Fragment.encode(MariaTypes.binary, unsaved.passwordHash), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.firstName), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.lastName), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.phone), Fragment.lit(", "), Fragment.encode(CustomerStatusId.pgType, unsaved.status), Fragment.lit(", "), Fragment.encode(MariaTypes.text, unsaved.tier), Fragment.lit(", "), Fragment.encode(MariaTypes.longtext.nullable(), unsaved.preferences), Fragment.lit(", "), Fragment.encode(MariaTypes.set.nullable(), unsaved.marketingFlags), Fragment.lit(", "), Fragment.encode(MariaTypes.text.nullable(), unsaved.notes), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime, unsaved.createdAt), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime, unsaved.updatedAt), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime.nullable(), unsaved.lastLoginAt), Fragment.lit(")\nRETURNING `customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`\n"))
    .updateReturning(CustomersRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: CustomersRowUnsaved,
    c: Connection
  ): CustomersRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("`email`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.email), Fragment.lit("")))
    columns.add(Fragment.lit("`password_hash`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.binary, unsaved.passwordHash), Fragment.lit("")))
    columns.add(Fragment.lit("`first_name`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.firstName), Fragment.lit("")))
    columns.add(Fragment.lit("`last_name`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.lastName), Fragment.lit("")))
    unsaved.phone.visit(
      {  },
      { value -> columns.add(Fragment.lit("`phone`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.status.visit(
      {  },
      { value -> columns.add(Fragment.lit("`status`"))
      values.add(Fragment.interpolate(Fragment.encode(CustomerStatusId.pgType, value), Fragment.lit(""))) }
    );
    unsaved.tier.visit(
      {  },
      { value -> columns.add(Fragment.lit("`tier`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.text, value), Fragment.lit(""))) }
    );
    unsaved.preferences.visit(
      {  },
      { value -> columns.add(Fragment.lit("`preferences`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.longtext.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.marketingFlags.visit(
      {  },
      { value -> columns.add(Fragment.lit("`marketing_flags`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.set.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.notes.visit(
      {  },
      { value -> columns.add(Fragment.lit("`notes`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.text.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.createdAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`created_at`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.datetime, value), Fragment.lit(""))) }
    );
    unsaved.updatedAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`updated_at`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.datetime, value), Fragment.lit(""))) }
    );
    unsaved.lastLoginAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`last_login_at`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.datetime.nullable(), value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into `customers`("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING `customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`\n"))
    return q.updateReturning(CustomersRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<CustomersFields, CustomersRow> = SelectBuilder.of("`customers`", CustomersFields.structure, CustomersRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<CustomersRow> = Fragment.interpolate(Fragment.lit("select `customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`\nfrom `customers`\n")).query(CustomersRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    customerId: CustomersId,
    c: Connection
  ): CustomersRow? = Fragment.interpolate(Fragment.lit("select `customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`\nfrom `customers`\nwhere `customer_id` = "), Fragment.encode(CustomersId.pgType, customerId), Fragment.lit("")).query(CustomersRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    customerIds: Array<CustomersId>,
    c: Connection
  ): List<CustomersRow> {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in customerIds) { fragments.add(Fragment.encode(CustomersId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("select `customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at` from `customers` where `customer_id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).query(CustomersRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    customerIds: Array<CustomersId>,
    c: Connection
  ): Map<CustomersId, CustomersRow> {
    val ret: MutableMap<CustomersId, CustomersRow> = mutableMapOf<CustomersId, CustomersRow>()
    selectByIds(customerIds, c).forEach({ row -> ret.put(row.customerId, row) })
    return ret.toMap()
  }

  override fun selectByUniqueEmail(
    email: String,
    c: Connection
  ): CustomersRow? = Fragment.interpolate(Fragment.lit("select `customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`\nfrom `customers`\nwhere `email` = "), Fragment.encode(MariaTypes.varchar, email), Fragment.lit("\n")).query(CustomersRow._rowParser.first()).runUnchecked(c)

  override fun update(): UpdateBuilder<CustomersFields, CustomersRow> = UpdateBuilder.of("`customers`", CustomersFields.structure, CustomersRow._rowParser, Dialect.MARIADB)

  override fun update(
    row: CustomersRow,
    c: Connection
  ): Boolean {
    val customerId: CustomersId = row.customerId
    return Fragment.interpolate(Fragment.lit("update `customers`\nset `email` = "), Fragment.encode(MariaTypes.varchar, row.email), Fragment.lit(",\n`password_hash` = "), Fragment.encode(MariaTypes.binary, row.passwordHash), Fragment.lit(",\n`first_name` = "), Fragment.encode(MariaTypes.varchar, row.firstName), Fragment.lit(",\n`last_name` = "), Fragment.encode(MariaTypes.varchar, row.lastName), Fragment.lit(",\n`phone` = "), Fragment.encode(MariaTypes.varchar.nullable(), row.phone), Fragment.lit(",\n`status` = "), Fragment.encode(CustomerStatusId.pgType, row.status), Fragment.lit(",\n`tier` = "), Fragment.encode(MariaTypes.text, row.tier), Fragment.lit(",\n`preferences` = "), Fragment.encode(MariaTypes.longtext.nullable(), row.preferences), Fragment.lit(",\n`marketing_flags` = "), Fragment.encode(MariaTypes.set.nullable(), row.marketingFlags), Fragment.lit(",\n`notes` = "), Fragment.encode(MariaTypes.text.nullable(), row.notes), Fragment.lit(",\n`created_at` = "), Fragment.encode(MariaTypes.datetime, row.createdAt), Fragment.lit(",\n`updated_at` = "), Fragment.encode(MariaTypes.datetime, row.updatedAt), Fragment.lit(",\n`last_login_at` = "), Fragment.encode(MariaTypes.datetime.nullable(), row.lastLoginAt), Fragment.lit("\nwhere `customer_id` = "), Fragment.encode(CustomersId.pgType, customerId), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: CustomersRow,
    c: Connection
  ): CustomersRow = Fragment.interpolate(Fragment.lit("INSERT INTO `customers`(`email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`)\nVALUES ("), Fragment.encode(MariaTypes.varchar, unsaved.email), Fragment.lit(", "), Fragment.encode(MariaTypes.binary, unsaved.passwordHash), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.firstName), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.lastName), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.phone), Fragment.lit(", "), Fragment.encode(CustomerStatusId.pgType, unsaved.status), Fragment.lit(", "), Fragment.encode(MariaTypes.text, unsaved.tier), Fragment.lit(", "), Fragment.encode(MariaTypes.longtext.nullable(), unsaved.preferences), Fragment.lit(", "), Fragment.encode(MariaTypes.set.nullable(), unsaved.marketingFlags), Fragment.lit(", "), Fragment.encode(MariaTypes.text.nullable(), unsaved.notes), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime, unsaved.createdAt), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime, unsaved.updatedAt), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime.nullable(), unsaved.lastLoginAt), Fragment.lit(")\nON DUPLICATE KEY UPDATE `email` = VALUES(`email`),\n`password_hash` = VALUES(`password_hash`),\n`first_name` = VALUES(`first_name`),\n`last_name` = VALUES(`last_name`),\n`phone` = VALUES(`phone`),\n`status` = VALUES(`status`),\n`tier` = VALUES(`tier`),\n`preferences` = VALUES(`preferences`),\n`marketing_flags` = VALUES(`marketing_flags`),\n`notes` = VALUES(`notes`),\n`created_at` = VALUES(`created_at`),\n`updated_at` = VALUES(`updated_at`),\n`last_login_at` = VALUES(`last_login_at`)\nRETURNING `customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`"))
    .updateReturning(CustomersRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<CustomersRow>,
    c: Connection
  ): List<CustomersRow> = Fragment.interpolate(Fragment.lit("INSERT INTO `customers`(`customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`)\nVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\nON DUPLICATE KEY UPDATE `email` = VALUES(`email`),\n`password_hash` = VALUES(`password_hash`),\n`first_name` = VALUES(`first_name`),\n`last_name` = VALUES(`last_name`),\n`phone` = VALUES(`phone`),\n`status` = VALUES(`status`),\n`tier` = VALUES(`tier`),\n`preferences` = VALUES(`preferences`),\n`marketing_flags` = VALUES(`marketing_flags`),\n`notes` = VALUES(`notes`),\n`created_at` = VALUES(`created_at`),\n`updated_at` = VALUES(`updated_at`),\n`last_login_at` = VALUES(`last_login_at`)\nRETURNING `customer_id`, `email`, `password_hash`, `first_name`, `last_name`, `phone`, `status`, `tier`, `preferences`, `marketing_flags`, `notes`, `created_at`, `updated_at`, `last_login_at`"))
    .updateReturningEach(CustomersRow._rowParser, unsaved)
  .runUnchecked(c)
}