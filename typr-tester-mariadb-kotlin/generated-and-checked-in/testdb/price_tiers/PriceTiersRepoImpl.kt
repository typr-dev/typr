/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.price_tiers

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typr.kotlindsl.DeleteBuilder
import typr.kotlindsl.Dialect
import typr.kotlindsl.Fragment
import typr.kotlindsl.KotlinDbTypes
import typr.kotlindsl.SelectBuilder
import typr.kotlindsl.UpdateBuilder
import typr.runtime.MariaTypes

class PriceTiersRepoImpl() : PriceTiersRepo {
  override fun delete(): DeleteBuilder<PriceTiersFields, PriceTiersRow> = DeleteBuilder.of("`price_tiers`", PriceTiersFields.structure, Dialect.MARIADB)

  override fun deleteById(
    tierId: PriceTiersId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from `price_tiers` where `tier_id` = "), Fragment.encode(PriceTiersId.pgType, tierId), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    tierIds: Array<PriceTiersId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in tierIds) { fragments.add(Fragment.encode(PriceTiersId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("delete from `price_tiers` where `tier_id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: PriceTiersRow,
    c: Connection
  ): PriceTiersRow = Fragment.interpolate(Fragment.lit("insert into `price_tiers`(`name`, `min_quantity`, `discount_type`, `discount_value`)\nvalues ("), Fragment.encode(MariaTypes.varchar, unsaved.name), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.intUnsigned, unsaved.minQuantity), Fragment.lit(", "), Fragment.encode(MariaTypes.text, unsaved.discountType), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.numeric, unsaved.discountValue), Fragment.lit(")\nRETURNING `tier_id`, `name`, `min_quantity`, `discount_type`, `discount_value`\n"))
    .updateReturning(PriceTiersRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: PriceTiersRowUnsaved,
    c: Connection
  ): PriceTiersRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("`name`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.name), Fragment.lit("")))
    columns.add(Fragment.lit("`discount_type`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.text, unsaved.discountType), Fragment.lit("")))
    columns.add(Fragment.lit("`discount_value`"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.MariaTypes.numeric, unsaved.discountValue), Fragment.lit("")))
    unsaved.minQuantity.visit(
      {  },
      { value -> columns.add(Fragment.lit("`min_quantity`"))
      values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.MariaTypes.intUnsigned, value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into `price_tiers`("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING `tier_id`, `name`, `min_quantity`, `discount_type`, `discount_value`\n"))
    return q.updateReturning(PriceTiersRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<PriceTiersFields, PriceTiersRow> = SelectBuilder.of("`price_tiers`", PriceTiersFields.structure, PriceTiersRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<PriceTiersRow> = Fragment.interpolate(Fragment.lit("select `tier_id`, `name`, `min_quantity`, `discount_type`, `discount_value`\nfrom `price_tiers`\n")).query(PriceTiersRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    tierId: PriceTiersId,
    c: Connection
  ): PriceTiersRow? = Fragment.interpolate(Fragment.lit("select `tier_id`, `name`, `min_quantity`, `discount_type`, `discount_value`\nfrom `price_tiers`\nwhere `tier_id` = "), Fragment.encode(PriceTiersId.pgType, tierId), Fragment.lit("")).query(PriceTiersRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    tierIds: Array<PriceTiersId>,
    c: Connection
  ): List<PriceTiersRow> {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in tierIds) { fragments.add(Fragment.encode(PriceTiersId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("select `tier_id`, `name`, `min_quantity`, `discount_type`, `discount_value` from `price_tiers` where `tier_id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).query(PriceTiersRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    tierIds: Array<PriceTiersId>,
    c: Connection
  ): Map<PriceTiersId, PriceTiersRow> {
    val ret: MutableMap<PriceTiersId, PriceTiersRow> = mutableMapOf<PriceTiersId, PriceTiersRow>()
    selectByIds(tierIds, c).forEach({ row -> ret.put(row.tierId, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<PriceTiersFields, PriceTiersRow> = UpdateBuilder.of("`price_tiers`", PriceTiersFields.structure, PriceTiersRow._rowParser, Dialect.MARIADB)

  override fun update(
    row: PriceTiersRow,
    c: Connection
  ): Boolean {
    val tierId: PriceTiersId = row.tierId
    return Fragment.interpolate(Fragment.lit("update `price_tiers`\nset `name` = "), Fragment.encode(MariaTypes.varchar, row.name), Fragment.lit(",\n`min_quantity` = "), Fragment.encode(KotlinDbTypes.MariaTypes.intUnsigned, row.minQuantity), Fragment.lit(",\n`discount_type` = "), Fragment.encode(MariaTypes.text, row.discountType), Fragment.lit(",\n`discount_value` = "), Fragment.encode(KotlinDbTypes.MariaTypes.numeric, row.discountValue), Fragment.lit("\nwhere `tier_id` = "), Fragment.encode(PriceTiersId.pgType, tierId), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: PriceTiersRow,
    c: Connection
  ): PriceTiersRow = Fragment.interpolate(Fragment.lit("INSERT INTO `price_tiers`(`name`, `min_quantity`, `discount_type`, `discount_value`)\nVALUES ("), Fragment.encode(MariaTypes.varchar, unsaved.name), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.intUnsigned, unsaved.minQuantity), Fragment.lit(", "), Fragment.encode(MariaTypes.text, unsaved.discountType), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.numeric, unsaved.discountValue), Fragment.lit(")\nON DUPLICATE KEY UPDATE `name` = VALUES(`name`),\n`min_quantity` = VALUES(`min_quantity`),\n`discount_type` = VALUES(`discount_type`),\n`discount_value` = VALUES(`discount_value`)\nRETURNING `tier_id`, `name`, `min_quantity`, `discount_type`, `discount_value`"))
    .updateReturning(PriceTiersRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<PriceTiersRow>,
    c: Connection
  ): List<PriceTiersRow> = Fragment.interpolate(Fragment.lit("INSERT INTO `price_tiers`(`tier_id`, `name`, `min_quantity`, `discount_type`, `discount_value`)\nVALUES (?, ?, ?, ?, ?)\nON DUPLICATE KEY UPDATE `name` = VALUES(`name`),\n`min_quantity` = VALUES(`min_quantity`),\n`discount_type` = VALUES(`discount_type`),\n`discount_value` = VALUES(`discount_value`)\nRETURNING `tier_id`, `name`, `min_quantity`, `discount_type`, `discount_value`"))
    .updateReturningEach(PriceTiersRow._rowParser, unsaved)
  .runUnchecked(c)
}