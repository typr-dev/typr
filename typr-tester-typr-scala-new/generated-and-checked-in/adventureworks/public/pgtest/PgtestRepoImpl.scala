/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.public.pgtest

import adventureworks.public.Mydomain
import adventureworks.public.Myenum
import java.sql.Connection
import typr.runtime.PgTypes
import typr.runtime.streamingInsert
import typr.scaladsl.DeleteBuilder
import typr.scaladsl.Dialect
import typr.scaladsl.Fragment
import typr.scaladsl.ScalaDbTypes
import typr.scaladsl.ScalaIteratorOps
import typr.scaladsl.SelectBuilder
import typr.scaladsl.UpdateBuilder
import typr.scaladsl.Fragment.sql

class PgtestRepoImpl extends PgtestRepo {
  override def delete: DeleteBuilder[PgtestFields, PgtestRow] = DeleteBuilder.of(""""public"."pgtest"""", PgtestFields.structure, Dialect.POSTGRESQL)

  override def insert(unsaved: PgtestRow)(using c: Connection): PgtestRow = {
  sql"""insert into "public"."pgtest"("bool", "box", "bpchar", "bytea", "char", "circle", "date", "float4", "float8", "hstore", "inet", "int2", "int2vector", "int4", "int8", "interval", "json", "jsonb", "line", "lseg", "money", "mydomain", "myenum", "name", "numeric", "path", "point", "polygon", "text", "time", "timestamp", "timestampz", "timez", "uuid", "varchar", "vector", "xml", "boxes", "bpchares", "chares", "circlees", "datees", "float4es", "float8es", "inetes", "int2es", "int2vectores", "int4es", "int8es", "intervales", "jsones", "jsonbes", "linees", "lseges", "moneyes", "mydomaines", "myenumes", "namees", "numerices", "pathes", "pointes", "polygones", "textes", "timees", "timestampes", "timestampzes", "timezes", "uuides", "varchares", "xmles")
    values (${Fragment.encode(ScalaDbTypes.PgTypes.bool, unsaved.bool)}, ${Fragment.encode(PgTypes.box, unsaved.box)}::box, ${Fragment.encode(PgTypes.bpchar, unsaved.bpchar)}::bpchar, ${Fragment.encode(PgTypes.bytea, unsaved.bytea)}::bytea, ${Fragment.encode(PgTypes.bpchar, unsaved.char)}::bpchar, ${Fragment.encode(PgTypes.circle, unsaved.circle)}::circle, ${Fragment.encode(PgTypes.date, unsaved.date)}::date, ${Fragment.encode(ScalaDbTypes.PgTypes.float4, unsaved.float4)}::float4, ${Fragment.encode(ScalaDbTypes.PgTypes.float8, unsaved.float8)}::float8, ${Fragment.encode(ScalaDbTypes.PgTypes.hstore, unsaved.hstore)}::hstore, ${Fragment.encode(PgTypes.inet, unsaved.inet)}::inet, ${Fragment.encode(ScalaDbTypes.PgTypes.int2, unsaved.int2)}::int2, ${Fragment.encode(PgTypes.int2vector, unsaved.int2vector)}::int2vector, ${Fragment.encode(ScalaDbTypes.PgTypes.int4, unsaved.int4)}::int4, ${Fragment.encode(ScalaDbTypes.PgTypes.int8, unsaved.int8)}::int8, ${Fragment.encode(PgTypes.interval, unsaved.interval)}::interval, ${Fragment.encode(PgTypes.json, unsaved.json)}::json, ${Fragment.encode(PgTypes.jsonb, unsaved.jsonb)}::jsonb, ${Fragment.encode(PgTypes.line, unsaved.line)}::line, ${Fragment.encode(PgTypes.lseg, unsaved.lseg)}::lseg, ${Fragment.encode(PgTypes.money, unsaved.money)}::money, ${Fragment.encode(Mydomain.pgType, unsaved.mydomain)}::text, ${Fragment.encode(Myenum.pgType, unsaved.myenum)}::public.myenum, ${Fragment.encode(PgTypes.name, unsaved.name)}::name, ${Fragment.encode(ScalaDbTypes.PgTypes.numeric, unsaved.numeric)}::numeric, ${Fragment.encode(PgTypes.path, unsaved.path)}::path, ${Fragment.encode(PgTypes.point, unsaved.point)}::point, ${Fragment.encode(PgTypes.polygon, unsaved.polygon)}::polygon, ${Fragment.encode(PgTypes.text, unsaved.text)}, ${Fragment.encode(PgTypes.time, unsaved.time)}::time, ${Fragment.encode(PgTypes.timestamp, unsaved.timestamp)}::timestamp, ${Fragment.encode(PgTypes.timestamptz, unsaved.timestampz)}::timestamptz, ${Fragment.encode(PgTypes.timetz, unsaved.timez)}::timetz, ${Fragment.encode(PgTypes.uuid, unsaved.uuid)}::uuid, ${Fragment.encode(PgTypes.text, unsaved.varchar)}, ${Fragment.encode(PgTypes.vector, unsaved.vector)}::vector, ${Fragment.encode(PgTypes.xml, unsaved.xml)}::xml, ${Fragment.encode(PgTypes.boxArray, unsaved.boxes)}::box[], ${Fragment.encode(PgTypes.bpcharArray, unsaved.bpchares)}::bpchar[], ${Fragment.encode(PgTypes.bpcharArray, unsaved.chares)}::bpchar[], ${Fragment.encode(PgTypes.circleArray, unsaved.circlees)}::circle[], ${Fragment.encode(PgTypes.dateArray, unsaved.datees)}::date[], ${Fragment.encode(PgTypes.float4ArrayUnboxed, unsaved.float4es)}::float4[], ${Fragment.encode(PgTypes.float8ArrayUnboxed, unsaved.float8es)}::float8[], ${Fragment.encode(PgTypes.inetArray, unsaved.inetes)}::inet[], ${Fragment.encode(PgTypes.int2ArrayUnboxed, unsaved.int2es)}::int2[], ${Fragment.encode(PgTypes.int2vectorArray, unsaved.int2vectores)}::int2vector[], ${Fragment.encode(PgTypes.int4ArrayUnboxed, unsaved.int4es)}::int4[], ${Fragment.encode(PgTypes.int8ArrayUnboxed, unsaved.int8es)}::int8[], ${Fragment.encode(PgTypes.intervalArray, unsaved.intervales)}::interval[], ${Fragment.encode(PgTypes.jsonArray, unsaved.jsones)}::json[], ${Fragment.encode(PgTypes.jsonbArray, unsaved.jsonbes)}::jsonb[], ${Fragment.encode(PgTypes.lineArray, unsaved.linees)}::line[], ${Fragment.encode(PgTypes.lsegArray, unsaved.lseges)}::lseg[], ${Fragment.encode(PgTypes.moneyArray, unsaved.moneyes)}::money[], ${Fragment.encode(Mydomain.pgTypeArray, unsaved.mydomaines)}::mydomain[], ${Fragment.encode(Myenum.pgTypeArray, unsaved.myenumes)}::myenum[], ${Fragment.encode(PgTypes.nameArray, unsaved.namees)}::name[], ${Fragment.encode(ScalaDbTypes.PgTypes.numericArray, unsaved.numerices)}::numeric[], ${Fragment.encode(PgTypes.pathArray, unsaved.pathes)}::path[], ${Fragment.encode(PgTypes.pointArray, unsaved.pointes)}::point[], ${Fragment.encode(PgTypes.polygonArray, unsaved.polygones)}::polygon[], ${Fragment.encode(PgTypes.textArray, unsaved.textes)}::text[], ${Fragment.encode(PgTypes.timeArray, unsaved.timees)}::time[], ${Fragment.encode(PgTypes.timestampArray, unsaved.timestampes)}::timestamp[], ${Fragment.encode(PgTypes.timestamptzArray, unsaved.timestampzes)}::timestamptz[], ${Fragment.encode(PgTypes.timetzArray, unsaved.timezes)}::timetz[], ${Fragment.encode(PgTypes.uuidArray, unsaved.uuides)}::uuid[], ${Fragment.encode(PgTypes.textArray, unsaved.varchares)}::varchar[], ${Fragment.encode(PgTypes.xmlArray, unsaved.xmles)}::xml[])
    RETURNING "bool", "box", "bpchar", "bytea", "char", "circle", "date", "float4", "float8", "hstore", "inet", "int2", "int2vector", "int4", "int8", "interval", "json", "jsonb", "line", "lseg", "money"::numeric, "mydomain", "myenum", "name", "numeric", "path", "point", "polygon", "text", "time", "timestamp", "timestampz", "timez", "uuid", "varchar", "vector", "xml", "boxes", "bpchares", "chares", "circlees", "datees", "float4es", "float8es", "inetes", "int2es", "int2vectores", "int4es", "int8es", "intervales", "jsones", "jsonbes", "linees", "lseges", "moneyes"::numeric[], "mydomaines"::text[], "myenumes", "namees", "numerices", "pathes", "pointes", "polygones", "textes", "timees", "timestampes", "timestampzes", "timezes", "uuides", "varchares", "xmles"
    """
    .updateReturning(PgtestRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insertStreaming(
    unsaved: Iterator[PgtestRow],
    batchSize: Int = 10000
  )(using c: Connection): Long = streamingInsert.insertUnchecked(s"""COPY "public"."pgtest"("bool", "box", "bpchar", "bytea", "char", "circle", "date", "float4", "float8", "hstore", "inet", "int2", "int2vector", "int4", "int8", "interval", "json", "jsonb", "line", "lseg", "money", "mydomain", "myenum", "name", "numeric", "path", "point", "polygon", "text", "time", "timestamp", "timestampz", "timez", "uuid", "varchar", "vector", "xml", "boxes", "bpchares", "chares", "circlees", "datees", "float4es", "float8es", "inetes", "int2es", "int2vectores", "int4es", "int8es", "intervales", "jsones", "jsonbes", "linees", "lseges", "moneyes", "mydomaines", "myenumes", "namees", "numerices", "pathes", "pointes", "polygones", "textes", "timees", "timestampes", "timestampzes", "timezes", "uuides", "varchares", "xmles") FROM STDIN""", batchSize, unsaved.toJavaIterator, c, PgtestRow.pgText)

  override def select: SelectBuilder[PgtestFields, PgtestRow] = SelectBuilder.of(""""public"."pgtest"""", PgtestFields.structure, PgtestRow.`_rowParser`, Dialect.POSTGRESQL)

  override def selectAll(using c: Connection): List[PgtestRow] = {
    sql"""select "bool", "box", "bpchar", "bytea", "char", "circle", "date", "float4", "float8", "hstore", "inet", "int2", "int2vector", "int4", "int8", "interval", "json", "jsonb", "line", "lseg", "money"::numeric, "mydomain", "myenum", "name", "numeric", "path", "point", "polygon", "text", "time", "timestamp", "timestampz", "timez", "uuid", "varchar", "vector", "xml", "boxes", "bpchares", "chares", "circlees", "datees", "float4es", "float8es", "inetes", "int2es", "int2vectores", "int4es", "int8es", "intervales", "jsones", "jsonbes", "linees", "lseges", "moneyes"::numeric[], "mydomaines"::text[], "myenumes", "namees", "numerices", "pathes", "pointes", "polygones", "textes", "timees", "timestampes", "timestampzes", "timezes", "uuides", "varchares", "xmles"
    from "public"."pgtest"
    """.query(PgtestRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def update: UpdateBuilder[PgtestFields, PgtestRow] = UpdateBuilder.of(""""public"."pgtest"""", PgtestFields.structure, PgtestRow.`_rowParser`, Dialect.POSTGRESQL)
}