/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.productphoto

import adventureworks.customtypes.Defaulted
import java.time.LocalDateTime
import typr.runtime.PgText
import typr.runtime.PgTypes
import typr.scaladsl.PgTypeOps
import typr.scaladsl.RowParser
import typr.scaladsl.RowParsers

/** Table: production.productphoto
 * Product images.
 * Primary key: productphotoid
 */
case class ProductphotoRow(
  /** Primary key for ProductPhoto records.
   * Default: nextval('production.productphoto_productphotoid_seq'::regclass)
   */
  productphotoid: ProductphotoId,
  /** Small image of the product. */
  thumbnailphoto: Option[Array[Byte]],
  /** Small image file name. */
  thumbnailphotofilename: Option[/* max 50 chars */ String],
  /** Large image of the product. */
  largephoto: Option[Array[Byte]],
  /** Large image file name. */
  largephotofilename: Option[/* max 50 chars */ String],
  /** Default: now() */
  modifieddate: LocalDateTime
) {
  def id: ProductphotoId = productphotoid

  def toUnsavedRow(
    productphotoid: Defaulted[ProductphotoId],
    modifieddate: Defaulted[LocalDateTime] = Defaulted.Provided(this.modifieddate)
  ): ProductphotoRowUnsaved = {
    new ProductphotoRowUnsaved(
      thumbnailphoto,
      thumbnailphotofilename,
      largephoto,
      largephotofilename,
      productphotoid,
      modifieddate
    )
  }
}

object ProductphotoRow {
  val `_rowParser`: RowParser[ProductphotoRow] = RowParsers.of(ProductphotoId.pgType, PgTypes.bytea.nullable, PgTypes.text.nullable, PgTypes.bytea.nullable, PgTypes.text.nullable, PgTypes.timestamp)(ProductphotoRow.apply)(row => Array[Any](row.productphotoid, row.thumbnailphoto, row.thumbnailphotofilename, row.largephoto, row.largephotofilename, row.modifieddate))

  given pgText: PgText[ProductphotoRow] = PgText.from(`_rowParser`.underlying)
}