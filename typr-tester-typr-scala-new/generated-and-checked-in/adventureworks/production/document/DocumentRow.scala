/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.document

import adventureworks.customtypes.Defaulted
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.public.Flag
import java.time.LocalDateTime
import java.util.UUID
import typr.runtime.PgText
import typr.runtime.PgTypes
import typr.scaladsl.PgTypeOps
import typr.scaladsl.RowParser
import typr.scaladsl.RowParsers
import typr.scaladsl.ScalaDbTypes

/** Table: production.document
 * Product maintenance documents.
 * Primary key: documentnode
 */
case class DocumentRow(
  /** Title of the document. */
  title: String,
  /** Employee who controls the document.  Foreign key to Employee.BusinessEntityID
   * Points to [[adventureworks.humanresources.employee.EmployeeRow.businessentityid]]
   */
  owner: BusinessentityId,
  /** 0 = This is a folder, 1 = This is a document.
   * Default: false
   */
  folderflag: Flag,
  /** File name of the document */
  filename: String,
  /** File extension indicating the document type. For example, .doc or .txt. */
  fileextension: Option[/* max 8 chars */ String],
  /** Revision number of the document. */
  revision: String,
  /** Engineering change approval number.
   * Default: 0
   */
  changenumber: Int,
  /** 1 = Pending approval, 2 = Approved, 3 = Obsolete
   * Constraint CK_Document_Status affecting columns status: (((status >= 1) AND (status <= 3)))
   */
  status: Short,
  /** Document abstract. */
  documentsummary: Option[String],
  /** Complete document. */
  document: Option[Array[Byte]],
  /** ROWGUIDCOL number uniquely identifying the record. Required for FileStream.
   * Default: uuid_generate_v1()
   */
  rowguid: UUID,
  /** Default: now() */
  modifieddate: LocalDateTime,
  /** Primary key for Document records.
   * Default: '/'::character varying
   */
  documentnode: DocumentId
) {
  def id: DocumentId = documentnode

  def toUnsavedRow(
    documentnode: Defaulted[DocumentId],
    folderflag: Defaulted[Flag] = Defaulted.Provided(this.folderflag),
    changenumber: Defaulted[Int] = Defaulted.Provided(this.changenumber),
    rowguid: Defaulted[UUID] = Defaulted.Provided(this.rowguid),
    modifieddate: Defaulted[LocalDateTime] = Defaulted.Provided(this.modifieddate)
  ): DocumentRowUnsaved = {
    new DocumentRowUnsaved(
      title,
      owner,
      filename,
      fileextension,
      revision,
      status,
      documentsummary,
      document,
      folderflag,
      changenumber,
      rowguid,
      modifieddate,
      documentnode
    )
  }
}

object DocumentRow {
  val `_rowParser`: RowParser[DocumentRow] = RowParsers.of(PgTypes.text, BusinessentityId.pgType, Flag.pgType, PgTypes.text, PgTypes.text.nullable, PgTypes.bpchar, ScalaDbTypes.PgTypes.int4, ScalaDbTypes.PgTypes.int2, PgTypes.text.nullable, PgTypes.bytea.nullable, PgTypes.uuid, PgTypes.timestamp, DocumentId.pgType)(DocumentRow.apply)(row => Array[Any](row.title, row.owner, row.folderflag, row.filename, row.fileextension, row.revision, row.changenumber, row.status, row.documentsummary, row.document, row.rowguid, row.modifieddate, row.documentnode))

  given pgText: PgText[DocumentRow] = PgText.from(`_rowParser`.underlying)
}