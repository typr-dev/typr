/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.purchasing.productvendor

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.Defaulted.UseDefault
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.time.LocalDateTime
import typr.runtime.PgText
import typr.runtime.PgTypes
import typr.scaladsl.PgTypeOps
import typr.scaladsl.ScalaDbTypes

/** This class corresponds to a row in table `purchasing.productvendor` which has not been persisted yet */
case class ProductvendorRowUnsaved(
  /** Primary key. Foreign key to Product.ProductID.
   * Points to [[adventureworks.production.product.ProductRow.productid]]
   */
  productid: ProductId,
  /** Primary key. Foreign key to Vendor.BusinessEntityID.
   * Points to [[adventureworks.purchasing.vendor.VendorRow.businessentityid]]
   */
  businessentityid: BusinessentityId,
  /** The average span of time (in days) between placing an order with the vendor and receiving the purchased product.
   * Constraint CK_ProductVendor_AverageLeadTime affecting columns averageleadtime:  ((averageleadtime >= 1))
   */
  averageleadtime: Int,
  /** The vendor's usual selling price.
   * Constraint CK_ProductVendor_StandardPrice affecting columns standardprice:  ((standardprice > 0.00))
   */
  standardprice: BigDecimal,
  /** The selling price when last purchased.
   * Constraint CK_ProductVendor_LastReceiptCost affecting columns lastreceiptcost:  ((lastreceiptcost > 0.00))
   */
  lastreceiptcost: Option[BigDecimal] = None,
  /** Date the product was last received by the vendor. */
  lastreceiptdate: Option[LocalDateTime] = None,
  /** The maximum quantity that should be ordered.
   * Constraint CK_ProductVendor_MinOrderQty affecting columns minorderqty:  ((minorderqty >= 1))
   */
  minorderqty: Int,
  /** The minimum quantity that should be ordered.
   * Constraint CK_ProductVendor_MaxOrderQty affecting columns maxorderqty:  ((maxorderqty >= 1))
   */
  maxorderqty: Int,
  /** The quantity currently on order.
   * Constraint CK_ProductVendor_OnOrderQty affecting columns onorderqty:  ((onorderqty >= 0))
   */
  onorderqty: Option[Int] = None,
  /** The product's unit of measure.
   * Points to [[adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]]
   */
  unitmeasurecode: UnitmeasureId,
  /** Default: now() */
  modifieddate: Defaulted[LocalDateTime] = new UseDefault()
) {
  def toRow(modifieddateDefault: => LocalDateTime): ProductvendorRow = {
    new ProductvendorRow(
      productid = productid,
      businessentityid = businessentityid,
      averageleadtime = averageleadtime,
      standardprice = standardprice,
      lastreceiptcost = lastreceiptcost,
      lastreceiptdate = lastreceiptdate,
      minorderqty = minorderqty,
      maxorderqty = maxorderqty,
      onorderqty = onorderqty,
      unitmeasurecode = unitmeasurecode,
      modifieddate = modifieddate.getOrElse(modifieddateDefault)
    )
  }
}

object ProductvendorRowUnsaved {
  given pgText: PgText[ProductvendorRowUnsaved] = PgText.instance((row, sb) => { ProductId.pgType.pgText.unsafeEncode(row.productid, sb); sb.append(PgText.DELIMETER); BusinessentityId.pgType.pgText.unsafeEncode(row.businessentityid, sb); sb.append(PgText.DELIMETER); ScalaDbTypes.PgTypes.int4.pgText.unsafeEncode(row.averageleadtime, sb); sb.append(PgText.DELIMETER); ScalaDbTypes.PgTypes.numeric.pgText.unsafeEncode(row.standardprice, sb); sb.append(PgText.DELIMETER); ScalaDbTypes.PgTypes.numeric.nullable.pgText.unsafeEncode(row.lastreceiptcost, sb); sb.append(PgText.DELIMETER); PgTypes.timestamp.nullable.pgText.unsafeEncode(row.lastreceiptdate, sb); sb.append(PgText.DELIMETER); ScalaDbTypes.PgTypes.int4.pgText.unsafeEncode(row.minorderqty, sb); sb.append(PgText.DELIMETER); ScalaDbTypes.PgTypes.int4.pgText.unsafeEncode(row.maxorderqty, sb); sb.append(PgText.DELIMETER); ScalaDbTypes.PgTypes.int4.nullable.pgText.unsafeEncode(row.onorderqty, sb); sb.append(PgText.DELIMETER); UnitmeasureId.pgType.pgText.unsafeEncode(row.unitmeasurecode, sb); sb.append(PgText.DELIMETER); Defaulted.pgText(using PgTypes.timestamp.pgText).unsafeEncode(row.modifieddate, sb) })
}