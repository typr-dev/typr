/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.customtypes

import adventureworks.Text
import java.sql.ResultSet
import java.sql.Types
import typr.dsl.Bijection
import typr.dsl.PGType
import zio.jdbc.JdbcDecoder
import zio.jdbc.JdbcEncoder
import zio.jdbc.SqlFragment.Setter
import zio.json.JsonDecoder
import zio.json.JsonEncoder

/** Short primitive */
case class TypoShort(value: Short)

object TypoShort {
  given arrayJdbcDecoder: JdbcDecoder[Array[TypoShort]] = {
    JdbcDecoder[Array[TypoShort]]((rs: ResultSet) => (i: Int) =>
      rs.getArray(i) match {
        case null => null
        case arr => arr.getArray.asInstanceOf[Array[AnyRef]].map(x => new TypoShort(x.asInstanceOf[java.lang.Short]))
      },
      "Array[java.lang.Integer]"
    )
  }

  given arrayJdbcEncoder: JdbcEncoder[Array[TypoShort]] = JdbcEncoder.singleParamEncoder(using arraySetter)

  given arraySetter: Setter[Array[TypoShort]] = {
    Setter.forSqlType((ps, i, v) =>
      ps.setArray(
        i,
        ps.getConnection.createArrayOf(
          "int2",
          v.map { vv =>
            vv.value: java.lang.Short
          }
        )
      ),
      Types.ARRAY
    )
  }

  given bijection: Bijection[TypoShort, Short] = Bijection.apply[TypoShort, Short](_.value)(TypoShort.apply)

  given jdbcDecoder: JdbcDecoder[TypoShort] = {
    JdbcDecoder[TypoShort](
      (rs: ResultSet) => (i: Int) => {
        val v = rs.getObject(i)
        if (v eq null) null else TypoShort(v.asInstanceOf[Integer].toShort)
      },
      "java.lang.Integer"
    )
  }

  given jdbcEncoder: JdbcEncoder[TypoShort] = JdbcEncoder.singleParamEncoder(using setter)

  given jsonDecoder: JsonDecoder[TypoShort] = JsonDecoder[Short].map(TypoShort.apply)

  given jsonEncoder: JsonEncoder[TypoShort] = JsonEncoder[Short].contramap(_.value)

  given numeric: Numeric[TypoShort] = {
    new Numeric[TypoShort] {
      override def compare(x: TypoShort, y: TypoShort): Int = java.lang.Short.compare(x.value, y.value)
      override def plus(x: TypoShort, y: TypoShort): TypoShort = TypoShort((x.value + y.value).toShort)
      override def minus(x: TypoShort, y: TypoShort): TypoShort = TypoShort((x.value - y.value).toShort)
      override def times(x: TypoShort, y: TypoShort): TypoShort = TypoShort((x.value * y.value).toShort)
      override def negate(x: TypoShort): TypoShort = TypoShort((-x.value).toShort)
      override def fromInt(x: Int): TypoShort = TypoShort(x.toShort)
      override def toInt(x: TypoShort): Int = x.value.toInt
      override def toLong(x: TypoShort): Long = x.value.toLong
      override def toFloat(x: TypoShort): Float = x.value.toFloat
      override def toDouble(x: TypoShort): Double = x.value.toDouble
      def parseString(str: String): Option[TypoShort] = str.toShortOption.map(s => TypoShort(s: java.lang.Short))
      locally{val _ = parseString("1")}
    }
  }

  given pgText: Text[TypoShort] = {
    new Text[TypoShort] {
      override def unsafeEncode(v: TypoShort, sb: StringBuilder): Unit = Text[Short].unsafeEncode(v.value, sb)
      override def unsafeArrayEncode(v: TypoShort, sb: StringBuilder): Unit = Text[Short].unsafeArrayEncode(v.value, sb)
    }
  }

  given pgType: PGType[TypoShort] = PGType.instance[TypoShort]("int2", Types.OTHER)

  given setter: Setter[TypoShort] = {
    Setter.other(
      (ps, i, v) => {
        ps.setObject(
          i,
          v.value.toInt
        )
      },
      "int2"
    )
  }
}