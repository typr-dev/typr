/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.customtypes

import adventureworks.Text
import java.sql.ResultSet
import java.sql.Types
import java.time.Instant
import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeFormatterBuilder
import java.time.temporal.ChronoField
import java.time.temporal.ChronoUnit
import typr.dsl.Bijection
import typr.dsl.PGType
import zio.jdbc.JdbcDecoder
import zio.jdbc.JdbcEncoder
import zio.jdbc.SqlFragment.Setter
import zio.json.JsonDecoder
import zio.json.JsonEncoder

/** This is `java.time.TypoInstant`, but with microsecond precision and transferred to and from postgres as strings. The reason is that postgres driver and db libs are broken */
case class TypoInstant(value: Instant)

object TypoInstant {
  def apply(value: Instant): TypoInstant = new TypoInstant(value.truncatedTo(ChronoUnit.MICROS))

  def apply(str: String): TypoInstant = TypoInstant.apply(OffsetDateTime.parse(str, (if (str.contains("T")) jsonParser else parser)).toInstant())

  given arrayJdbcDecoder: JdbcDecoder[Array[TypoInstant]] = {
    JdbcDecoder[Array[TypoInstant]]((rs: ResultSet) => (i: Int) =>
      rs.getArray(i) match {
        case null => null
        case arr => arr.getArray.asInstanceOf[Array[AnyRef]].map(x => apply(x.asInstanceOf[String]))
      },
      "Array[java.lang.String]"
    )
  }

  given arrayJdbcEncoder: JdbcEncoder[Array[TypoInstant]] = JdbcEncoder.singleParamEncoder(using arraySetter)

  given arraySetter: Setter[Array[TypoInstant]] = {
    Setter.forSqlType((ps, i, v) =>
      ps.setArray(
        i,
        ps.getConnection.createArrayOf(
          "timestamptz",
          v.map { vv =>
            vv.value.toString()
          }
        )
      ),
      Types.ARRAY
    )
  }

  given bijection: Bijection[TypoInstant, Instant] = Bijection.apply[TypoInstant, Instant](_.value)(TypoInstant.apply)

  given jdbcDecoder: JdbcDecoder[TypoInstant] = {
    JdbcDecoder[TypoInstant](
      (rs: ResultSet) => (i: Int) => {
        val v = rs.getObject(i)
        if (v eq null) null else apply(v.asInstanceOf[String])
      },
      "java.lang.String"
    )
  }

  given jdbcEncoder: JdbcEncoder[TypoInstant] = JdbcEncoder.singleParamEncoder(using setter)

  given jsonDecoder: JsonDecoder[TypoInstant] = JsonDecoder.instant.map(TypoInstant.apply)

  given jsonEncoder: JsonEncoder[TypoInstant] = JsonEncoder.instant.contramap(_.value)

  val jsonParser: DateTimeFormatter = new DateTimeFormatterBuilder().appendPattern("yyyy-MM-dd'T'HH:mm:ss").appendFraction(ChronoField.MICRO_OF_SECOND, 0, 6, true).appendPattern("X").toFormatter()

  def now: TypoInstant = TypoInstant.apply(Instant.now())

  val parser: DateTimeFormatter = new DateTimeFormatterBuilder().appendPattern("yyyy-MM-dd HH:mm:ss").appendFraction(ChronoField.MICRO_OF_SECOND, 0, 6, true).appendPattern("X").toFormatter()

  given pgText: Text[TypoInstant] = {
    new Text[TypoInstant] {
      override def unsafeEncode(v: TypoInstant, sb: StringBuilder): Unit = Text.stringInstance.unsafeEncode(v.value.toString(), sb)
      override def unsafeArrayEncode(v: TypoInstant, sb: StringBuilder): Unit = Text.stringInstance.unsafeArrayEncode(v.value.toString(), sb)
    }
  }

  given pgType: PGType[TypoInstant] = PGType.instance[TypoInstant]("timestamptz", Types.OTHER)

  given setter: Setter[TypoInstant] = {
    Setter.other(
      (ps, i, v) => {
        ps.setObject(
          i,
          v.value.toString()
        )
      },
      "timestamptz"
    )
  }
}