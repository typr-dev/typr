/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package oracledb.contacts

import java.sql.Connection
import oracledb.EmailTableT
import oracledb.TagVarrayT
import scala.collection.mutable.ListBuffer
import typo.runtime.OracleTypes
import typo.scaladsl.DeleteBuilder
import typo.scaladsl.Dialect
import typo.scaladsl.Fragment
import typo.scaladsl.OracleTypeOps
import typo.scaladsl.SelectBuilder
import typo.scaladsl.UpdateBuilder
import typo.scaladsl.Fragment.sql

class ContactsRepoImpl extends ContactsRepo {
  override def delete: DeleteBuilder[ContactsFields, ContactsRow] = DeleteBuilder.of(""""CONTACTS"""", ContactsFields.structure, Dialect.ORACLE)

  override def deleteById(contactId: ContactsId)(using c: Connection): Boolean = sql"""delete from "CONTACTS" where "CONTACT_ID" = ${Fragment.encode(ContactsId.oracleType, contactId)}""".update().runUnchecked(c) > 0

  override def deleteByIds(contactIds: Array[ContactsId])(using c: Connection): Int = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    contactIds.foreach { id => fragments.addOne(Fragment.encode(ContactsId.oracleType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""delete from "CONTACTS" where "CONTACT_ID" in ("""), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: ContactsRow)(using c: Connection): ContactsId = {
  sql"""insert into "CONTACTS"("CONTACT_ID", "NAME", "EMAILS", "TAGS")
    values (${Fragment.encode(ContactsId.oracleType, unsaved.contactId)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.name)}, ${Fragment.encode(EmailTableT.oracleType.nullable, unsaved.emails)}, ${Fragment.encode(TagVarrayT.oracleType.nullable, unsaved.tags)})
    """
    .updateReturningGeneratedKeys(Array[String]("CONTACT_ID"), ContactsId.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: ContactsRowUnsaved)(using c: Connection): ContactsId = {
    val columns: ListBuffer[Fragment] = ListBuffer()
    val values: ListBuffer[Fragment] = ListBuffer()
    columns.addOne(Fragment.lit(""""NAME"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(OracleTypes.varchar2, unsaved.name)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""EMAILS"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(EmailTableT.oracleType.nullable, unsaved.emails)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""TAGS"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(TagVarrayT.oracleType.nullable, unsaved.tags)}"): @scala.annotation.nowarn
    unsaved.contactId.visit(
      {  },
      value => { columns.addOne(Fragment.lit(""""CONTACT_ID"""")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ContactsId.oracleType, value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      sql"""insert into "CONTACTS"(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      """
    }
    return q.updateReturningGeneratedKeys(Array[String]("CONTACT_ID"), ContactsId.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[ContactsFields, ContactsRow] = SelectBuilder.of(""""CONTACTS"""", ContactsFields.structure, ContactsRow.`_rowParser`, Dialect.ORACLE)

  override def selectAll(using c: Connection): List[ContactsRow] = {
    sql"""select "CONTACT_ID", "NAME", "EMAILS", "TAGS"
    from "CONTACTS"
    """.query(ContactsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(contactId: ContactsId)(using c: Connection): Option[ContactsRow] = {
    sql"""select "CONTACT_ID", "NAME", "EMAILS", "TAGS"
    from "CONTACTS"
    where "CONTACT_ID" = ${Fragment.encode(ContactsId.oracleType, contactId)}""".query(ContactsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(contactIds: Array[ContactsId])(using c: Connection): List[ContactsRow] = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    contactIds.foreach { id => fragments.addOne(Fragment.encode(ContactsId.oracleType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""select "CONTACT_ID", "NAME", "EMAILS", "TAGS" from "CONTACTS" where "CONTACT_ID" in ("""), Fragment.comma(fragments), Fragment.lit(")")).query(ContactsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(contactIds: Array[ContactsId])(using c: Connection): Map[ContactsId, ContactsRow] = {
    val ret: scala.collection.mutable.Map[ContactsId, ContactsRow] = scala.collection.mutable.Map.empty[ContactsId, ContactsRow]
    selectByIds(contactIds)(using c).foreach(row => ret.put(row.contactId, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def update: UpdateBuilder[ContactsFields, ContactsRow] = UpdateBuilder.of(""""CONTACTS"""", ContactsFields.structure, ContactsRow.`_rowParser`, Dialect.ORACLE)

  override def update(row: ContactsRow)(using c: Connection): Boolean = {
    val contactId: ContactsId = row.contactId
    return sql"""update "CONTACTS"
    set "NAME" = ${Fragment.encode(OracleTypes.varchar2, row.name)},
    "EMAILS" = ${Fragment.encode(EmailTableT.oracleType.nullable, row.emails)},
    "TAGS" = ${Fragment.encode(TagVarrayT.oracleType.nullable, row.tags)}
    where "CONTACT_ID" = ${Fragment.encode(ContactsId.oracleType, contactId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: ContactsRow)(using c: Connection): ContactsRow = {
  sql"""MERGE INTO "CONTACTS" t
    USING (SELECT ${Fragment.encode(ContactsId.oracleType, unsaved.contactId)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.name)}, ${Fragment.encode(EmailTableT.oracleType.nullable, unsaved.emails)}, ${Fragment.encode(TagVarrayT.oracleType.nullable, unsaved.tags)} FROM DUAL) s
    ON ("CONTACT_ID")
    WHEN MATCHED THEN UPDATE SET t."NAME" = s."NAME",
    t."EMAILS" = s."EMAILS",
    t."TAGS" = s."TAGS"
    WHEN NOT MATCHED THEN INSERT ("CONTACT_ID", "NAME", "EMAILS", "TAGS") VALUES (${Fragment.encode(ContactsId.oracleType, unsaved.contactId)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.name)}, ${Fragment.encode(EmailTableT.oracleType.nullable, unsaved.emails)}, ${Fragment.encode(TagVarrayT.oracleType.nullable, unsaved.tags)})"""
    .updateReturning(ContactsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[ContactsRow])(using c: Connection): List[ContactsRow] = {
    sql"""MERGE INTO "CONTACTS" t
    USING (SELECT ?, ?, ?, ? FROM DUAL) s
    ON ("CONTACT_ID")
    WHEN MATCHED THEN UPDATE SET t."NAME" = s."NAME",
    t."EMAILS" = s."EMAILS",
    t."TAGS" = s."TAGS"
    WHEN NOT MATCHED THEN INSERT ("CONTACT_ID", "NAME", "EMAILS", "TAGS") VALUES (?, ?, ?, ?)"""
      .updateReturningEach(ContactsRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}