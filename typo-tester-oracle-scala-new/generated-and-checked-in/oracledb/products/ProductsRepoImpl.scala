/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package oracledb.products

import java.sql.Connection
import oracledb.MoneyT
import oracledb.TagVarrayT
import scala.collection.mutable.ListBuffer
import typo.runtime.OracleTypes
import typo.scaladsl.DeleteBuilder
import typo.scaladsl.Dialect
import typo.scaladsl.Fragment
import typo.scaladsl.OracleTypeOps
import typo.scaladsl.SelectBuilder
import typo.scaladsl.UpdateBuilder
import typo.scaladsl.Fragment.sql

class ProductsRepoImpl extends ProductsRepo {
  override def delete: DeleteBuilder[ProductsFields, ProductsRow] = DeleteBuilder.of(""""PRODUCTS"""", ProductsFields.structure, Dialect.ORACLE)

  override def deleteById(productId: ProductsId)(using c: Connection): Boolean = sql"""delete from "PRODUCTS" where "PRODUCT_ID" = ${Fragment.encode(ProductsId.oracleType, productId)}""".update().runUnchecked(c) > 0

  override def deleteByIds(productIds: Array[ProductsId])(using c: Connection): Int = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    productIds.foreach { id => fragments.addOne(Fragment.encode(ProductsId.oracleType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""delete from "PRODUCTS" where "PRODUCT_ID" in ("""), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: ProductsRow)(using c: Connection): ProductsId = {
  sql"""insert into "PRODUCTS"("PRODUCT_ID", "SKU", "NAME", "PRICE", "TAGS")
    values (${Fragment.encode(ProductsId.oracleType, unsaved.productId)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.sku)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.name)}, ${Fragment.encode(MoneyT.oracleType, unsaved.price)}, ${Fragment.encode(TagVarrayT.oracleType.nullable, unsaved.tags)})
    """
    .updateReturningGeneratedKeys(Array[String]("PRODUCT_ID"), ProductsId.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: ProductsRowUnsaved)(using c: Connection): ProductsId = {
    val columns: ListBuffer[Fragment] = ListBuffer()
    val values: ListBuffer[Fragment] = ListBuffer()
    columns.addOne(Fragment.lit(""""SKU"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(OracleTypes.varchar2, unsaved.sku)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""NAME"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(OracleTypes.varchar2, unsaved.name)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""PRICE"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MoneyT.oracleType, unsaved.price)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""TAGS"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(TagVarrayT.oracleType.nullable, unsaved.tags)}"): @scala.annotation.nowarn
    unsaved.productId.visit(
      {  },
      value => { columns.addOne(Fragment.lit(""""PRODUCT_ID"""")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ProductsId.oracleType, value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      sql"""insert into "PRODUCTS"(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      """
    }
    return q.updateReturningGeneratedKeys(Array[String]("PRODUCT_ID"), ProductsId.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[ProductsFields, ProductsRow] = SelectBuilder.of(""""PRODUCTS"""", ProductsFields.structure, ProductsRow.`_rowParser`, Dialect.ORACLE)

  override def selectAll(using c: Connection): List[ProductsRow] = {
    sql"""select "PRODUCT_ID", "SKU", "NAME", "PRICE", "TAGS"
    from "PRODUCTS"
    """.query(ProductsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(productId: ProductsId)(using c: Connection): Option[ProductsRow] = {
    sql"""select "PRODUCT_ID", "SKU", "NAME", "PRICE", "TAGS"
    from "PRODUCTS"
    where "PRODUCT_ID" = ${Fragment.encode(ProductsId.oracleType, productId)}""".query(ProductsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(productIds: Array[ProductsId])(using c: Connection): List[ProductsRow] = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    productIds.foreach { id => fragments.addOne(Fragment.encode(ProductsId.oracleType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""select "PRODUCT_ID", "SKU", "NAME", "PRICE", "TAGS" from "PRODUCTS" where "PRODUCT_ID" in ("""), Fragment.comma(fragments), Fragment.lit(")")).query(ProductsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(productIds: Array[ProductsId])(using c: Connection): Map[ProductsId, ProductsRow] = {
    val ret: scala.collection.mutable.Map[ProductsId, ProductsRow] = scala.collection.mutable.Map.empty[ProductsId, ProductsRow]
    selectByIds(productIds)(using c).foreach(row => ret.put(row.productId, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def selectByUniqueSku(sku: String)(using c: Connection): Option[ProductsRow] = {
    sql"""select "PRODUCT_ID", "SKU", "NAME", "PRICE", "TAGS"
    from "PRODUCTS"
    where "SKU" = ${Fragment.encode(OracleTypes.varchar2, sku)}
    """.query(ProductsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def update: UpdateBuilder[ProductsFields, ProductsRow] = UpdateBuilder.of(""""PRODUCTS"""", ProductsFields.structure, ProductsRow.`_rowParser`, Dialect.ORACLE)

  override def update(row: ProductsRow)(using c: Connection): Boolean = {
    val productId: ProductsId = row.productId
    return sql"""update "PRODUCTS"
    set "SKU" = ${Fragment.encode(OracleTypes.varchar2, row.sku)},
    "NAME" = ${Fragment.encode(OracleTypes.varchar2, row.name)},
    "PRICE" = ${Fragment.encode(MoneyT.oracleType, row.price)},
    "TAGS" = ${Fragment.encode(TagVarrayT.oracleType.nullable, row.tags)}
    where "PRODUCT_ID" = ${Fragment.encode(ProductsId.oracleType, productId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: ProductsRow)(using c: Connection): ProductsRow = {
  sql"""MERGE INTO "PRODUCTS" t
    USING (SELECT ${Fragment.encode(ProductsId.oracleType, unsaved.productId)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.sku)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.name)}, ${Fragment.encode(MoneyT.oracleType, unsaved.price)}, ${Fragment.encode(TagVarrayT.oracleType.nullable, unsaved.tags)} FROM DUAL) s
    ON ("PRODUCT_ID")
    WHEN MATCHED THEN UPDATE SET t."SKU" = s."SKU",
    t."NAME" = s."NAME",
    t."PRICE" = s."PRICE",
    t."TAGS" = s."TAGS"
    WHEN NOT MATCHED THEN INSERT ("PRODUCT_ID", "SKU", "NAME", "PRICE", "TAGS") VALUES (${Fragment.encode(ProductsId.oracleType, unsaved.productId)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.sku)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.name)}, ${Fragment.encode(MoneyT.oracleType, unsaved.price)}, ${Fragment.encode(TagVarrayT.oracleType.nullable, unsaved.tags)})"""
    .updateReturning(ProductsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[ProductsRow])(using c: Connection): List[ProductsRow] = {
    sql"""MERGE INTO "PRODUCTS" t
    USING (SELECT ?, ?, ?, ?, ? FROM DUAL) s
    ON ("PRODUCT_ID")
    WHEN MATCHED THEN UPDATE SET t."SKU" = s."SKU",
    t."NAME" = s."NAME",
    t."PRICE" = s."PRICE",
    t."TAGS" = s."TAGS"
    WHEN NOT MATCHED THEN INSERT ("PRODUCT_ID", "SKU", "NAME", "PRICE", "TAGS") VALUES (?, ?, ?, ?, ?)"""
      .updateReturningEach(ProductsRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}