/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package oracledb.all_scalar_types

import java.sql.Connection
import scala.collection.mutable.ListBuffer
import typo.runtime.OracleTypes
import typo.scaladsl.DeleteBuilder
import typo.scaladsl.Dialect
import typo.scaladsl.Fragment
import typo.scaladsl.OracleTypeOps
import typo.scaladsl.ScalaDbTypes
import typo.scaladsl.SelectBuilder
import typo.scaladsl.UpdateBuilder
import typo.scaladsl.Fragment.sql

class AllScalarTypesRepoImpl extends AllScalarTypesRepo {
  override def delete: DeleteBuilder[AllScalarTypesFields, AllScalarTypesRow] = DeleteBuilder.of(""""ALL_SCALAR_TYPES"""", AllScalarTypesFields.structure, Dialect.ORACLE)

  override def deleteById(id: AllScalarTypesId)(using c: Connection): Boolean = sql"""delete from "ALL_SCALAR_TYPES" where "ID" = ${Fragment.encode(AllScalarTypesId.oracleType, id)}""".update().runUnchecked(c) > 0

  override def deleteByIds(ids: Array[AllScalarTypesId])(using c: Connection): Int = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    ids.foreach { id => fragments.addOne(Fragment.encode(AllScalarTypesId.oracleType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""delete from "ALL_SCALAR_TYPES" where "ID" in ("""), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: AllScalarTypesRow)(using c: Connection): AllScalarTypesRow = {
  sql"""insert into "ALL_SCALAR_TYPES"("ID", "COL_VARCHAR2", "COL_NUMBER", "COL_DATE", "COL_TIMESTAMP", "COL_CLOB", "COL_NOT_NULL")
    values (${Fragment.encode(AllScalarTypesId.oracleType, unsaved.id)}, ${Fragment.encode(OracleTypes.varchar2.nullable, unsaved.colVarchar2)}, ${Fragment.encode(ScalaDbTypes.OracleTypes.number.nullable, unsaved.colNumber)}, ${Fragment.encode(OracleTypes.date.nullable, unsaved.colDate)}, ${Fragment.encode(OracleTypes.timestamp.nullable, unsaved.colTimestamp)}, ${Fragment.encode(OracleTypes.clob.nullable, unsaved.colClob)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.colNotNull)})
    """
    .updateReturningGeneratedKeys(Array[String]("ID", "COL_VARCHAR2", "COL_NUMBER", "COL_DATE", "COL_TIMESTAMP", "COL_CLOB", "COL_NOT_NULL"), AllScalarTypesRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: AllScalarTypesRowUnsaved)(using c: Connection): AllScalarTypesRow = {
    val columns: ListBuffer[Fragment] = ListBuffer()
    val values: ListBuffer[Fragment] = ListBuffer()
    columns.addOne(Fragment.lit(""""COL_VARCHAR2"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(OracleTypes.varchar2.nullable, unsaved.colVarchar2)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""COL_NUMBER"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.OracleTypes.number.nullable, unsaved.colNumber)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""COL_DATE"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(OracleTypes.date.nullable, unsaved.colDate)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""COL_TIMESTAMP"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(OracleTypes.timestamp.nullable, unsaved.colTimestamp)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""COL_CLOB"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(OracleTypes.clob.nullable, unsaved.colClob)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""COL_NOT_NULL"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(OracleTypes.varchar2, unsaved.colNotNull)}"): @scala.annotation.nowarn
    unsaved.id.visit(
      {  },
      value => { columns.addOne(Fragment.lit(""""ID"""")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(AllScalarTypesId.oracleType, value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      sql"""insert into "ALL_SCALAR_TYPES"(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      """
    }
    return q.updateReturningGeneratedKeys(Array[String]("ID", "COL_VARCHAR2", "COL_NUMBER", "COL_DATE", "COL_TIMESTAMP", "COL_CLOB", "COL_NOT_NULL"), AllScalarTypesRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[AllScalarTypesFields, AllScalarTypesRow] = SelectBuilder.of(""""ALL_SCALAR_TYPES"""", AllScalarTypesFields.structure, AllScalarTypesRow.`_rowParser`, Dialect.ORACLE)

  override def selectAll(using c: Connection): List[AllScalarTypesRow] = {
    sql"""select "ID", "COL_VARCHAR2", "COL_NUMBER", "COL_DATE", "COL_TIMESTAMP", "COL_CLOB", "COL_NOT_NULL"
    from "ALL_SCALAR_TYPES"
    """.query(AllScalarTypesRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(id: AllScalarTypesId)(using c: Connection): Option[AllScalarTypesRow] = {
    sql"""select "ID", "COL_VARCHAR2", "COL_NUMBER", "COL_DATE", "COL_TIMESTAMP", "COL_CLOB", "COL_NOT_NULL"
    from "ALL_SCALAR_TYPES"
    where "ID" = ${Fragment.encode(AllScalarTypesId.oracleType, id)}""".query(AllScalarTypesRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(ids: Array[AllScalarTypesId])(using c: Connection): List[AllScalarTypesRow] = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    ids.foreach { id => fragments.addOne(Fragment.encode(AllScalarTypesId.oracleType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""select "ID", "COL_VARCHAR2", "COL_NUMBER", "COL_DATE", "COL_TIMESTAMP", "COL_CLOB", "COL_NOT_NULL" from "ALL_SCALAR_TYPES" where "ID" in ("""), Fragment.comma(fragments), Fragment.lit(")")).query(AllScalarTypesRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(ids: Array[AllScalarTypesId])(using c: Connection): Map[AllScalarTypesId, AllScalarTypesRow] = {
    val ret: scala.collection.mutable.Map[AllScalarTypesId, AllScalarTypesRow] = scala.collection.mutable.Map.empty[AllScalarTypesId, AllScalarTypesRow]
    selectByIds(ids)(using c).foreach(row => ret.put(row.id, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def update: UpdateBuilder[AllScalarTypesFields, AllScalarTypesRow] = UpdateBuilder.of(""""ALL_SCALAR_TYPES"""", AllScalarTypesFields.structure, AllScalarTypesRow.`_rowParser`, Dialect.ORACLE)

  override def update(row: AllScalarTypesRow)(using c: Connection): Boolean = {
    val id: AllScalarTypesId = row.id
    return sql"""update "ALL_SCALAR_TYPES"
    set "COL_VARCHAR2" = ${Fragment.encode(OracleTypes.varchar2.nullable, row.colVarchar2)},
    "COL_NUMBER" = ${Fragment.encode(ScalaDbTypes.OracleTypes.number.nullable, row.colNumber)},
    "COL_DATE" = ${Fragment.encode(OracleTypes.date.nullable, row.colDate)},
    "COL_TIMESTAMP" = ${Fragment.encode(OracleTypes.timestamp.nullable, row.colTimestamp)},
    "COL_CLOB" = ${Fragment.encode(OracleTypes.clob.nullable, row.colClob)},
    "COL_NOT_NULL" = ${Fragment.encode(OracleTypes.varchar2, row.colNotNull)}
    where "ID" = ${Fragment.encode(AllScalarTypesId.oracleType, id)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: AllScalarTypesRow)(using c: Connection): AllScalarTypesRow = {
  sql"""MERGE INTO "ALL_SCALAR_TYPES" t
    USING (SELECT ${Fragment.encode(AllScalarTypesId.oracleType, unsaved.id)}, ${Fragment.encode(OracleTypes.varchar2.nullable, unsaved.colVarchar2)}, ${Fragment.encode(ScalaDbTypes.OracleTypes.number.nullable, unsaved.colNumber)}, ${Fragment.encode(OracleTypes.date.nullable, unsaved.colDate)}, ${Fragment.encode(OracleTypes.timestamp.nullable, unsaved.colTimestamp)}, ${Fragment.encode(OracleTypes.clob.nullable, unsaved.colClob)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.colNotNull)} FROM DUAL) s
    ON ("ID")
    WHEN MATCHED THEN UPDATE SET t."COL_VARCHAR2" = s."COL_VARCHAR2",
    t."COL_NUMBER" = s."COL_NUMBER",
    t."COL_DATE" = s."COL_DATE",
    t."COL_TIMESTAMP" = s."COL_TIMESTAMP",
    t."COL_CLOB" = s."COL_CLOB",
    t."COL_NOT_NULL" = s."COL_NOT_NULL"
    WHEN NOT MATCHED THEN INSERT ("ID", "COL_VARCHAR2", "COL_NUMBER", "COL_DATE", "COL_TIMESTAMP", "COL_CLOB", "COL_NOT_NULL") VALUES (${Fragment.encode(AllScalarTypesId.oracleType, unsaved.id)}, ${Fragment.encode(OracleTypes.varchar2.nullable, unsaved.colVarchar2)}, ${Fragment.encode(ScalaDbTypes.OracleTypes.number.nullable, unsaved.colNumber)}, ${Fragment.encode(OracleTypes.date.nullable, unsaved.colDate)}, ${Fragment.encode(OracleTypes.timestamp.nullable, unsaved.colTimestamp)}, ${Fragment.encode(OracleTypes.clob.nullable, unsaved.colClob)}, ${Fragment.encode(OracleTypes.varchar2, unsaved.colNotNull)})"""
    .updateReturning(AllScalarTypesRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[AllScalarTypesRow])(using c: Connection): List[AllScalarTypesRow] = {
    sql"""MERGE INTO "ALL_SCALAR_TYPES" t
    USING (SELECT ?, ?, ?, ?, ?, ?, ? FROM DUAL) s
    ON ("ID")
    WHEN MATCHED THEN UPDATE SET t."COL_VARCHAR2" = s."COL_VARCHAR2",
    t."COL_NUMBER" = s."COL_NUMBER",
    t."COL_DATE" = s."COL_DATE",
    t."COL_TIMESTAMP" = s."COL_TIMESTAMP",
    t."COL_CLOB" = s."COL_CLOB",
    t."COL_NOT_NULL" = s."COL_NOT_NULL"
    WHEN NOT MATCHED THEN INSERT ("ID", "COL_VARCHAR2", "COL_NUMBER", "COL_DATE", "COL_TIMESTAMP", "COL_CLOB", "COL_NOT_NULL") VALUES (?, ?, ?, ?, ?, ?, ?)"""
      .updateReturningEach(AllScalarTypesRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}