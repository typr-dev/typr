/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb.hardcoded.myschema.football_club;

import java.sql.Connection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import typr.dsl.DeleteBuilder;
import typr.dsl.Dialect;
import typr.dsl.SelectBuilder;
import typr.dsl.UpdateBuilder;
import typr.runtime.Fragment;
import typr.runtime.PgTypes;
import typr.runtime.streamingInsert;
import static typr.runtime.Fragment.interpolate;

public class FootballClubRepoImpl implements FootballClubRepo {
  @Override
  public DeleteBuilder<FootballClubFields, FootballClubRow> delete() {
    return DeleteBuilder.of("\"myschema\".\"football_club\"", FootballClubFields.structure(), Dialect.POSTGRESQL);
  };

  @Override
  public Boolean deleteById(
    FootballClubId id,
    Connection c
  ) {
    return interpolate(Fragment.lit("delete from \"myschema\".\"football_club\" where \"id\" = "), Fragment.encode(FootballClubId.pgType, id), Fragment.lit("")).update().runUnchecked(c) > 0;
  };

  @Override
  public Integer deleteByIds(
    FootballClubId[] ids,
    Connection c
  ) {
    return interpolate(Fragment.lit("delete\nfrom \"myschema\".\"football_club\"\nwhere \"id\" = ANY("), Fragment.encode(FootballClubId.pgTypeArray, ids), Fragment.lit(")"))
      .update()
      .runUnchecked(c);
  };

  @Override
  public FootballClubRow insert(
    FootballClubRow unsaved,
    Connection c
  ) {
    return interpolate(Fragment.lit("insert into \"myschema\".\"football_club\"(\"id\", \"name\")\nvalues ("), Fragment.encode(FootballClubId.pgType, unsaved.id()), Fragment.lit("::int8, "), Fragment.encode(PgTypes.text, unsaved.name()), Fragment.lit(")\nRETURNING \"id\", \"name\"\n"))
      .updateReturning(FootballClubRow._rowParser.exactlyOne()).runUnchecked(c);
  };

  @Override
  public Long insertStreaming(
    Iterator<FootballClubRow> unsaved,
    Integer batchSize,
    Connection c
  ) {
    return streamingInsert.insertUnchecked("COPY \"myschema\".\"football_club\"(\"id\", \"name\") FROM STDIN", batchSize, unsaved, c, FootballClubRow.pgText);
  };

  @Override
  public SelectBuilder<FootballClubFields, FootballClubRow> select() {
    return SelectBuilder.of("\"myschema\".\"football_club\"", FootballClubFields.structure(), FootballClubRow._rowParser, Dialect.POSTGRESQL);
  };

  @Override
  public List<FootballClubRow> selectAll(Connection c) {
    return interpolate(Fragment.lit("select \"id\", \"name\"\nfrom \"myschema\".\"football_club\"\n")).query(FootballClubRow._rowParser.all()).runUnchecked(c);
  };

  @Override
  public Optional<FootballClubRow> selectById(
    FootballClubId id,
    Connection c
  ) {
    return interpolate(Fragment.lit("select \"id\", \"name\"\nfrom \"myschema\".\"football_club\"\nwhere \"id\" = "), Fragment.encode(FootballClubId.pgType, id), Fragment.lit("")).query(FootballClubRow._rowParser.first()).runUnchecked(c);
  };

  @Override
  public List<FootballClubRow> selectByIds(
    FootballClubId[] ids,
    Connection c
  ) {
    return interpolate(Fragment.lit("select \"id\", \"name\"\nfrom \"myschema\".\"football_club\"\nwhere \"id\" = ANY("), Fragment.encode(FootballClubId.pgTypeArray, ids), Fragment.lit(")")).query(FootballClubRow._rowParser.all()).runUnchecked(c);
  };

  @Override
  public Map<FootballClubId, FootballClubRow> selectByIdsTracked(
    FootballClubId[] ids,
    Connection c
  ) {
    HashMap<FootballClubId, FootballClubRow> ret = new HashMap<FootballClubId, FootballClubRow>();
    selectByIds(ids, c).forEach(row -> ret.put(row.id(), row));
    return ret;
  };

  @Override
  public UpdateBuilder<FootballClubFields, FootballClubRow> update() {
    return UpdateBuilder.of("\"myschema\".\"football_club\"", FootballClubFields.structure(), FootballClubRow._rowParser, Dialect.POSTGRESQL);
  };

  @Override
  public Boolean update(
    FootballClubRow row,
    Connection c
  ) {
    FootballClubId id = row.id();;
    return interpolate(Fragment.lit("update \"myschema\".\"football_club\"\nset \"name\" = "), Fragment.encode(PgTypes.text, row.name()), Fragment.lit("\nwhere \"id\" = "), Fragment.encode(FootballClubId.pgType, id), Fragment.lit("")).update().runUnchecked(c) > 0;
  };

  @Override
  public FootballClubRow upsert(
    FootballClubRow unsaved,
    Connection c
  ) {
    return interpolate(Fragment.lit("insert into \"myschema\".\"football_club\"(\"id\", \"name\")\nvalues ("), Fragment.encode(FootballClubId.pgType, unsaved.id()), Fragment.lit("::int8, "), Fragment.encode(PgTypes.text, unsaved.name()), Fragment.lit(")\non conflict (\"id\")\ndo update set\n  \"name\" = EXCLUDED.\"name\"\nreturning \"id\", \"name\""))
      .updateReturning(FootballClubRow._rowParser.exactlyOne())
      .runUnchecked(c);
  };

  @Override
  public List<FootballClubRow> upsertBatch(
    Iterator<FootballClubRow> unsaved,
    Connection c
  ) {
    return interpolate(Fragment.lit("insert into \"myschema\".\"football_club\"(\"id\", \"name\")\nvalues (?::int8, ?)\non conflict (\"id\")\ndo update set\n  \"name\" = EXCLUDED.\"name\"\nreturning \"id\", \"name\""))
      .updateManyReturning(FootballClubRow._rowParser, unsaved)
    .runUnchecked(c);
  };

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  @Override
  public Integer upsertStreaming(
    Iterator<FootballClubRow> unsaved,
    Integer batchSize,
    Connection c
  ) {
    interpolate(Fragment.lit("create temporary table football_club_TEMP (like \"myschema\".\"football_club\") on commit drop")).update().runUnchecked(c);
    streamingInsert.insertUnchecked("copy football_club_TEMP(\"id\", \"name\") from stdin", batchSize, unsaved, c, FootballClubRow.pgText);
    return interpolate(Fragment.lit("insert into \"myschema\".\"football_club\"(\"id\", \"name\")\nselect * from football_club_TEMP\non conflict (\"id\")\ndo update set\n  \"name\" = EXCLUDED.\"name\"\n;\ndrop table football_club_TEMP;")).update().runUnchecked(c);
  };
}