/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb.hardcoded.myschema.person

import java.util.Optional
import testdb.hardcoded.customtypes.Defaulted
import testdb.hardcoded.myschema.Number
import testdb.hardcoded.myschema.Sector
import testdb.hardcoded.myschema.football_club.FootballClubId
import testdb.hardcoded.myschema.marital_status.MaritalStatusId
import typo.runtime.PgText
import typo.runtime.PgTypes
import typo.runtime.RowParser
import typo.runtime.RowParsers

/** Table: myschema.person
 * person table
 * Primary key: id
 */
case class PersonRow(
  /** Default: auto-increment */
  id: PersonId,
  /** Points to [[testdb.hardcoded.myschema.football_club.FootballClubRow.id]] */
  favouriteFootballClubId: FootballClubId,
  name: /* max 100 chars */ String,
  nickName: Optional[/* max 30 chars */ String],
  blogUrl: Optional[/* max 100 chars */ String],
  email: /* max 254 chars */ String,
  phone: /* max 8 chars */ String,
  likesPizza: java.lang.Boolean,
  /** Default: some-value
   * Points to [[testdb.hardcoded.myschema.marital_status.MaritalStatusRow.id]]
   */
  maritalStatusId: MaritalStatusId,
  workEmail: Optional[/* max 254 chars */ String],
  /** Default: PUBLIC
   * Identity ALWAYS
   */
  sector: Sector,
  /** Default: one */
  favoriteNumber: Number
) {
  def toUnsavedRow(
    id: Defaulted[PersonId],
    maritalStatusId: Defaulted[MaritalStatusId] = Defaulted.Provided(this.maritalStatusId),
    favoriteNumber: Defaulted[Number] = Defaulted.Provided(this.favoriteNumber)
  ): PersonRowUnsaved = {
    new PersonRowUnsaved(
      favouriteFootballClubId,
      name,
      nickName,
      blogUrl,
      email,
      phone,
      likesPizza,
      workEmail,
      id,
      maritalStatusId,
      favoriteNumber
    )
  }
}

object PersonRow {
  val `_rowParser`: RowParser[PersonRow] = RowParsers.of(PersonId.pgType, FootballClubId.pgType, PgTypes.text, PgTypes.text.opt(), PgTypes.text.opt(), PgTypes.text, PgTypes.text, PgTypes.bool, MaritalStatusId.pgType, PgTypes.text.opt(), Sector.pgType, Number.pgType, PersonRow.apply, row => Array[Object](row.id.asInstanceOf[Object], row.favouriteFootballClubId.asInstanceOf[Object], row.name.asInstanceOf[Object], row.nickName.asInstanceOf[Object], row.blogUrl.asInstanceOf[Object], row.email.asInstanceOf[Object], row.phone.asInstanceOf[Object], row.likesPizza.asInstanceOf[Object], row.maritalStatusId.asInstanceOf[Object], row.workEmail.asInstanceOf[Object], row.sector.asInstanceOf[Object], row.favoriteNumber.asInstanceOf[Object]))

  given pgText: PgText[PersonRow] = PgText.from(`_rowParser`)
}