/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb.hardcoded.myschema.football_club

import cats.data.NonEmptyList
import cats.instances.list.catsStdInstancesForList
import doobie.free.connection.ConnectionIO
import doobie.free.connection.pure
import doobie.postgres.syntax.FragmentOps
import doobie.syntax.SqlInterpolator.SingleFragment.fromWrite
import doobie.util.Write
import doobie.util.fragments
import doobie.util.meta.Meta
import doobie.util.update.Update
import fs2.Stream
import typr.dsl.DeleteBuilder
import typr.dsl.SelectBuilder
import typr.dsl.UpdateBuilder
import doobie.syntax.string.toSqlInterpolator

class FootballClubRepoImpl extends FootballClubRepo {
  override def delete: DeleteBuilder[FootballClubFields, FootballClubRow] = DeleteBuilder.of(""""myschema"."football_club"""", FootballClubFields.structure, FootballClubRow.read)

  override def deleteById(id: FootballClubId): ConnectionIO[Boolean] = sql"""delete from "myschema"."football_club" where "id" = ${fromWrite(id)(new Write.Single(FootballClubId.put))}""".update.run.map(_ > 0)

  override def deleteByIds(ids: Array[FootballClubId]): ConnectionIO[Int] = sql"""delete from "myschema"."football_club" where "id" = ANY(${fromWrite(ids)(new Write.Single(FootballClubId.arrayPut))})""".update.run

  override def insert(unsaved: FootballClubRow): ConnectionIO[FootballClubRow] = {
    sql"""insert into "myschema"."football_club"("id", "name")
    values (${fromWrite(unsaved.id)(new Write.Single(FootballClubId.put))}::int8, ${fromWrite(unsaved.name)(new Write.Single(Meta.StringMeta.put))})
    returning "id", "name"
    """.query(FootballClubRow.read).unique
  }

  override def insertStreaming(
    unsaved: Stream[ConnectionIO, FootballClubRow],
    batchSize: Int = 10000
  ): ConnectionIO[Long] = new FragmentOps(sql"""COPY "myschema"."football_club"("id", "name") FROM STDIN""").copyIn(unsaved, batchSize)(FootballClubRow.pgText)

  override def select: SelectBuilder[FootballClubFields, FootballClubRow] = SelectBuilder.of(""""myschema"."football_club"""", FootballClubFields.structure, FootballClubRow.read)

  override def selectAll: Stream[ConnectionIO, FootballClubRow] = sql"""select "id", "name" from "myschema"."football_club"""".query(FootballClubRow.read).stream

  override def selectByFieldValues(fieldValues: List[FootballClubFieldValue[?]]): Stream[ConnectionIO, FootballClubRow] = {
    val where = fragments.whereAndOpt(
      fieldValues.map {
        case FootballClubFieldValue.id(value) => fr""""id" = ${fromWrite(value)(new Write.Single(FootballClubId.put))}"""
        case FootballClubFieldValue.name(value) => fr""""name" = ${fromWrite(value)(new Write.Single(Meta.StringMeta.put))}"""
      }
    )
    sql"""select "id", "name" from "myschema"."football_club" $where""".query(FootballClubRow.read).stream
  }

  override def selectById(id: FootballClubId): ConnectionIO[Option[FootballClubRow]] = sql"""select "id", "name" from "myschema"."football_club" where "id" = ${fromWrite(id)(new Write.Single(FootballClubId.put))}""".query(FootballClubRow.read).option

  override def selectByIds(ids: Array[FootballClubId]): Stream[ConnectionIO, FootballClubRow] = sql"""select "id", "name" from "myschema"."football_club" where "id" = ANY(${fromWrite(ids)(new Write.Single(FootballClubId.arrayPut))})""".query(FootballClubRow.read).stream

  override def selectByIdsTracked(ids: Array[FootballClubId]): ConnectionIO[Map[FootballClubId, FootballClubRow]] = {
    selectByIds(ids).compile.toList.map { rows =>
      val byId = rows.view.map(x => (x.id, x)).toMap
      ids.view.flatMap(id => byId.get(id).map(x => (id, x))).toMap
    }
  }

  override def update: UpdateBuilder[FootballClubFields, FootballClubRow] = UpdateBuilder.of(""""myschema"."football_club"""", FootballClubFields.structure, FootballClubRow.read)

  override def update(row: FootballClubRow): ConnectionIO[Option[FootballClubRow]] = {
    val id = row.id
    sql"""update "myschema"."football_club"
    set "name" = ${fromWrite(row.name)(new Write.Single(Meta.StringMeta.put))}
    where "id" = ${fromWrite(id)(new Write.Single(FootballClubId.put))}
    returning "id", "name"""".query(FootballClubRow.read).option
  }

  override def updateFieldValues(
    id: FootballClubId,
    fieldValues: List[FootballClubFieldValue[?]]
  ): ConnectionIO[Boolean] = {
    NonEmptyList.fromList(fieldValues) match {
      case None => pure(false)
      case Some(nonEmpty) =>
        val updates = fragments.set(
          nonEmpty.map {
            case FootballClubFieldValue.id(value) => fr""""id" = ${fromWrite(value)(new Write.Single(FootballClubId.put))}::int8"""
            case FootballClubFieldValue.name(value) => fr""""name" = ${fromWrite(value)(new Write.Single(Meta.StringMeta.put))}"""
          }
        )
        sql"""update "myschema"."football_club"
        $updates
        where "id" = ${fromWrite(id)(new Write.Single(FootballClubId.put))}""".update.run.map(_ > 0)
    }
  }

  override def upsert(unsaved: FootballClubRow): ConnectionIO[FootballClubRow] = {
    sql"""insert into "myschema"."football_club"("id", "name")
    values (
      ${fromWrite(unsaved.id)(new Write.Single(FootballClubId.put))}::int8,
    ${fromWrite(unsaved.name)(new Write.Single(Meta.StringMeta.put))}
    )
    on conflict ("id")
    do update set
      "name" = EXCLUDED."name"
    returning "id", "name"
    """.query(FootballClubRow.read).unique
  }

  override def upsertBatch(unsaved: List[FootballClubRow]): Stream[ConnectionIO, FootballClubRow] = {
    Update[FootballClubRow](
      s"""insert into "myschema"."football_club"("id", "name")
      values (?::int8,?)
      on conflict ("id")
      do update set
        "name" = EXCLUDED."name"
      returning "id", "name""""
    )(FootballClubRow.write)
    .updateManyWithGeneratedKeys[FootballClubRow]("id", "name")(unsaved)(catsStdInstancesForList, FootballClubRow.read)
  }

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override def upsertStreaming(
    unsaved: Stream[ConnectionIO, FootballClubRow],
    batchSize: Int = 10000
  ): ConnectionIO[Int] = {
    for {
      _ <- sql"""create temporary table football_club_TEMP (like "myschema"."football_club") on commit drop""".update.run
      _ <- new FragmentOps(sql"""copy football_club_TEMP("id", "name") from stdin""").copyIn(unsaved, batchSize)(FootballClubRow.pgText)
      res <- sql"""insert into "myschema"."football_club"("id", "name")
             select * from football_club_TEMP
             on conflict ("id")
             do update set
               "name" = EXCLUDED."name"
             ;
             drop table football_club_TEMP;""".update.run
    } yield res
  }
}