/**
 * File automatically generated by `typo` for its own test suite.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN
 */
package testdb.hardcoded.myschema.marital_status

import testdb.hardcoded.streamingInsert
import typr.dsl.DeleteBuilder
import typr.dsl.SelectBuilder
import typr.dsl.UpdateBuilder
import zio.NonEmptyChunk
import zio.ZIO
import zio.jdbc.SqlFragment
import zio.jdbc.SqlFragment.Segment
import zio.jdbc.UpdateResult
import zio.jdbc.ZConnection
import zio.stream.ZStream
import zio.jdbc.sqlInterpolator

class MaritalStatusRepoImpl extends MaritalStatusRepo {
  override def delete: DeleteBuilder[MaritalStatusFields, MaritalStatusRow] = DeleteBuilder.of(""""myschema"."marital_status"""", MaritalStatusFields.structure, MaritalStatusRow.jdbcDecoder)

  override def deleteById(id: MaritalStatusId): ZIO[ZConnection, Throwable, Boolean] = sql"""delete from "myschema"."marital_status" where "id" = ${Segment.paramSegment(id)(MaritalStatusId.setter)}""".delete.map(_ > 0)

  override def deleteByIds(ids: Array[MaritalStatusId]): ZIO[ZConnection, Throwable, Long] = sql"""delete from "myschema"."marital_status" where "id" = ANY(${Segment.paramSegment(ids)(MaritalStatusId.arraySetter)})""".delete

  override def insert(unsaved: MaritalStatusRow): ZIO[ZConnection, Throwable, MaritalStatusRow] = {
    sql"""insert into "myschema"."marital_status"("id")
    values (${Segment.paramSegment(unsaved.id)(MaritalStatusId.setter)}::int8)
    returning "id"
    """.insertReturning(MaritalStatusRow.jdbcDecoder).map(_.updatedKeys.head)
  }

  override def insertStreaming(
    unsaved: ZStream[ZConnection, Throwable, MaritalStatusRow],
    batchSize: Int = 10000
  ): ZIO[ZConnection, Throwable, Long] = streamingInsert(s"""COPY "myschema"."marital_status"("id") FROM STDIN""", batchSize, unsaved)(MaritalStatusRow.pgText)

  override def select: SelectBuilder[MaritalStatusFields, MaritalStatusRow] = SelectBuilder.of(""""myschema"."marital_status"""", MaritalStatusFields.structure, MaritalStatusRow.jdbcDecoder)

  override def selectAll: ZStream[ZConnection, Throwable, MaritalStatusRow] = sql"""select "id" from "myschema"."marital_status"""".query(MaritalStatusRow.jdbcDecoder).selectStream()

  override def selectByFieldValues(fieldValues: List[MaritalStatusFieldValue[?]]): ZStream[ZConnection, Throwable, MaritalStatusRow] = {
    fieldValues match {
      case Nil      => selectAll
      case nonEmpty =>
        val wheres = SqlFragment.empty.and(
          nonEmpty.map {
            case MaritalStatusFieldValue.id(value) => sql""""id" = ${Segment.paramSegment(value)(MaritalStatusId.setter)}"""
          }
        )
        sql"""select "id" from "myschema"."marital_status" where $wheres""".query(MaritalStatusRow.jdbcDecoder).selectStream()
    }
  }

  override def selectById(id: MaritalStatusId): ZIO[ZConnection, Throwable, Option[MaritalStatusRow]] = sql"""select "id" from "myschema"."marital_status" where "id" = ${Segment.paramSegment(id)(MaritalStatusId.setter)}""".query(MaritalStatusRow.jdbcDecoder).selectOne

  override def selectByIds(ids: Array[MaritalStatusId]): ZStream[ZConnection, Throwable, MaritalStatusRow] = sql"""select "id" from "myschema"."marital_status" where "id" = ANY(${Segment.paramSegment(ids)(MaritalStatusId.arraySetter)})""".query(MaritalStatusRow.jdbcDecoder).selectStream()

  override def selectByIdsTracked(ids: Array[MaritalStatusId]): ZIO[ZConnection, Throwable, Map[MaritalStatusId, MaritalStatusRow]] = {
    selectByIds(ids).runCollect.map { rows =>
      val byId = rows.view.map(x => (x.id, x)).toMap
      ids.view.flatMap(id => byId.get(id).map(x => (id, x))).toMap
    }
  }

  override def update: UpdateBuilder[MaritalStatusFields, MaritalStatusRow] = UpdateBuilder.of(""""myschema"."marital_status"""", MaritalStatusFields.structure, MaritalStatusRow.jdbcDecoder)

  override def updateFieldValues(
    id: MaritalStatusId,
    fieldValues: List[MaritalStatusFieldValue[?]]
  ): ZIO[ZConnection, Throwable, Boolean] = {
    NonEmptyChunk.fromIterableOption(fieldValues) match {
      case None           => ZIO.succeed(false)
      case Some(nonEmpty) =>
        val updates = nonEmpty.map { case MaritalStatusFieldValue.id(value) => sql""""id" = ${Segment.paramSegment(value)(MaritalStatusId.setter)}::int8""" }.mkFragment(SqlFragment(", "))
        sql"""update "myschema"."marital_status"
        set $updates
        where "id" = ${Segment.paramSegment(id)(MaritalStatusId.setter)}
        """.update.map(_ > 0)
    }
  }

  override def upsert(unsaved: MaritalStatusRow): ZIO[ZConnection, Throwable, UpdateResult[MaritalStatusRow]] = {
    sql"""insert into "myschema"."marital_status"("id")
    values (
      ${Segment.paramSegment(unsaved.id)(MaritalStatusId.setter)}::int8
    )
    on conflict ("id")
    do update set "id" = EXCLUDED."id"
    returning "id"""".insertReturning(MaritalStatusRow.jdbcDecoder)
  }

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override def upsertStreaming(
    unsaved: ZStream[ZConnection, Throwable, MaritalStatusRow],
    batchSize: Int = 10000
  ): ZIO[ZConnection, Throwable, Long] = {
    val created = sql"""create temporary table marital_status_TEMP (like "myschema"."marital_status") on commit drop""".execute
    val copied = streamingInsert(s"""copy marital_status_TEMP("id") from stdin""", batchSize, unsaved)(MaritalStatusRow.pgText)
    val merged = sql"""insert into "myschema"."marital_status"("id")
    select * from marital_status_TEMP
    on conflict ("id")
    do nothing
    ;
    drop table marital_status_TEMP;""".update
    created *> copied *> merged
  }
}