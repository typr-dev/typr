/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.inventory;

import static typo.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import testdb.products.ProductsId;
import testdb.warehouses.WarehousesId;
import typo.dsl.DeleteBuilder;
import typo.dsl.Dialect;
import typo.dsl.SelectBuilder;
import typo.dsl.UpdateBuilder;
import typo.runtime.Fragment;
import typo.runtime.MariaTypes;

public class InventoryRepoImpl implements InventoryRepo {
  @Override
  public DeleteBuilder<InventoryFields, InventoryRow> delete() {
    return DeleteBuilder.of("`inventory`", InventoryFields.structure(), Dialect.MARIADB);
  }
  ;

  @Override
  public Boolean deleteById(InventoryId inventoryId, Connection c) {
    return interpolate(
                Fragment.lit("delete from `inventory` where `inventory_id` = "),
                Fragment.encode(InventoryId.pgType, inventoryId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(InventoryId[] inventoryIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : inventoryIds) {
      fragments.add(Fragment.encode(InventoryId.pgType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from `inventory` where `inventory_id` in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public InventoryRow insert(InventoryRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into `inventory`(`product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`)\n"
                    + "values ("),
            Fragment.encode(ProductsId.pgType, unsaved.productId()),
            Fragment.lit(", "),
            Fragment.encode(WarehousesId.pgType, unsaved.warehouseId()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.quantityOnHand()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.quantityReserved()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.quantityOnOrder()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.reorderPoint()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.reorderQuantity()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.varchar.opt(), unsaved.binLocation()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.datetime.opt(), unsaved.lastCountedAt()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.datetime, unsaved.updatedAt()),
            Fragment.lit(
                ")\n"
                    + "RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`\n"))
        .updateReturning(InventoryRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public InventoryRow insert(InventoryRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("`product_id`"));
    values.add(
        interpolate(Fragment.encode(ProductsId.pgType, unsaved.productId()), Fragment.lit("")));
    columns.add(Fragment.lit("`warehouse_id`"));
    values.add(
        interpolate(Fragment.encode(WarehousesId.pgType, unsaved.warehouseId()), Fragment.lit("")));
    unsaved
        .quantityOnHand()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`quantity_on_hand`"));
              values.add(interpolate(Fragment.encode(MariaTypes.int_, value), Fragment.lit("")));
            });
    ;
    unsaved
        .quantityReserved()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`quantity_reserved`"));
              values.add(interpolate(Fragment.encode(MariaTypes.int_, value), Fragment.lit("")));
            });
    ;
    unsaved
        .quantityOnOrder()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`quantity_on_order`"));
              values.add(interpolate(Fragment.encode(MariaTypes.int_, value), Fragment.lit("")));
            });
    ;
    unsaved
        .reorderPoint()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`reorder_point`"));
              values.add(interpolate(Fragment.encode(MariaTypes.int_, value), Fragment.lit("")));
            });
    ;
    unsaved
        .reorderQuantity()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`reorder_quantity`"));
              values.add(interpolate(Fragment.encode(MariaTypes.int_, value), Fragment.lit("")));
            });
    ;
    unsaved
        .binLocation()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`bin_location`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.varchar.opt(), value), Fragment.lit("")));
            });
    ;
    unsaved
        .lastCountedAt()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`last_counted_at`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.datetime.opt(), value), Fragment.lit("")));
            });
    ;
    unsaved
        .updatedAt()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`updated_at`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.datetime, value), Fragment.lit("")));
            });
    ;
    Fragment q =
        interpolate(
            Fragment.lit("insert into `inventory`("),
            Fragment.comma(columns),
            Fragment.lit(")\nvalues ("),
            Fragment.comma(values),
            Fragment.lit(
                ")\n"
                    + "RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`\n"));
    ;
    return q.updateReturning(InventoryRow._rowParser.exactlyOne()).runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<InventoryFields, InventoryRow> select() {
    return SelectBuilder.of(
        "`inventory`", InventoryFields.structure(), InventoryRow._rowParser, Dialect.MARIADB);
  }
  ;

  @Override
  public List<InventoryRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit(
                "select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`\n"
                    + "from `inventory`\n"))
        .query(InventoryRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<InventoryRow> selectById(InventoryId inventoryId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`\n"
                    + "from `inventory`\n"
                    + "where `inventory_id` = "),
            Fragment.encode(InventoryId.pgType, inventoryId),
            Fragment.lit(""))
        .query(InventoryRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<InventoryRow> selectByIds(InventoryId[] inventoryIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : inventoryIds) {
      fragments.add(Fragment.encode(InventoryId.pgType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at` from"
                    + " `inventory` where `inventory_id` in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(InventoryRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<InventoryId, InventoryRow> selectByIdsTracked(
      InventoryId[] inventoryIds, Connection c) {
    HashMap<InventoryId, InventoryRow> ret = new HashMap<InventoryId, InventoryRow>();
    selectByIds(inventoryIds, c).forEach(row -> ret.put(row.inventoryId(), row));
    return ret;
  }
  ;

  @Override
  public Optional<InventoryRow> selectByUniqueProductIdAndWarehouseId(
      ProductsId productId, WarehousesId warehouseId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`\n"
                    + "from `inventory`\n"
                    + "where `product_id` = "),
            Fragment.encode(ProductsId.pgType, productId),
            Fragment.lit(" AND `warehouse_id` = "),
            Fragment.encode(WarehousesId.pgType, warehouseId),
            Fragment.lit("\n"))
        .query(InventoryRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public UpdateBuilder<InventoryFields, InventoryRow> update() {
    return UpdateBuilder.of(
        "`inventory`", InventoryFields.structure(), InventoryRow._rowParser, Dialect.MARIADB);
  }
  ;

  @Override
  public Boolean update(InventoryRow row, Connection c) {
    InventoryId inventoryId = row.inventoryId();
    ;
    return interpolate(
                Fragment.lit("update `inventory`\nset `product_id` = "),
                Fragment.encode(ProductsId.pgType, row.productId()),
                Fragment.lit(",\n`warehouse_id` = "),
                Fragment.encode(WarehousesId.pgType, row.warehouseId()),
                Fragment.lit(",\n`quantity_on_hand` = "),
                Fragment.encode(MariaTypes.int_, row.quantityOnHand()),
                Fragment.lit(",\n`quantity_reserved` = "),
                Fragment.encode(MariaTypes.int_, row.quantityReserved()),
                Fragment.lit(",\n`quantity_on_order` = "),
                Fragment.encode(MariaTypes.int_, row.quantityOnOrder()),
                Fragment.lit(",\n`reorder_point` = "),
                Fragment.encode(MariaTypes.int_, row.reorderPoint()),
                Fragment.lit(",\n`reorder_quantity` = "),
                Fragment.encode(MariaTypes.int_, row.reorderQuantity()),
                Fragment.lit(",\n`bin_location` = "),
                Fragment.encode(MariaTypes.varchar.opt(), row.binLocation()),
                Fragment.lit(",\n`last_counted_at` = "),
                Fragment.encode(MariaTypes.datetime.opt(), row.lastCountedAt()),
                Fragment.lit(",\n`updated_at` = "),
                Fragment.encode(MariaTypes.datetime, row.updatedAt()),
                Fragment.lit("\nwhere `inventory_id` = "),
                Fragment.encode(InventoryId.pgType, inventoryId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public InventoryRow upsert(InventoryRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "INSERT INTO `inventory`(`product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`)\n"
                    + "VALUES ("),
            Fragment.encode(ProductsId.pgType, unsaved.productId()),
            Fragment.lit(", "),
            Fragment.encode(WarehousesId.pgType, unsaved.warehouseId()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.quantityOnHand()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.quantityReserved()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.quantityOnOrder()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.reorderPoint()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.int_, unsaved.reorderQuantity()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.varchar.opt(), unsaved.binLocation()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.datetime.opt(), unsaved.lastCountedAt()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.datetime, unsaved.updatedAt()),
            Fragment.lit(
                ")\n"
                    + "ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),\n"
                    + "`warehouse_id` = VALUES(`warehouse_id`),\n"
                    + "`quantity_on_hand` = VALUES(`quantity_on_hand`),\n"
                    + "`quantity_reserved` = VALUES(`quantity_reserved`),\n"
                    + "`quantity_on_order` = VALUES(`quantity_on_order`),\n"
                    + "`reorder_point` = VALUES(`reorder_point`),\n"
                    + "`reorder_quantity` = VALUES(`reorder_quantity`),\n"
                    + "`bin_location` = VALUES(`bin_location`),\n"
                    + "`last_counted_at` = VALUES(`last_counted_at`),\n"
                    + "`updated_at` = VALUES(`updated_at`)\n"
                    + "RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`"))
        .updateReturning(InventoryRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<InventoryRow> upsertBatch(Iterator<InventoryRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "INSERT INTO `inventory`(`inventory_id`, `product_id`, `warehouse_id`,"
                    + " `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`,"
                    + " `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`,"
                    + " `updated_at`)\n"
                    + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n"
                    + "ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),\n"
                    + "`warehouse_id` = VALUES(`warehouse_id`),\n"
                    + "`quantity_on_hand` = VALUES(`quantity_on_hand`),\n"
                    + "`quantity_reserved` = VALUES(`quantity_reserved`),\n"
                    + "`quantity_on_order` = VALUES(`quantity_on_order`),\n"
                    + "`reorder_point` = VALUES(`reorder_point`),\n"
                    + "`reorder_quantity` = VALUES(`reorder_quantity`),\n"
                    + "`bin_location` = VALUES(`bin_location`),\n"
                    + "`last_counted_at` = VALUES(`last_counted_at`),\n"
                    + "`updated_at` = VALUES(`updated_at`)\n"
                    + "RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`,"
                    + " `quantity_reserved`, `quantity_on_order`, `reorder_point`,"
                    + " `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`"))
        .updateReturningEach(InventoryRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
