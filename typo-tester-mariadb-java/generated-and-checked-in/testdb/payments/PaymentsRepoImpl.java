/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.payments;

import static typo.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import testdb.orders.OrdersId;
import testdb.payment_methods.PaymentMethodsId;
import typo.dsl.DeleteBuilder;
import typo.dsl.Dialect;
import typo.dsl.SelectBuilder;
import typo.dsl.UpdateBuilder;
import typo.runtime.Fragment;
import typo.runtime.MariaTypes;

public class PaymentsRepoImpl implements PaymentsRepo {
  @Override
  public DeleteBuilder<PaymentsFields, PaymentsRow> delete() {
    return DeleteBuilder.of("`payments`", PaymentsFields.structure(), Dialect.MARIADB);
  }
  ;

  @Override
  public Boolean deleteById(PaymentsId paymentId, Connection c) {
    return interpolate(
                Fragment.lit("delete from `payments` where `payment_id` = "),
                Fragment.encode(PaymentsId.pgType, paymentId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(PaymentsId[] paymentIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : paymentIds) {
      fragments.add(Fragment.encode(PaymentsId.pgType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from `payments` where `payment_id` in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public PaymentsRow insert(PaymentsRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into `payments`(`order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`)\n"
                    + "values ("),
            Fragment.encode(OrdersId.pgType, unsaved.orderId()),
            Fragment.lit(", "),
            Fragment.encode(PaymentMethodsId.pgType, unsaved.methodId()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.varchar.opt(), unsaved.transactionId()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.numeric, unsaved.amount()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.char_, unsaved.currencyCode()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.text, unsaved.status()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.longtext.opt(), unsaved.processorResponse()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.varchar.opt(), unsaved.errorMessage()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.inet6.opt(), unsaved.ipAddress()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.datetime, unsaved.createdAt()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.datetime.opt(), unsaved.processedAt()),
            Fragment.lit(
                ")\n"
                    + "RETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`\n"))
        .updateReturning(PaymentsRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public PaymentsRow insert(PaymentsRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("`order_id`"));
    values.add(interpolate(Fragment.encode(OrdersId.pgType, unsaved.orderId()), Fragment.lit("")));
    columns.add(Fragment.lit("`method_id`"));
    values.add(
        interpolate(
            Fragment.encode(PaymentMethodsId.pgType, unsaved.methodId()), Fragment.lit("")));
    columns.add(Fragment.lit("`amount`"));
    values.add(
        interpolate(Fragment.encode(MariaTypes.numeric, unsaved.amount()), Fragment.lit("")));
    unsaved
        .transactionId()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`transaction_id`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.varchar.opt(), value), Fragment.lit("")));
            });
    ;
    unsaved
        .currencyCode()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`currency_code`"));
              values.add(interpolate(Fragment.encode(MariaTypes.char_, value), Fragment.lit("")));
            });
    ;
    unsaved
        .status()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`status`"));
              values.add(interpolate(Fragment.encode(MariaTypes.text, value), Fragment.lit("")));
            });
    ;
    unsaved
        .processorResponse()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`processor_response`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.longtext.opt(), value), Fragment.lit("")));
            });
    ;
    unsaved
        .errorMessage()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`error_message`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.varchar.opt(), value), Fragment.lit("")));
            });
    ;
    unsaved
        .ipAddress()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`ip_address`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.inet6.opt(), value), Fragment.lit("")));
            });
    ;
    unsaved
        .createdAt()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`created_at`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.datetime, value), Fragment.lit("")));
            });
    ;
    unsaved
        .processedAt()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`processed_at`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.datetime.opt(), value), Fragment.lit("")));
            });
    ;
    Fragment q =
        interpolate(
            Fragment.lit("insert into `payments`("),
            Fragment.comma(columns),
            Fragment.lit(")\nvalues ("),
            Fragment.comma(values),
            Fragment.lit(
                ")\n"
                    + "RETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`\n"));
    ;
    return q.updateReturning(PaymentsRow._rowParser.exactlyOne()).runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<PaymentsFields, PaymentsRow> select() {
    return SelectBuilder.of(
        "`payments`", PaymentsFields.structure(), PaymentsRow._rowParser, Dialect.MARIADB);
  }
  ;

  @Override
  public List<PaymentsRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit(
                "select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`\n"
                    + "from `payments`\n"))
        .query(PaymentsRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<PaymentsRow> selectById(PaymentsId paymentId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`\n"
                    + "from `payments`\n"
                    + "where `payment_id` = "),
            Fragment.encode(PaymentsId.pgType, paymentId),
            Fragment.lit(""))
        .query(PaymentsRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<PaymentsRow> selectByIds(PaymentsId[] paymentIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : paymentIds) {
      fragments.add(Fragment.encode(PaymentsId.pgType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at` from `payments` where"
                    + " `payment_id` in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(PaymentsRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<PaymentsId, PaymentsRow> selectByIdsTracked(PaymentsId[] paymentIds, Connection c) {
    HashMap<PaymentsId, PaymentsRow> ret = new HashMap<PaymentsId, PaymentsRow>();
    selectByIds(paymentIds, c).forEach(row -> ret.put(row.paymentId(), row));
    return ret;
  }
  ;

  @Override
  public UpdateBuilder<PaymentsFields, PaymentsRow> update() {
    return UpdateBuilder.of(
        "`payments`", PaymentsFields.structure(), PaymentsRow._rowParser, Dialect.MARIADB);
  }
  ;

  @Override
  public Boolean update(PaymentsRow row, Connection c) {
    PaymentsId paymentId = row.paymentId();
    ;
    return interpolate(
                Fragment.lit("update `payments`\nset `order_id` = "),
                Fragment.encode(OrdersId.pgType, row.orderId()),
                Fragment.lit(",\n`method_id` = "),
                Fragment.encode(PaymentMethodsId.pgType, row.methodId()),
                Fragment.lit(",\n`transaction_id` = "),
                Fragment.encode(MariaTypes.varchar.opt(), row.transactionId()),
                Fragment.lit(",\n`amount` = "),
                Fragment.encode(MariaTypes.numeric, row.amount()),
                Fragment.lit(",\n`currency_code` = "),
                Fragment.encode(MariaTypes.char_, row.currencyCode()),
                Fragment.lit(",\n`status` = "),
                Fragment.encode(MariaTypes.text, row.status()),
                Fragment.lit(",\n`processor_response` = "),
                Fragment.encode(MariaTypes.longtext.opt(), row.processorResponse()),
                Fragment.lit(",\n`error_message` = "),
                Fragment.encode(MariaTypes.varchar.opt(), row.errorMessage()),
                Fragment.lit(",\n`ip_address` = "),
                Fragment.encode(MariaTypes.inet6.opt(), row.ipAddress()),
                Fragment.lit(",\n`created_at` = "),
                Fragment.encode(MariaTypes.datetime, row.createdAt()),
                Fragment.lit(",\n`processed_at` = "),
                Fragment.encode(MariaTypes.datetime.opt(), row.processedAt()),
                Fragment.lit("\nwhere `payment_id` = "),
                Fragment.encode(PaymentsId.pgType, paymentId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public PaymentsRow upsert(PaymentsRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "INSERT INTO `payments`(`order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`)\n"
                    + "VALUES ("),
            Fragment.encode(OrdersId.pgType, unsaved.orderId()),
            Fragment.lit(", "),
            Fragment.encode(PaymentMethodsId.pgType, unsaved.methodId()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.varchar.opt(), unsaved.transactionId()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.numeric, unsaved.amount()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.char_, unsaved.currencyCode()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.text, unsaved.status()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.longtext.opt(), unsaved.processorResponse()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.varchar.opt(), unsaved.errorMessage()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.inet6.opt(), unsaved.ipAddress()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.datetime, unsaved.createdAt()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.datetime.opt(), unsaved.processedAt()),
            Fragment.lit(
                ")\n"
                    + "ON DUPLICATE KEY UPDATE `order_id` = VALUES(`order_id`),\n"
                    + "`method_id` = VALUES(`method_id`),\n"
                    + "`transaction_id` = VALUES(`transaction_id`),\n"
                    + "`amount` = VALUES(`amount`),\n"
                    + "`currency_code` = VALUES(`currency_code`),\n"
                    + "`status` = VALUES(`status`),\n"
                    + "`processor_response` = VALUES(`processor_response`),\n"
                    + "`error_message` = VALUES(`error_message`),\n"
                    + "`ip_address` = VALUES(`ip_address`),\n"
                    + "`created_at` = VALUES(`created_at`),\n"
                    + "`processed_at` = VALUES(`processed_at`)\n"
                    + "RETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`"))
        .updateReturning(PaymentsRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<PaymentsRow> upsertBatch(Iterator<PaymentsRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "INSERT INTO `payments`(`payment_id`, `order_id`, `method_id`, `transaction_id`,"
                    + " `amount`, `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`)\n"
                    + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n"
                    + "ON DUPLICATE KEY UPDATE `order_id` = VALUES(`order_id`),\n"
                    + "`method_id` = VALUES(`method_id`),\n"
                    + "`transaction_id` = VALUES(`transaction_id`),\n"
                    + "`amount` = VALUES(`amount`),\n"
                    + "`currency_code` = VALUES(`currency_code`),\n"
                    + "`status` = VALUES(`status`),\n"
                    + "`processor_response` = VALUES(`processor_response`),\n"
                    + "`error_message` = VALUES(`error_message`),\n"
                    + "`ip_address` = VALUES(`ip_address`),\n"
                    + "`created_at` = VALUES(`created_at`),\n"
                    + "`processed_at` = VALUES(`processed_at`)\n"
                    + "RETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`,"
                    + " `currency_code`, `status`, `processor_response`, `error_message`,"
                    + " `ip_address`, `created_at`, `processed_at`"))
        .updateReturningEach(PaymentsRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
