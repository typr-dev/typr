/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.reviews

import java.sql.Connection
import java.util.ArrayList
import java.util.HashMap
import java.util.Optional
import testdb.customers.CustomersId
import testdb.order_items.OrderItemsId
import testdb.products.ProductsId
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.MariaTypes
import typo.runtime.FragmentInterpolator.interpolate

class ReviewsRepoImpl extends ReviewsRepo {
  override def delete: DeleteBuilder[ReviewsFields, ReviewsRow] = DeleteBuilder.of("`reviews`", ReviewsFields.structure, Dialect.MARIADB)

  override def deleteById(reviewId: ReviewsId)(using c: Connection): java.lang.Boolean = interpolate"delete from `reviews` where `review_id` = ${ReviewsId.pgType.encode(reviewId)}".update().runUnchecked(c) > 0

  override def deleteByIds(reviewIds: Array[ReviewsId])(using c: Connection): Integer = {
    val fragments: ArrayList[Fragment] = new ArrayList[Fragment]()
    reviewIds.foreach { id => fragments.add(ReviewsId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("delete from `reviews` where `review_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: ReviewsRow)(using c: Connection): ReviewsRow = {
  interpolate"""insert into `reviews`(`product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`)
    values (${ProductsId.pgType.encode(unsaved.productId)}, ${CustomersId.pgType.encode(unsaved.customerId)}, ${OrderItemsId.pgType.opt().encode(unsaved.orderItemId)}, ${MariaTypes.smallint.encode(unsaved.rating)}, ${MariaTypes.text.opt().encode(unsaved.title)}, ${MariaTypes.text.opt().encode(unsaved.content)}, ${MariaTypes.text.opt().encode(unsaved.pros)}, ${MariaTypes.text.opt().encode(unsaved.cons)}, ${MariaTypes.text.opt().encode(unsaved.images)}, ${MariaTypes.bool.encode(unsaved.isVerifiedPurchase)}, ${MariaTypes.bool.encode(unsaved.isApproved)}, ${MariaTypes.bigint.encode(unsaved.helpfulVotes)}, ${MariaTypes.bigint.encode(unsaved.unhelpfulVotes)}, ${MariaTypes.text.opt().encode(unsaved.adminResponse)}, ${MariaTypes.datetime.opt().encode(unsaved.respondedAt)}, ${MariaTypes.datetime.encode(unsaved.createdAt)}, ${MariaTypes.datetime.encode(unsaved.updatedAt)})
    returning `review_id`, `product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`
    """
    .updateReturning(ReviewsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: ReviewsRowUnsaved)(using c: Connection): ReviewsRow = {
    val columns: ArrayList[Literal] = new ArrayList[Literal]()
    val values: ArrayList[Fragment] = new ArrayList[Fragment]()
    columns.add(Fragment.lit("`product_id`")): @scala.annotation.nowarn
    values.add(interpolate"${ProductsId.pgType.encode(unsaved.productId)}"): @scala.annotation.nowarn
    columns.add(Fragment.lit("`customer_id`")): @scala.annotation.nowarn
    values.add(interpolate"${CustomersId.pgType.encode(unsaved.customerId)}"): @scala.annotation.nowarn
    columns.add(Fragment.lit("`rating`")): @scala.annotation.nowarn
    values.add(interpolate"${MariaTypes.smallint.encode(unsaved.rating)}"): @scala.annotation.nowarn
    unsaved.orderItemId.visit(
      {  },
      value => { columns.add(Fragment.lit("`order_item_id`")): @scala.annotation.nowarn; values.add(interpolate"${OrderItemsId.pgType.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.title.visit(
      {  },
      value => { columns.add(Fragment.lit("`title`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.text.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.content.visit(
      {  },
      value => { columns.add(Fragment.lit("`content`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.text.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.pros.visit(
      {  },
      value => { columns.add(Fragment.lit("`pros`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.text.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.cons.visit(
      {  },
      value => { columns.add(Fragment.lit("`cons`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.text.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.images.visit(
      {  },
      value => { columns.add(Fragment.lit("`images`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.text.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.isVerifiedPurchase.visit(
      {  },
      value => { columns.add(Fragment.lit("`is_verified_purchase`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.bool.encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.isApproved.visit(
      {  },
      value => { columns.add(Fragment.lit("`is_approved`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.bool.encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.helpfulVotes.visit(
      {  },
      value => { columns.add(Fragment.lit("`helpful_votes`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.bigint.encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.unhelpfulVotes.visit(
      {  },
      value => { columns.add(Fragment.lit("`unhelpful_votes`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.bigint.encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.adminResponse.visit(
      {  },
      value => { columns.add(Fragment.lit("`admin_response`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.text.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.respondedAt.visit(
      {  },
      value => { columns.add(Fragment.lit("`responded_at`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.datetime.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.createdAt.visit(
      {  },
      value => { columns.add(Fragment.lit("`created_at`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.datetime.encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.updatedAt.visit(
      {  },
      value => { columns.add(Fragment.lit("`updated_at`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.datetime.encode(value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      interpolate"""insert into `reviews`(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      returning `review_id`, `product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`
      """
    }
    return q.updateReturning(ReviewsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[ReviewsFields, ReviewsRow] = SelectBuilder.of("`reviews`", ReviewsFields.structure, ReviewsRow.`_rowParser`, Dialect.MARIADB)

  override def selectAll(using c: Connection): java.util.List[ReviewsRow] = {
    interpolate"""select `review_id`, `product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`
    from `reviews`
    """.query(ReviewsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(reviewId: ReviewsId)(using c: Connection): Optional[ReviewsRow] = {
    interpolate"""select `review_id`, `product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`
    from `reviews`
    where `review_id` = ${ReviewsId.pgType.encode(reviewId)}""".query(ReviewsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(reviewIds: Array[ReviewsId])(using c: Connection): java.util.List[ReviewsRow] = {
    val fragments: ArrayList[Fragment] = new ArrayList[Fragment]()
    reviewIds.foreach { id => fragments.add(ReviewsId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("select `review_id`, `product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at` from `reviews` where `review_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).query(ReviewsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(reviewIds: Array[ReviewsId])(using c: Connection): java.util.Map[ReviewsId, ReviewsRow] = {
    val ret: HashMap[ReviewsId, ReviewsRow] = new HashMap[ReviewsId, ReviewsRow]()
    selectByIds(reviewIds)(using c).forEach(row => ret.put(row.reviewId, row): @scala.annotation.nowarn)
    return ret
  }

  override def update: UpdateBuilder[ReviewsFields, ReviewsRow] = UpdateBuilder.of("`reviews`", ReviewsFields.structure, ReviewsRow.`_rowParser`.all(), Dialect.MARIADB)

  override def update(row: ReviewsRow)(using c: Connection): java.lang.Boolean = {
    val reviewId: ReviewsId = row.reviewId
    return interpolate"""update `reviews`
    set `product_id` = ${ProductsId.pgType.encode(row.productId)},
    `customer_id` = ${CustomersId.pgType.encode(row.customerId)},
    `order_item_id` = ${OrderItemsId.pgType.opt().encode(row.orderItemId)},
    `rating` = ${MariaTypes.smallint.encode(row.rating)},
    `title` = ${MariaTypes.text.opt().encode(row.title)},
    `content` = ${MariaTypes.text.opt().encode(row.content)},
    `pros` = ${MariaTypes.text.opt().encode(row.pros)},
    `cons` = ${MariaTypes.text.opt().encode(row.cons)},
    `images` = ${MariaTypes.text.opt().encode(row.images)},
    `is_verified_purchase` = ${MariaTypes.bool.encode(row.isVerifiedPurchase)},
    `is_approved` = ${MariaTypes.bool.encode(row.isApproved)},
    `helpful_votes` = ${MariaTypes.bigint.encode(row.helpfulVotes)},
    `unhelpful_votes` = ${MariaTypes.bigint.encode(row.unhelpfulVotes)},
    `admin_response` = ${MariaTypes.text.opt().encode(row.adminResponse)},
    `responded_at` = ${MariaTypes.datetime.opt().encode(row.respondedAt)},
    `created_at` = ${MariaTypes.datetime.encode(row.createdAt)},
    `updated_at` = ${MariaTypes.datetime.encode(row.updatedAt)}
    where `review_id` = ${ReviewsId.pgType.encode(reviewId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: ReviewsRow)(using c: Connection): ReviewsRow = {
  interpolate"""INSERT INTO `reviews`(`product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`)
    VALUES (${ProductsId.pgType.encode(unsaved.productId)}, ${CustomersId.pgType.encode(unsaved.customerId)}, ${OrderItemsId.pgType.opt().encode(unsaved.orderItemId)}, ${MariaTypes.smallint.encode(unsaved.rating)}, ${MariaTypes.text.opt().encode(unsaved.title)}, ${MariaTypes.text.opt().encode(unsaved.content)}, ${MariaTypes.text.opt().encode(unsaved.pros)}, ${MariaTypes.text.opt().encode(unsaved.cons)}, ${MariaTypes.text.opt().encode(unsaved.images)}, ${MariaTypes.bool.encode(unsaved.isVerifiedPurchase)}, ${MariaTypes.bool.encode(unsaved.isApproved)}, ${MariaTypes.bigint.encode(unsaved.helpfulVotes)}, ${MariaTypes.bigint.encode(unsaved.unhelpfulVotes)}, ${MariaTypes.text.opt().encode(unsaved.adminResponse)}, ${MariaTypes.datetime.opt().encode(unsaved.respondedAt)}, ${MariaTypes.datetime.encode(unsaved.createdAt)}, ${MariaTypes.datetime.encode(unsaved.updatedAt)})
    ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),
    `customer_id` = VALUES(`customer_id`),
    `order_item_id` = VALUES(`order_item_id`),
    `rating` = VALUES(`rating`),
    `title` = VALUES(`title`),
    `content` = VALUES(`content`),
    `pros` = VALUES(`pros`),
    `cons` = VALUES(`cons`),
    `images` = VALUES(`images`),
    `is_verified_purchase` = VALUES(`is_verified_purchase`),
    `is_approved` = VALUES(`is_approved`),
    `helpful_votes` = VALUES(`helpful_votes`),
    `unhelpful_votes` = VALUES(`unhelpful_votes`),
    `admin_response` = VALUES(`admin_response`),
    `responded_at` = VALUES(`responded_at`),
    `created_at` = VALUES(`created_at`),
    `updated_at` = VALUES(`updated_at`)
    RETURNING `review_id`, `product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`"""
    .updateReturning(ReviewsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: java.util.Iterator[ReviewsRow])(using c: Connection): java.util.List[ReviewsRow] = {
    interpolate"""INSERT INTO `reviews`(`review_id`, `product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),
    `customer_id` = VALUES(`customer_id`),
    `order_item_id` = VALUES(`order_item_id`),
    `rating` = VALUES(`rating`),
    `title` = VALUES(`title`),
    `content` = VALUES(`content`),
    `pros` = VALUES(`pros`),
    `cons` = VALUES(`cons`),
    `images` = VALUES(`images`),
    `is_verified_purchase` = VALUES(`is_verified_purchase`),
    `is_approved` = VALUES(`is_approved`),
    `helpful_votes` = VALUES(`helpful_votes`),
    `unhelpful_votes` = VALUES(`unhelpful_votes`),
    `admin_response` = VALUES(`admin_response`),
    `responded_at` = VALUES(`responded_at`),
    `created_at` = VALUES(`created_at`),
    `updated_at` = VALUES(`updated_at`)
    RETURNING `review_id`, `product_id`, `customer_id`, `order_item_id`, `rating`, `title`, `content`, `pros`, `cons`, `images`, `is_verified_purchase`, `is_approved`, `helpful_votes`, `unhelpful_votes`, `admin_response`, `responded_at`, `created_at`, `updated_at`"""
      .updateReturningEach(ReviewsRow.`_rowParser`, unsaved)
      .runUnchecked(c)
  }
}