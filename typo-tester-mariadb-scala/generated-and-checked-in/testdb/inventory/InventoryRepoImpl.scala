/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.inventory

import java.sql.Connection
import scala.collection.mutable.ListBuffer
import testdb.products.ProductsId
import testdb.warehouses.WarehousesId
import typo.runtime.MariaTypes
import typo.scaladsl.DeleteBuilder
import typo.scaladsl.Dialect
import typo.scaladsl.Fragment
import typo.scaladsl.MariaTypeOps
import typo.scaladsl.ScalaDbTypes
import typo.scaladsl.SelectBuilder
import typo.scaladsl.UpdateBuilder
import typo.scaladsl.Fragment.sql

class InventoryRepoImpl extends InventoryRepo {
  override def delete: DeleteBuilder[InventoryFields, InventoryRow] = DeleteBuilder.of("`inventory`", InventoryFields.structure, Dialect.MARIADB)

  override def deleteById(inventoryId: InventoryId)(using c: Connection): Boolean = sql"delete from `inventory` where `inventory_id` = ${Fragment.encode(InventoryId.pgType, inventoryId)}".update().runUnchecked(c) > 0

  override def deleteByIds(inventoryIds: Array[InventoryId])(using c: Connection): Int = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    inventoryIds.foreach { id => fragments.addOne(Fragment.encode(InventoryId.pgType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("delete from `inventory` where `inventory_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: InventoryRow)(using c: Connection): InventoryRow = {
  sql"""insert into `inventory`(`product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`)
    values (${Fragment.encode(ProductsId.pgType, unsaved.productId)}, ${Fragment.encode(WarehousesId.pgType, unsaved.warehouseId)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.quantityOnHand)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.quantityReserved)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.quantityOnOrder)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.reorderPoint)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.reorderQuantity)}, ${Fragment.encode(MariaTypes.varchar.nullable, unsaved.binLocation)}, ${Fragment.encode(MariaTypes.datetime.nullable, unsaved.lastCountedAt)}, ${Fragment.encode(MariaTypes.datetime, unsaved.updatedAt)})
    RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
    """
    .updateReturning(InventoryRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: InventoryRowUnsaved)(using c: Connection): InventoryRow = {
    val columns: ListBuffer[Fragment] = ListBuffer()
    val values: ListBuffer[Fragment] = ListBuffer()
    columns.addOne(Fragment.lit("`product_id`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ProductsId.pgType, unsaved.productId)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`warehouse_id`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(WarehousesId.pgType, unsaved.warehouseId)}"): @scala.annotation.nowarn
    unsaved.quantityOnHand.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`quantity_on_hand`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.int_, value)}"): @scala.annotation.nowarn }
    );
    unsaved.quantityReserved.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`quantity_reserved`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.int_, value)}"): @scala.annotation.nowarn }
    );
    unsaved.quantityOnOrder.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`quantity_on_order`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.int_, value)}"): @scala.annotation.nowarn }
    );
    unsaved.reorderPoint.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`reorder_point`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.int_, value)}"): @scala.annotation.nowarn }
    );
    unsaved.reorderQuantity.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`reorder_quantity`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.int_, value)}"): @scala.annotation.nowarn }
    );
    unsaved.binLocation.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`bin_location`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.varchar.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.lastCountedAt.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`last_counted_at`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.datetime.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.updatedAt.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`updated_at`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.datetime, value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      sql"""insert into `inventory`(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
      """
    }
    return q.updateReturning(InventoryRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[InventoryFields, InventoryRow] = SelectBuilder.of("`inventory`", InventoryFields.structure, InventoryRow.`_rowParser`, Dialect.MARIADB)

  override def selectAll(using c: Connection): List[InventoryRow] = {
    sql"""select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
    from `inventory`
    """.query(InventoryRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(inventoryId: InventoryId)(using c: Connection): Option[InventoryRow] = {
    sql"""select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
    from `inventory`
    where `inventory_id` = ${Fragment.encode(InventoryId.pgType, inventoryId)}""".query(InventoryRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(inventoryIds: Array[InventoryId])(using c: Connection): List[InventoryRow] = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    inventoryIds.foreach { id => fragments.addOne(Fragment.encode(InventoryId.pgType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at` from `inventory` where `inventory_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).query(InventoryRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(inventoryIds: Array[InventoryId])(using c: Connection): Map[InventoryId, InventoryRow] = {
    val ret: scala.collection.mutable.Map[InventoryId, InventoryRow] = scala.collection.mutable.Map.empty[InventoryId, InventoryRow]
    selectByIds(inventoryIds)(using c).foreach(row => ret.put(row.inventoryId, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def selectByUniqueProductIdAndWarehouseId(
    productId: ProductsId,
    warehouseId: WarehousesId
  )(using c: Connection): Option[InventoryRow] = {
    sql"""select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
    from `inventory`
    where `product_id` = ${Fragment.encode(ProductsId.pgType, productId)} AND `warehouse_id` = ${Fragment.encode(WarehousesId.pgType, warehouseId)}
    """.query(InventoryRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def update: UpdateBuilder[InventoryFields, InventoryRow] = UpdateBuilder.of("`inventory`", InventoryFields.structure, InventoryRow.`_rowParser`, Dialect.MARIADB)

  override def update(row: InventoryRow)(using c: Connection): Boolean = {
    val inventoryId: InventoryId = row.inventoryId
    return sql"""update `inventory`
    set `product_id` = ${Fragment.encode(ProductsId.pgType, row.productId)},
    `warehouse_id` = ${Fragment.encode(WarehousesId.pgType, row.warehouseId)},
    `quantity_on_hand` = ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, row.quantityOnHand)},
    `quantity_reserved` = ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, row.quantityReserved)},
    `quantity_on_order` = ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, row.quantityOnOrder)},
    `reorder_point` = ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, row.reorderPoint)},
    `reorder_quantity` = ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, row.reorderQuantity)},
    `bin_location` = ${Fragment.encode(MariaTypes.varchar.nullable, row.binLocation)},
    `last_counted_at` = ${Fragment.encode(MariaTypes.datetime.nullable, row.lastCountedAt)},
    `updated_at` = ${Fragment.encode(MariaTypes.datetime, row.updatedAt)}
    where `inventory_id` = ${Fragment.encode(InventoryId.pgType, inventoryId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: InventoryRow)(using c: Connection): InventoryRow = {
  sql"""INSERT INTO `inventory`(`product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`)
    VALUES (${Fragment.encode(ProductsId.pgType, unsaved.productId)}, ${Fragment.encode(WarehousesId.pgType, unsaved.warehouseId)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.quantityOnHand)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.quantityReserved)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.quantityOnOrder)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.reorderPoint)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.int_, unsaved.reorderQuantity)}, ${Fragment.encode(MariaTypes.varchar.nullable, unsaved.binLocation)}, ${Fragment.encode(MariaTypes.datetime.nullable, unsaved.lastCountedAt)}, ${Fragment.encode(MariaTypes.datetime, unsaved.updatedAt)})
    ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),
    `warehouse_id` = VALUES(`warehouse_id`),
    `quantity_on_hand` = VALUES(`quantity_on_hand`),
    `quantity_reserved` = VALUES(`quantity_reserved`),
    `quantity_on_order` = VALUES(`quantity_on_order`),
    `reorder_point` = VALUES(`reorder_point`),
    `reorder_quantity` = VALUES(`reorder_quantity`),
    `bin_location` = VALUES(`bin_location`),
    `last_counted_at` = VALUES(`last_counted_at`),
    `updated_at` = VALUES(`updated_at`)
    RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`"""
    .updateReturning(InventoryRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[InventoryRow])(using c: Connection): List[InventoryRow] = {
    sql"""INSERT INTO `inventory`(`inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),
    `warehouse_id` = VALUES(`warehouse_id`),
    `quantity_on_hand` = VALUES(`quantity_on_hand`),
    `quantity_reserved` = VALUES(`quantity_reserved`),
    `quantity_on_order` = VALUES(`quantity_on_order`),
    `reorder_point` = VALUES(`reorder_point`),
    `reorder_quantity` = VALUES(`reorder_quantity`),
    `bin_location` = VALUES(`bin_location`),
    `last_counted_at` = VALUES(`last_counted_at`),
    `updated_at` = VALUES(`updated_at`)
    RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`"""
      .updateReturningEach(InventoryRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}