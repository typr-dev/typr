/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.promotions

import java.sql.Connection
import java.util.ArrayList
import java.util.HashMap
import java.util.Optional
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.MariaTypes
import typo.runtime.FragmentInterpolator.interpolate

class PromotionsRepoImpl extends PromotionsRepo {
  override def delete: DeleteBuilder[PromotionsFields, PromotionsRow] = DeleteBuilder.of("`promotions`", PromotionsFields.structure, Dialect.MARIADB)

  override def deleteById(promotionId: PromotionsId)(using c: Connection): java.lang.Boolean = interpolate"delete from `promotions` where `promotion_id` = ${PromotionsId.pgType.encode(promotionId)}".update().runUnchecked(c) > 0

  override def deleteByIds(promotionIds: Array[PromotionsId])(using c: Connection): Integer = {
    val fragments: ArrayList[Fragment] = new ArrayList[Fragment]()
    promotionIds.foreach { id => fragments.add(PromotionsId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("delete from `promotions` where `promotion_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: PromotionsRow)(using c: Connection): PromotionsRow = {
  interpolate"""insert into `promotions`(`code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`)
    values (${MariaTypes.text.encode(unsaved.code)}, ${MariaTypes.text.encode(unsaved.name)}, ${MariaTypes.text.opt().encode(unsaved.description)}, ${MariaTypes.text.encode(unsaved.discountType)}, ${MariaTypes.numeric.encode(unsaved.discountValue)}, ${MariaTypes.numeric.opt().encode(unsaved.minOrderAmount)}, ${MariaTypes.bigint.opt().encode(unsaved.maxUses)}, ${MariaTypes.bigint.encode(unsaved.usesCount)}, ${MariaTypes.smallint.opt().encode(unsaved.maxUsesPerCustomer)}, ${MariaTypes.set.opt().encode(unsaved.applicableTo)}, ${MariaTypes.text.opt().encode(unsaved.rulesJson)}, ${MariaTypes.datetime.encode(unsaved.validFrom)}, ${MariaTypes.datetime.encode(unsaved.validTo)}, ${MariaTypes.bool.encode(unsaved.isActive)}, ${MariaTypes.datetime.encode(unsaved.createdAt)})
    returning `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
    """
    .updateReturning(PromotionsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: PromotionsRowUnsaved)(using c: Connection): PromotionsRow = {
    val columns: ArrayList[Literal] = new ArrayList[Literal]()
    val values: ArrayList[Fragment] = new ArrayList[Fragment]()
    columns.add(Fragment.lit("`code`")): @scala.annotation.nowarn
    values.add(interpolate"${MariaTypes.text.encode(unsaved.code)}"): @scala.annotation.nowarn
    columns.add(Fragment.lit("`name`")): @scala.annotation.nowarn
    values.add(interpolate"${MariaTypes.text.encode(unsaved.name)}"): @scala.annotation.nowarn
    columns.add(Fragment.lit("`discount_type`")): @scala.annotation.nowarn
    values.add(interpolate"${MariaTypes.text.encode(unsaved.discountType)}"): @scala.annotation.nowarn
    columns.add(Fragment.lit("`discount_value`")): @scala.annotation.nowarn
    values.add(interpolate"${MariaTypes.numeric.encode(unsaved.discountValue)}"): @scala.annotation.nowarn
    columns.add(Fragment.lit("`valid_from`")): @scala.annotation.nowarn
    values.add(interpolate"${MariaTypes.datetime.encode(unsaved.validFrom)}"): @scala.annotation.nowarn
    columns.add(Fragment.lit("`valid_to`")): @scala.annotation.nowarn
    values.add(interpolate"${MariaTypes.datetime.encode(unsaved.validTo)}"): @scala.annotation.nowarn
    unsaved.description.visit(
      {  },
      value => { columns.add(Fragment.lit("`description`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.text.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.minOrderAmount.visit(
      {  },
      value => { columns.add(Fragment.lit("`min_order_amount`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.numeric.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.maxUses.visit(
      {  },
      value => { columns.add(Fragment.lit("`max_uses`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.bigint.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.usesCount.visit(
      {  },
      value => { columns.add(Fragment.lit("`uses_count`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.bigint.encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.maxUsesPerCustomer.visit(
      {  },
      value => { columns.add(Fragment.lit("`max_uses_per_customer`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.smallint.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.applicableTo.visit(
      {  },
      value => { columns.add(Fragment.lit("`applicable_to`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.set.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.rulesJson.visit(
      {  },
      value => { columns.add(Fragment.lit("`rules_json`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.text.opt().encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.isActive.visit(
      {  },
      value => { columns.add(Fragment.lit("`is_active`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.bool.encode(value)}"): @scala.annotation.nowarn }
    );
    unsaved.createdAt.visit(
      {  },
      value => { columns.add(Fragment.lit("`created_at`")): @scala.annotation.nowarn; values.add(interpolate"${MariaTypes.datetime.encode(value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      interpolate"""insert into `promotions`(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      returning `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
      """
    }
    return q.updateReturning(PromotionsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[PromotionsFields, PromotionsRow] = SelectBuilder.of("`promotions`", PromotionsFields.structure, PromotionsRow.`_rowParser`, Dialect.MARIADB)

  override def selectAll(using c: Connection): java.util.List[PromotionsRow] = {
    interpolate"""select `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
    from `promotions`
    """.query(PromotionsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(promotionId: PromotionsId)(using c: Connection): Optional[PromotionsRow] = {
    interpolate"""select `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
    from `promotions`
    where `promotion_id` = ${PromotionsId.pgType.encode(promotionId)}""".query(PromotionsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(promotionIds: Array[PromotionsId])(using c: Connection): java.util.List[PromotionsRow] = {
    val fragments: ArrayList[Fragment] = new ArrayList[Fragment]()
    promotionIds.foreach { id => fragments.add(PromotionsId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("select `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at` from `promotions` where `promotion_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).query(PromotionsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(promotionIds: Array[PromotionsId])(using c: Connection): java.util.Map[PromotionsId, PromotionsRow] = {
    val ret: HashMap[PromotionsId, PromotionsRow] = new HashMap[PromotionsId, PromotionsRow]()
    selectByIds(promotionIds)(using c).forEach(row => ret.put(row.promotionId, row): @scala.annotation.nowarn)
    return ret
  }

  override def selectByUniqueCode(code: String)(using c: Connection): Optional[PromotionsRow] = {
    interpolate"""select `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
    from `promotions`
    where `code` = ${MariaTypes.text.encode(code)}
    """.query(PromotionsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def update: UpdateBuilder[PromotionsFields, PromotionsRow] = UpdateBuilder.of("`promotions`", PromotionsFields.structure, PromotionsRow.`_rowParser`.all(), Dialect.MARIADB)

  override def update(row: PromotionsRow)(using c: Connection): java.lang.Boolean = {
    val promotionId: PromotionsId = row.promotionId
    return interpolate"""update `promotions`
    set `code` = ${MariaTypes.text.encode(row.code)},
    `name` = ${MariaTypes.text.encode(row.name)},
    `description` = ${MariaTypes.text.opt().encode(row.description)},
    `discount_type` = ${MariaTypes.text.encode(row.discountType)},
    `discount_value` = ${MariaTypes.numeric.encode(row.discountValue)},
    `min_order_amount` = ${MariaTypes.numeric.opt().encode(row.minOrderAmount)},
    `max_uses` = ${MariaTypes.bigint.opt().encode(row.maxUses)},
    `uses_count` = ${MariaTypes.bigint.encode(row.usesCount)},
    `max_uses_per_customer` = ${MariaTypes.smallint.opt().encode(row.maxUsesPerCustomer)},
    `applicable_to` = ${MariaTypes.set.opt().encode(row.applicableTo)},
    `rules_json` = ${MariaTypes.text.opt().encode(row.rulesJson)},
    `valid_from` = ${MariaTypes.datetime.encode(row.validFrom)},
    `valid_to` = ${MariaTypes.datetime.encode(row.validTo)},
    `is_active` = ${MariaTypes.bool.encode(row.isActive)},
    `created_at` = ${MariaTypes.datetime.encode(row.createdAt)}
    where `promotion_id` = ${PromotionsId.pgType.encode(promotionId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: PromotionsRow)(using c: Connection): PromotionsRow = {
  interpolate"""INSERT INTO `promotions`(`code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`)
    VALUES (${MariaTypes.text.encode(unsaved.code)}, ${MariaTypes.text.encode(unsaved.name)}, ${MariaTypes.text.opt().encode(unsaved.description)}, ${MariaTypes.text.encode(unsaved.discountType)}, ${MariaTypes.numeric.encode(unsaved.discountValue)}, ${MariaTypes.numeric.opt().encode(unsaved.minOrderAmount)}, ${MariaTypes.bigint.opt().encode(unsaved.maxUses)}, ${MariaTypes.bigint.encode(unsaved.usesCount)}, ${MariaTypes.smallint.opt().encode(unsaved.maxUsesPerCustomer)}, ${MariaTypes.set.opt().encode(unsaved.applicableTo)}, ${MariaTypes.text.opt().encode(unsaved.rulesJson)}, ${MariaTypes.datetime.encode(unsaved.validFrom)}, ${MariaTypes.datetime.encode(unsaved.validTo)}, ${MariaTypes.bool.encode(unsaved.isActive)}, ${MariaTypes.datetime.encode(unsaved.createdAt)})
    ON DUPLICATE KEY UPDATE `code` = VALUES(`code`),
    `name` = VALUES(`name`),
    `description` = VALUES(`description`),
    `discount_type` = VALUES(`discount_type`),
    `discount_value` = VALUES(`discount_value`),
    `min_order_amount` = VALUES(`min_order_amount`),
    `max_uses` = VALUES(`max_uses`),
    `uses_count` = VALUES(`uses_count`),
    `max_uses_per_customer` = VALUES(`max_uses_per_customer`),
    `applicable_to` = VALUES(`applicable_to`),
    `rules_json` = VALUES(`rules_json`),
    `valid_from` = VALUES(`valid_from`),
    `valid_to` = VALUES(`valid_to`),
    `is_active` = VALUES(`is_active`),
    `created_at` = VALUES(`created_at`)
    RETURNING `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`"""
    .updateReturning(PromotionsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: java.util.Iterator[PromotionsRow])(using c: Connection): java.util.List[PromotionsRow] = {
    interpolate"""INSERT INTO `promotions`(`promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON DUPLICATE KEY UPDATE `code` = VALUES(`code`),
    `name` = VALUES(`name`),
    `description` = VALUES(`description`),
    `discount_type` = VALUES(`discount_type`),
    `discount_value` = VALUES(`discount_value`),
    `min_order_amount` = VALUES(`min_order_amount`),
    `max_uses` = VALUES(`max_uses`),
    `uses_count` = VALUES(`uses_count`),
    `max_uses_per_customer` = VALUES(`max_uses_per_customer`),
    `applicable_to` = VALUES(`applicable_to`),
    `rules_json` = VALUES(`rules_json`),
    `valid_from` = VALUES(`valid_from`),
    `valid_to` = VALUES(`valid_to`),
    `is_active` = VALUES(`is_active`),
    `created_at` = VALUES(`created_at`)
    RETURNING `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`"""
      .updateReturningEach(PromotionsRow.`_rowParser`, unsaved)
      .runUnchecked(c)
  }
}