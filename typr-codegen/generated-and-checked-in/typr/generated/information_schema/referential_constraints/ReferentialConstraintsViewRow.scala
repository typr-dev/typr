/**
 * File has been automatically generated by `typo` for internal use.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 *
 * (If you're developing `typo` and want to change it: run `bleep generate-sources`)
 */
package typr.generated.information_schema.referential_constraints

import anorm.Column
import anorm.RowParser
import anorm.Success
import play.api.libs.json.JsObject
import play.api.libs.json.JsResult
import play.api.libs.json.JsValue
import play.api.libs.json.OWrites
import play.api.libs.json.Reads
import play.api.libs.json.Writes
import scala.collection.immutable.ListMap
import scala.util.Try

/** View: information_schema.referential_constraints */
case class ReferentialConstraintsViewRow(
  /** debug: {"name":"constraint_catalog","inferred_type":"\"information_schema\".\"sql_identifier\"","nullable_from_join":false,"nullable_in_schema":false,"is_expression":false,"source_primary_key":false} */
  constraintCatalog: Option[String],
  /** debug: {"name":"constraint_schema","inferred_type":"\"information_schema\".\"sql_identifier\"","nullable_from_join":true,"nullable_in_schema":false,"is_expression":true,"source_table":"pg_namespace","source_column":"nspname","source_type":"name","source_primary_key":false} */
  constraintSchema: Option[String],
  /** debug: {"name":"constraint_name","inferred_type":"\"information_schema\".\"sql_identifier\"","nullable_from_join":true,"nullable_in_schema":false,"is_expression":true,"source_table":"pg_constraint","source_column":"conname","source_type":"name","source_primary_key":false} */
  constraintName: Option[String],
  /** debug: {"name":"unique_constraint_catalog","inferred_type":"\"information_schema\".\"sql_identifier\"","nullable_from_join":true,"nullable_in_schema":false,"is_expression":true,"source_table":"pg_namespace","source_column":"nspname","source_type":"name","source_primary_key":false} */
  uniqueConstraintCatalog: Option[String],
  /** debug: {"name":"unique_constraint_schema","inferred_type":"\"information_schema\".\"sql_identifier\"","nullable_from_join":true,"nullable_in_schema":false,"is_expression":true,"source_table":"pg_namespace","source_column":"nspname","source_type":"name","source_primary_key":false} */
  uniqueConstraintSchema: Option[String],
  /** debug: {"name":"unique_constraint_name","inferred_type":"\"information_schema\".\"sql_identifier\"","nullable_from_join":true,"nullable_in_schema":false,"is_expression":true,"source_table":"pg_constraint","source_column":"conname","source_type":"name","source_primary_key":false} */
  uniqueConstraintName: Option[String],
  /** debug: {"name":"match_option","inferred_type":"\"information_schema\".\"character_data\"","nullable_from_join":true,"nullable_in_schema":false,"is_expression":true,"source_table":"pg_constraint","source_column":"confmatchtype","source_type":"char","source_primary_key":false} */
  matchOption: Option[String],
  /** debug: {"name":"update_rule","inferred_type":"\"information_schema\".\"character_data\"","nullable_from_join":true,"nullable_in_schema":false,"is_expression":true,"source_table":"pg_constraint","source_column":"confupdtype","source_type":"char","source_primary_key":false} */
  updateRule: Option[String],
  /** debug: {"name":"delete_rule","inferred_type":"\"information_schema\".\"character_data\"","nullable_from_join":true,"nullable_in_schema":false,"is_expression":true,"source_table":"pg_constraint","source_column":"confdeltype","source_type":"char","source_primary_key":false} */
  deleteRule: Option[String]
)

object ReferentialConstraintsViewRow {
  given reads: Reads[ReferentialConstraintsViewRow] = {
    Reads[ReferentialConstraintsViewRow](json => JsResult.fromTry(
        Try(
          ReferentialConstraintsViewRow(
            constraintCatalog = json.\("constraint_catalog").toOption.map(_.as(using Reads.StringReads)),
            constraintSchema = json.\("constraint_schema").toOption.map(_.as(using Reads.StringReads)),
            constraintName = json.\("constraint_name").toOption.map(_.as(using Reads.StringReads)),
            uniqueConstraintCatalog = json.\("unique_constraint_catalog").toOption.map(_.as(using Reads.StringReads)),
            uniqueConstraintSchema = json.\("unique_constraint_schema").toOption.map(_.as(using Reads.StringReads)),
            uniqueConstraintName = json.\("unique_constraint_name").toOption.map(_.as(using Reads.StringReads)),
            matchOption = json.\("match_option").toOption.map(_.as(using Reads.StringReads)),
            updateRule = json.\("update_rule").toOption.map(_.as(using Reads.StringReads)),
            deleteRule = json.\("delete_rule").toOption.map(_.as(using Reads.StringReads))
          )
        )
      ),
    )
  }

  def rowParser(idx: Int): RowParser[ReferentialConstraintsViewRow] = {
    RowParser[ReferentialConstraintsViewRow] { row =>
      Success(
        ReferentialConstraintsViewRow(
          constraintCatalog = row(idx + 0)(using Column.columnToOption(using Column.columnToString)),
          constraintSchema = row(idx + 1)(using Column.columnToOption(using Column.columnToString)),
          constraintName = row(idx + 2)(using Column.columnToOption(using Column.columnToString)),
          uniqueConstraintCatalog = row(idx + 3)(using Column.columnToOption(using Column.columnToString)),
          uniqueConstraintSchema = row(idx + 4)(using Column.columnToOption(using Column.columnToString)),
          uniqueConstraintName = row(idx + 5)(using Column.columnToOption(using Column.columnToString)),
          matchOption = row(idx + 6)(using Column.columnToOption(using Column.columnToString)),
          updateRule = row(idx + 7)(using Column.columnToOption(using Column.columnToString)),
          deleteRule = row(idx + 8)(using Column.columnToOption(using Column.columnToString))
        )
      )
    }
  }

  given writes: OWrites[ReferentialConstraintsViewRow] = {
    OWrites[ReferentialConstraintsViewRow](o =>
      new JsObject(ListMap[String, JsValue](
        "constraint_catalog" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.constraintCatalog),
        "constraint_schema" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.constraintSchema),
        "constraint_name" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.constraintName),
        "unique_constraint_catalog" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.uniqueConstraintCatalog),
        "unique_constraint_schema" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.uniqueConstraintSchema),
        "unique_constraint_name" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.uniqueConstraintName),
        "match_option" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.matchOption),
        "update_rule" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.updateRule),
        "delete_rule" -> Writes.OptionWrites(using Writes.StringWrites).writes(o.deleteRule)
      ))
    )
  }
}