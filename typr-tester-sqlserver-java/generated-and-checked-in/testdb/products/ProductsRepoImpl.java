/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.products;

import static typr.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import typr.dsl.DeleteBuilder;
import typr.dsl.Dialect;
import typr.dsl.SelectBuilder;
import typr.dsl.UpdateBuilder;
import typr.runtime.Fragment;
import typr.runtime.SqlServerTypes;

public class ProductsRepoImpl implements ProductsRepo {
  @Override
  public DeleteBuilder<ProductsFields, ProductsRow> delete() {
    return DeleteBuilder.of("[products]", ProductsFields.structure(), Dialect.SQLSERVER);
  }
  ;

  @Override
  public Boolean deleteById(ProductsId productId, Connection c) {
    return interpolate(
                Fragment.lit("delete from [products] where [product_id] = "),
                Fragment.encode(ProductsId.sqlServerType, productId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(ProductsId[] productIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : productIds) {
      fragments.add(Fragment.encode(ProductsId.sqlServerType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from [products] where [product_id] in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public ProductsRow insert(ProductsRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into [products]([name], [price], [description])\n"
                    + "OUTPUT INSERTED.[product_id], INSERTED.[name], INSERTED.[price],"
                    + " INSERTED.[description]\n"
                    + "values ("),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money, unsaved.price()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.description()),
            Fragment.lit(")\n"))
        .updateReturning(ProductsRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public ProductsRow insert(ProductsRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("[name]"));
    values.add(
        interpolate(Fragment.encode(SqlServerTypes.nvarchar, unsaved.name()), Fragment.lit("")));
    columns.add(Fragment.lit("[price]"));
    values.add(
        interpolate(Fragment.encode(SqlServerTypes.money, unsaved.price()), Fragment.lit("")));
    columns.add(Fragment.lit("[description]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.description()),
            Fragment.lit("")));
    Fragment q =
        interpolate(
            Fragment.lit("insert into [products]("),
            Fragment.comma(columns),
            Fragment.lit(
                ")\n"
                    + "OUTPUT INSERTED.[product_id], INSERTED.[name], INSERTED.[price],"
                    + " INSERTED.[description]\n"
                    + "values ("),
            Fragment.comma(values),
            Fragment.lit(")\n"));
    ;
    return q.updateReturning(ProductsRow._rowParser.exactlyOne()).runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<ProductsFields, ProductsRow> select() {
    return SelectBuilder.of(
        "[products]", ProductsFields.structure(), ProductsRow._rowParser, Dialect.SQLSERVER);
  }
  ;

  @Override
  public List<ProductsRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit("select [product_id], [name], [price], [description]\nfrom [products]\n"))
        .query(ProductsRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<ProductsRow> selectById(ProductsId productId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select [product_id], [name], [price], [description]\n"
                    + "from [products]\n"
                    + "where [product_id] = "),
            Fragment.encode(ProductsId.sqlServerType, productId),
            Fragment.lit(""))
        .query(ProductsRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<ProductsRow> selectByIds(ProductsId[] productIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : productIds) {
      fragments.add(Fragment.encode(ProductsId.sqlServerType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select [product_id], [name], [price], [description] from [products] where"
                    + " [product_id] in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(ProductsRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<ProductsId, ProductsRow> selectByIdsTracked(ProductsId[] productIds, Connection c) {
    HashMap<ProductsId, ProductsRow> ret = new HashMap<ProductsId, ProductsRow>();
    selectByIds(productIds, c).forEach(row -> ret.put(row.productId(), row));
    return ret;
  }
  ;

  @Override
  public UpdateBuilder<ProductsFields, ProductsRow> update() {
    return UpdateBuilder.of(
        "[products]", ProductsFields.structure(), ProductsRow._rowParser, Dialect.SQLSERVER);
  }
  ;

  @Override
  public Boolean update(ProductsRow row, Connection c) {
    ProductsId productId = row.productId();
    ;
    return interpolate(
                Fragment.lit("update [products]\nset [name] = "),
                Fragment.encode(SqlServerTypes.nvarchar, row.name()),
                Fragment.lit(",\n[price] = "),
                Fragment.encode(SqlServerTypes.money, row.price()),
                Fragment.lit(",\n[description] = "),
                Fragment.encode(SqlServerTypes.nvarchar.opt(), row.description()),
                Fragment.lit("\nwhere [product_id] = "),
                Fragment.encode(ProductsId.sqlServerType, productId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public ProductsRow upsert(ProductsRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit("MERGE INTO [products] AS target\nUSING (VALUES ("),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money, unsaved.price()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.description()),
            Fragment.lit(
                ")) AS source([name], [price], [description])\n"
                    + "ON target.[product_id] = source.[product_id]\n"
                    + "WHEN MATCHED THEN UPDATE SET [name] = source.[name],\n"
                    + "[price] = source.[price],\n"
                    + "[description] = source.[description]\n"
                    + "WHEN NOT MATCHED THEN INSERT ([name], [price], [description]) VALUES ("),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money, unsaved.price()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.description()),
            Fragment.lit(
                ")\n"
                    + "OUTPUT INSERTED.[product_id], INSERTED.[name], INSERTED.[price],"
                    + " INSERTED.[description];"))
        .updateReturning(ProductsRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<ProductsRow> upsertBatch(Iterator<ProductsRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "MERGE INTO [products] AS target\n"
                    + "USING (VALUES (?, ?, ?, ?)) AS source([product_id], [name], [price],"
                    + " [description])\n"
                    + "ON target.[product_id] = source.[product_id]\n"
                    + "WHEN MATCHED THEN UPDATE SET [name] = source.[name],\n"
                    + "[price] = source.[price],\n"
                    + "[description] = source.[description]\n"
                    + "WHEN NOT MATCHED THEN INSERT ([product_id], [name], [price], [description])"
                    + " VALUES (?, ?, ?, ?)\n"
                    + "OUTPUT INSERTED.[product_id], INSERTED.[name], INSERTED.[price],"
                    + " INSERTED.[description];"))
        .updateReturningEach(ProductsRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
