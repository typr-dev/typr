/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.order_items;

import static typr.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import testdb.orders.OrdersId;
import testdb.products.ProductsId;
import typr.dsl.DeleteBuilder;
import typr.dsl.Dialect;
import typr.dsl.SelectBuilder;
import typr.dsl.UpdateBuilder;
import typr.runtime.Fragment;
import typr.runtime.SqlServerTypes;

public class OrderItemsRepoImpl implements OrderItemsRepo {
  @Override
  public DeleteBuilder<OrderItemsFields, OrderItemsRow> delete() {
    return DeleteBuilder.of("[order_items]", OrderItemsFields.structure(), Dialect.SQLSERVER);
  }
  ;

  @Override
  public Boolean deleteById(OrderItemsId orderItemId, Connection c) {
    return interpolate(
                Fragment.lit("delete from [order_items] where [order_item_id] = "),
                Fragment.encode(OrderItemsId.sqlServerType, orderItemId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(OrderItemsId[] orderItemIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : orderItemIds) {
      fragments.add(Fragment.encode(OrderItemsId.sqlServerType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from [order_items] where [order_item_id] in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public OrderItemsRow insert(OrderItemsRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into [order_items]([order_id], [product_id], [quantity], [price])\n"
                    + "OUTPUT INSERTED.[order_item_id], INSERTED.[order_id], INSERTED.[product_id],"
                    + " INSERTED.[quantity], INSERTED.[price]\n"
                    + "values ("),
            Fragment.encode(OrdersId.sqlServerType, unsaved.orderId()),
            Fragment.lit(", "),
            Fragment.encode(ProductsId.sqlServerType, unsaved.productId()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.int_, unsaved.quantity()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money, unsaved.price()),
            Fragment.lit(")\n"))
        .updateReturning(OrderItemsRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public OrderItemsRow insert(OrderItemsRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("[order_id]"));
    values.add(
        interpolate(Fragment.encode(OrdersId.sqlServerType, unsaved.orderId()), Fragment.lit("")));
    columns.add(Fragment.lit("[product_id]"));
    values.add(
        interpolate(
            Fragment.encode(ProductsId.sqlServerType, unsaved.productId()), Fragment.lit("")));
    columns.add(Fragment.lit("[quantity]"));
    values.add(
        interpolate(Fragment.encode(SqlServerTypes.int_, unsaved.quantity()), Fragment.lit("")));
    columns.add(Fragment.lit("[price]"));
    values.add(
        interpolate(Fragment.encode(SqlServerTypes.money, unsaved.price()), Fragment.lit("")));
    Fragment q =
        interpolate(
            Fragment.lit("insert into [order_items]("),
            Fragment.comma(columns),
            Fragment.lit(
                ")\n"
                    + "OUTPUT INSERTED.[order_item_id], INSERTED.[order_id], INSERTED.[product_id],"
                    + " INSERTED.[quantity], INSERTED.[price]\n"
                    + "values ("),
            Fragment.comma(values),
            Fragment.lit(")\n"));
    ;
    return q.updateReturning(OrderItemsRow._rowParser.exactlyOne()).runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<OrderItemsFields, OrderItemsRow> select() {
    return SelectBuilder.of(
        "[order_items]", OrderItemsFields.structure(), OrderItemsRow._rowParser, Dialect.SQLSERVER);
  }
  ;

  @Override
  public List<OrderItemsRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit(
                "select [order_item_id], [order_id], [product_id], [quantity], [price]\n"
                    + "from [order_items]\n"))
        .query(OrderItemsRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<OrderItemsRow> selectById(OrderItemsId orderItemId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select [order_item_id], [order_id], [product_id], [quantity], [price]\n"
                    + "from [order_items]\n"
                    + "where [order_item_id] = "),
            Fragment.encode(OrderItemsId.sqlServerType, orderItemId),
            Fragment.lit(""))
        .query(OrderItemsRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<OrderItemsRow> selectByIds(OrderItemsId[] orderItemIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : orderItemIds) {
      fragments.add(Fragment.encode(OrderItemsId.sqlServerType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select [order_item_id], [order_id], [product_id], [quantity], [price] from"
                    + " [order_items] where [order_item_id] in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(OrderItemsRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<OrderItemsId, OrderItemsRow> selectByIdsTracked(
      OrderItemsId[] orderItemIds, Connection c) {
    HashMap<OrderItemsId, OrderItemsRow> ret = new HashMap<OrderItemsId, OrderItemsRow>();
    selectByIds(orderItemIds, c).forEach(row -> ret.put(row.orderItemId(), row));
    return ret;
  }
  ;

  @Override
  public UpdateBuilder<OrderItemsFields, OrderItemsRow> update() {
    return UpdateBuilder.of(
        "[order_items]", OrderItemsFields.structure(), OrderItemsRow._rowParser, Dialect.SQLSERVER);
  }
  ;

  @Override
  public Boolean update(OrderItemsRow row, Connection c) {
    OrderItemsId orderItemId = row.orderItemId();
    ;
    return interpolate(
                Fragment.lit("update [order_items]\nset [order_id] = "),
                Fragment.encode(OrdersId.sqlServerType, row.orderId()),
                Fragment.lit(",\n[product_id] = "),
                Fragment.encode(ProductsId.sqlServerType, row.productId()),
                Fragment.lit(",\n[quantity] = "),
                Fragment.encode(SqlServerTypes.int_, row.quantity()),
                Fragment.lit(",\n[price] = "),
                Fragment.encode(SqlServerTypes.money, row.price()),
                Fragment.lit("\nwhere [order_item_id] = "),
                Fragment.encode(OrderItemsId.sqlServerType, orderItemId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public OrderItemsRow upsert(OrderItemsRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit("MERGE INTO [order_items] AS target\nUSING (VALUES ("),
            Fragment.encode(OrdersId.sqlServerType, unsaved.orderId()),
            Fragment.lit(", "),
            Fragment.encode(ProductsId.sqlServerType, unsaved.productId()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.int_, unsaved.quantity()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money, unsaved.price()),
            Fragment.lit(
                ")) AS source([order_id], [product_id], [quantity], [price])\n"
                    + "ON target.[order_item_id] = source.[order_item_id]\n"
                    + "WHEN MATCHED THEN UPDATE SET [order_id] = source.[order_id],\n"
                    + "[product_id] = source.[product_id],\n"
                    + "[quantity] = source.[quantity],\n"
                    + "[price] = source.[price]\n"
                    + "WHEN NOT MATCHED THEN INSERT ([order_id], [product_id], [quantity], [price])"
                    + " VALUES ("),
            Fragment.encode(OrdersId.sqlServerType, unsaved.orderId()),
            Fragment.lit(", "),
            Fragment.encode(ProductsId.sqlServerType, unsaved.productId()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.int_, unsaved.quantity()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money, unsaved.price()),
            Fragment.lit(
                ")\n"
                    + "OUTPUT INSERTED.[order_item_id], INSERTED.[order_id], INSERTED.[product_id],"
                    + " INSERTED.[quantity], INSERTED.[price];"))
        .updateReturning(OrderItemsRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<OrderItemsRow> upsertBatch(Iterator<OrderItemsRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "MERGE INTO [order_items] AS target\n"
                    + "USING (VALUES (?, ?, ?, ?, ?)) AS source([order_item_id], [order_id],"
                    + " [product_id], [quantity], [price])\n"
                    + "ON target.[order_item_id] = source.[order_item_id]\n"
                    + "WHEN MATCHED THEN UPDATE SET [order_id] = source.[order_id],\n"
                    + "[product_id] = source.[product_id],\n"
                    + "[quantity] = source.[quantity],\n"
                    + "[price] = source.[price]\n"
                    + "WHEN NOT MATCHED THEN INSERT ([order_item_id], [order_id], [product_id],"
                    + " [quantity], [price]) VALUES (?, ?, ?, ?, ?)\n"
                    + "OUTPUT INSERTED.[order_item_id], INSERTED.[order_id], INSERTED.[product_id],"
                    + " INSERTED.[quantity], INSERTED.[price];"))
        .updateReturningEach(OrderItemsRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
