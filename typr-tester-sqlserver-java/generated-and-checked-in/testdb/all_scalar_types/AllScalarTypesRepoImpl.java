/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.all_scalar_types;

import static typr.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import typr.dsl.DeleteBuilder;
import typr.dsl.Dialect;
import typr.dsl.SelectBuilder;
import typr.dsl.UpdateBuilder;
import typr.runtime.Fragment;
import typr.runtime.SqlServerTypes;

public class AllScalarTypesRepoImpl implements AllScalarTypesRepo {
  @Override
  public DeleteBuilder<AllScalarTypesFields, AllScalarTypesRow> delete() {
    return DeleteBuilder.of(
        "[all_scalar_types]", AllScalarTypesFields.structure(), Dialect.SQLSERVER);
  }
  ;

  @Override
  public Boolean deleteById(AllScalarTypesId id, Connection c) {
    return interpolate(
                Fragment.lit("delete from [all_scalar_types] where [id] = "),
                Fragment.encode(AllScalarTypesId.sqlServerType, id),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(AllScalarTypesId[] ids, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : ids) {
      fragments.add(Fragment.encode(AllScalarTypesId.sqlServerType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from [all_scalar_types] where [id] in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public AllScalarTypesRow insert(AllScalarTypesRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into [all_scalar_types]([col_tinyint], [col_smallint], [col_int],"
                    + " [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney],"
                    + " [col_real], [col_float], [col_bit], [col_char], [col_varchar],"
                    + " [col_varchar_max], [col_text], [col_nchar], [col_nvarchar],"
                    + " [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary],"
                    + " [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime],"
                    + " [col_smalldatetime], [col_datetime2], [col_datetimeoffset],"
                    + " [col_uniqueidentifier], [col_xml], [col_json], [col_hierarchyid],"
                    + " [col_geography], [col_geometry], [col_not_null])\n"
                    + "OUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint],"
                    + " INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal],"
                    + " INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney],"
                    + " INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit],"
                    + " INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max],"
                    + " INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar],"
                    + " INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary],"
                    + " INSERTED.[col_varbinary], INSERTED.[col_varbinary_max],"
                    + " INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time],"
                    + " INSERTED.[col_datetime], INSERTED.[col_smalldatetime],"
                    + " INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset],"
                    + " INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json],"
                    + " INSERTED.[col_rowversion], INSERTED.[col_hierarchyid],"
                    + " INSERTED.[col_geography], INSERTED.[col_geometry],"
                    + " INSERTED.[col_not_null]\n"
                    + "values ("),
            Fragment.encode(SqlServerTypes.tinyint.opt(), unsaved.colTinyint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smallint.opt(), unsaved.colSmallint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.int_.opt(), unsaved.colInt()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.bigint.opt(), unsaved.colBigint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.decimal.opt(), unsaved.colDecimal()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.decimal.opt(), unsaved.colNumeric()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money.opt(), unsaved.colMoney()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smallmoney.opt(), unsaved.colSmallmoney()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.real.opt(), unsaved.colReal()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.float_.opt(), unsaved.colFloat()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.bit.opt(), unsaved.colBit()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.char_.opt(), unsaved.colChar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varchar.opt(), unsaved.colVarchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varchar.opt(), unsaved.colVarcharMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.text.opt(), unsaved.colText()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nchar.opt(), unsaved.colNchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colNvarchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colNvarcharMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.ntext.opt(), unsaved.colNtext()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.binary.opt(), unsaved.colBinary()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varbinary.opt(), unsaved.colVarbinary()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varbinary.opt(), unsaved.colVarbinaryMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.image.opt(), unsaved.colImage()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.date.opt(), unsaved.colDate()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.time.opt(), unsaved.colTime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime.opt(), unsaved.colDatetime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smalldatetime.opt(), unsaved.colSmalldatetime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime2.opt(), unsaved.colDatetime2()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetimeoffset.opt(), unsaved.colDatetimeoffset()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.uniqueidentifier.opt(), unsaved.colUniqueidentifier()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.xml.opt(), unsaved.colXml()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colJson()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.hierarchyid.opt(), unsaved.colHierarchyid()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.geography.opt(), unsaved.colGeography()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.geometry.opt(), unsaved.colGeometry()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull()),
            Fragment.lit(")\n"))
        .updateReturning(AllScalarTypesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public AllScalarTypesRow insert(AllScalarTypesRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("[col_tinyint]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.tinyint.opt(), unsaved.colTinyint()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_smallint]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.smallint.opt(), unsaved.colSmallint()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_int]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.int_.opt(), unsaved.colInt()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_bigint]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.bigint.opt(), unsaved.colBigint()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_decimal]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.decimal.opt(), unsaved.colDecimal()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_numeric]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.decimal.opt(), unsaved.colNumeric()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_money]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.money.opt(), unsaved.colMoney()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_smallmoney]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.smallmoney.opt(), unsaved.colSmallmoney()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_real]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.real.opt(), unsaved.colReal()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_float]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.float_.opt(), unsaved.colFloat()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_bit]"));
    values.add(
        interpolate(Fragment.encode(SqlServerTypes.bit.opt(), unsaved.colBit()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_char]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.char_.opt(), unsaved.colChar()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_varchar]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.varchar.opt(), unsaved.colVarchar()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_varchar_max]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.varchar.opt(), unsaved.colVarcharMax()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_text]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.text.opt(), unsaved.colText()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_nchar]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.nchar.opt(), unsaved.colNchar()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_nvarchar]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colNvarchar()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_nvarchar_max]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colNvarcharMax()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_ntext]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.ntext.opt(), unsaved.colNtext()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_binary]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.binary.opt(), unsaved.colBinary()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_varbinary]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.varbinary.opt(), unsaved.colVarbinary()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_varbinary_max]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.varbinary.opt(), unsaved.colVarbinaryMax()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_image]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.image.opt(), unsaved.colImage()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_date]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.date.opt(), unsaved.colDate()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_time]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.time.opt(), unsaved.colTime()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_datetime]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.datetime.opt(), unsaved.colDatetime()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_smalldatetime]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.smalldatetime.opt(), unsaved.colSmalldatetime()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_datetime2]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.datetime2.opt(), unsaved.colDatetime2()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_datetimeoffset]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.datetimeoffset.opt(), unsaved.colDatetimeoffset()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_uniqueidentifier]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.uniqueidentifier.opt(), unsaved.colUniqueidentifier()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_xml]"));
    values.add(
        interpolate(Fragment.encode(SqlServerTypes.xml.opt(), unsaved.colXml()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_json]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colJson()), Fragment.lit("")));
    columns.add(Fragment.lit("[col_hierarchyid]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.hierarchyid.opt(), unsaved.colHierarchyid()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_geography]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.geography.opt(), unsaved.colGeography()),
            Fragment.lit("")));
    columns.add(Fragment.lit("[col_geometry]"));
    values.add(
        interpolate(
            Fragment.encode(SqlServerTypes.geometry.opt(), unsaved.colGeometry()),
            Fragment.lit("")));
    unsaved
        .colNotNull()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("[col_not_null]"));
              values.add(
                  interpolate(Fragment.encode(SqlServerTypes.nvarchar, value), Fragment.lit("")));
            });
    ;
    Fragment q =
        interpolate(
            Fragment.lit("insert into [all_scalar_types]("),
            Fragment.comma(columns),
            Fragment.lit(
                ")\n"
                    + "OUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint],"
                    + " INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal],"
                    + " INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney],"
                    + " INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit],"
                    + " INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max],"
                    + " INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar],"
                    + " INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary],"
                    + " INSERTED.[col_varbinary], INSERTED.[col_varbinary_max],"
                    + " INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time],"
                    + " INSERTED.[col_datetime], INSERTED.[col_smalldatetime],"
                    + " INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset],"
                    + " INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json],"
                    + " INSERTED.[col_rowversion], INSERTED.[col_hierarchyid],"
                    + " INSERTED.[col_geography], INSERTED.[col_geometry],"
                    + " INSERTED.[col_not_null]\n"
                    + "values ("),
            Fragment.comma(values),
            Fragment.lit(")\n"));
    ;
    return q.updateReturning(AllScalarTypesRow._rowParser.exactlyOne()).runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<AllScalarTypesFields, AllScalarTypesRow> select() {
    return SelectBuilder.of(
        "[all_scalar_types]",
        AllScalarTypesFields.structure(),
        AllScalarTypesRow._rowParser,
        Dialect.SQLSERVER);
  }
  ;

  @Override
  public List<AllScalarTypesRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit(
                "select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint],"
                    + " [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real],"
                    + " [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max],"
                    + " [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext],"
                    + " [col_binary], [col_varbinary], [col_varbinary_max], [col_image],"
                    + " [col_date], [col_time], [col_datetime], [col_smalldatetime],"
                    + " [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml],"
                    + " [col_json], [col_rowversion], [col_hierarchyid], [col_geography],"
                    + " [col_geometry], [col_not_null]\n"
                    + "from [all_scalar_types]\n"))
        .query(AllScalarTypesRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<AllScalarTypesRow> selectById(AllScalarTypesId id, Connection c) {
    return interpolate(
            Fragment.lit(
                "select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint],"
                    + " [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real],"
                    + " [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max],"
                    + " [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext],"
                    + " [col_binary], [col_varbinary], [col_varbinary_max], [col_image],"
                    + " [col_date], [col_time], [col_datetime], [col_smalldatetime],"
                    + " [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml],"
                    + " [col_json], [col_rowversion], [col_hierarchyid], [col_geography],"
                    + " [col_geometry], [col_not_null]\n"
                    + "from [all_scalar_types]\n"
                    + "where [id] = "),
            Fragment.encode(AllScalarTypesId.sqlServerType, id),
            Fragment.lit(""))
        .query(AllScalarTypesRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<AllScalarTypesRow> selectByIds(AllScalarTypesId[] ids, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : ids) {
      fragments.add(Fragment.encode(AllScalarTypesId.sqlServerType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint],"
                    + " [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real],"
                    + " [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max],"
                    + " [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext],"
                    + " [col_binary], [col_varbinary], [col_varbinary_max], [col_image],"
                    + " [col_date], [col_time], [col_datetime], [col_smalldatetime],"
                    + " [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml],"
                    + " [col_json], [col_rowversion], [col_hierarchyid], [col_geography],"
                    + " [col_geometry], [col_not_null] from [all_scalar_types] where [id] in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(AllScalarTypesRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<AllScalarTypesId, AllScalarTypesRow> selectByIdsTracked(
      AllScalarTypesId[] ids, Connection c) {
    HashMap<AllScalarTypesId, AllScalarTypesRow> ret =
        new HashMap<AllScalarTypesId, AllScalarTypesRow>();
    selectByIds(ids, c).forEach(row -> ret.put(row.id(), row));
    return ret;
  }
  ;

  @Override
  public UpdateBuilder<AllScalarTypesFields, AllScalarTypesRow> update() {
    return UpdateBuilder.of(
        "[all_scalar_types]",
        AllScalarTypesFields.structure(),
        AllScalarTypesRow._rowParser,
        Dialect.SQLSERVER);
  }
  ;

  @Override
  public Boolean update(AllScalarTypesRow row, Connection c) {
    AllScalarTypesId id = row.id();
    ;
    return interpolate(
                Fragment.lit("update [all_scalar_types]\nset [col_tinyint] = "),
                Fragment.encode(SqlServerTypes.tinyint.opt(), row.colTinyint()),
                Fragment.lit(",\n[col_smallint] = "),
                Fragment.encode(SqlServerTypes.smallint.opt(), row.colSmallint()),
                Fragment.lit(",\n[col_int] = "),
                Fragment.encode(SqlServerTypes.int_.opt(), row.colInt()),
                Fragment.lit(",\n[col_bigint] = "),
                Fragment.encode(SqlServerTypes.bigint.opt(), row.colBigint()),
                Fragment.lit(",\n[col_decimal] = "),
                Fragment.encode(SqlServerTypes.decimal.opt(), row.colDecimal()),
                Fragment.lit(",\n[col_numeric] = "),
                Fragment.encode(SqlServerTypes.decimal.opt(), row.colNumeric()),
                Fragment.lit(",\n[col_money] = "),
                Fragment.encode(SqlServerTypes.money.opt(), row.colMoney()),
                Fragment.lit(",\n[col_smallmoney] = "),
                Fragment.encode(SqlServerTypes.smallmoney.opt(), row.colSmallmoney()),
                Fragment.lit(",\n[col_real] = "),
                Fragment.encode(SqlServerTypes.real.opt(), row.colReal()),
                Fragment.lit(",\n[col_float] = "),
                Fragment.encode(SqlServerTypes.float_.opt(), row.colFloat()),
                Fragment.lit(",\n[col_bit] = "),
                Fragment.encode(SqlServerTypes.bit.opt(), row.colBit()),
                Fragment.lit(",\n[col_char] = "),
                Fragment.encode(SqlServerTypes.char_.opt(), row.colChar()),
                Fragment.lit(",\n[col_varchar] = "),
                Fragment.encode(SqlServerTypes.varchar.opt(), row.colVarchar()),
                Fragment.lit(",\n[col_varchar_max] = "),
                Fragment.encode(SqlServerTypes.varchar.opt(), row.colVarcharMax()),
                Fragment.lit(",\n[col_text] = "),
                Fragment.encode(SqlServerTypes.text.opt(), row.colText()),
                Fragment.lit(",\n[col_nchar] = "),
                Fragment.encode(SqlServerTypes.nchar.opt(), row.colNchar()),
                Fragment.lit(",\n[col_nvarchar] = "),
                Fragment.encode(SqlServerTypes.nvarchar.opt(), row.colNvarchar()),
                Fragment.lit(",\n[col_nvarchar_max] = "),
                Fragment.encode(SqlServerTypes.nvarchar.opt(), row.colNvarcharMax()),
                Fragment.lit(",\n[col_ntext] = "),
                Fragment.encode(SqlServerTypes.ntext.opt(), row.colNtext()),
                Fragment.lit(",\n[col_binary] = "),
                Fragment.encode(SqlServerTypes.binary.opt(), row.colBinary()),
                Fragment.lit(",\n[col_varbinary] = "),
                Fragment.encode(SqlServerTypes.varbinary.opt(), row.colVarbinary()),
                Fragment.lit(",\n[col_varbinary_max] = "),
                Fragment.encode(SqlServerTypes.varbinary.opt(), row.colVarbinaryMax()),
                Fragment.lit(",\n[col_image] = "),
                Fragment.encode(SqlServerTypes.image.opt(), row.colImage()),
                Fragment.lit(",\n[col_date] = "),
                Fragment.encode(SqlServerTypes.date.opt(), row.colDate()),
                Fragment.lit(",\n[col_time] = "),
                Fragment.encode(SqlServerTypes.time.opt(), row.colTime()),
                Fragment.lit(",\n[col_datetime] = "),
                Fragment.encode(SqlServerTypes.datetime.opt(), row.colDatetime()),
                Fragment.lit(",\n[col_smalldatetime] = "),
                Fragment.encode(SqlServerTypes.smalldatetime.opt(), row.colSmalldatetime()),
                Fragment.lit(",\n[col_datetime2] = "),
                Fragment.encode(SqlServerTypes.datetime2.opt(), row.colDatetime2()),
                Fragment.lit(",\n[col_datetimeoffset] = "),
                Fragment.encode(SqlServerTypes.datetimeoffset.opt(), row.colDatetimeoffset()),
                Fragment.lit(",\n[col_uniqueidentifier] = "),
                Fragment.encode(SqlServerTypes.uniqueidentifier.opt(), row.colUniqueidentifier()),
                Fragment.lit(",\n[col_xml] = "),
                Fragment.encode(SqlServerTypes.xml.opt(), row.colXml()),
                Fragment.lit(",\n[col_json] = "),
                Fragment.encode(SqlServerTypes.nvarchar.opt(), row.colJson()),
                Fragment.lit(",\n[col_hierarchyid] = "),
                Fragment.encode(SqlServerTypes.hierarchyid.opt(), row.colHierarchyid()),
                Fragment.lit(",\n[col_geography] = "),
                Fragment.encode(SqlServerTypes.geography.opt(), row.colGeography()),
                Fragment.lit(",\n[col_geometry] = "),
                Fragment.encode(SqlServerTypes.geometry.opt(), row.colGeometry()),
                Fragment.lit(",\n[col_not_null] = "),
                Fragment.encode(SqlServerTypes.nvarchar, row.colNotNull()),
                Fragment.lit("\nwhere [id] = "),
                Fragment.encode(AllScalarTypesId.sqlServerType, id),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public AllScalarTypesRow upsert(AllScalarTypesRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit("MERGE INTO [all_scalar_types] AS target\nUSING (VALUES ("),
            Fragment.encode(SqlServerTypes.tinyint.opt(), unsaved.colTinyint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smallint.opt(), unsaved.colSmallint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.int_.opt(), unsaved.colInt()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.bigint.opt(), unsaved.colBigint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.decimal.opt(), unsaved.colDecimal()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.decimal.opt(), unsaved.colNumeric()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money.opt(), unsaved.colMoney()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smallmoney.opt(), unsaved.colSmallmoney()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.real.opt(), unsaved.colReal()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.float_.opt(), unsaved.colFloat()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.bit.opt(), unsaved.colBit()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.char_.opt(), unsaved.colChar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varchar.opt(), unsaved.colVarchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varchar.opt(), unsaved.colVarcharMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.text.opt(), unsaved.colText()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nchar.opt(), unsaved.colNchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colNvarchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colNvarcharMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.ntext.opt(), unsaved.colNtext()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.binary.opt(), unsaved.colBinary()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varbinary.opt(), unsaved.colVarbinary()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varbinary.opt(), unsaved.colVarbinaryMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.image.opt(), unsaved.colImage()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.date.opt(), unsaved.colDate()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.time.opt(), unsaved.colTime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime.opt(), unsaved.colDatetime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smalldatetime.opt(), unsaved.colSmalldatetime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime2.opt(), unsaved.colDatetime2()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetimeoffset.opt(), unsaved.colDatetimeoffset()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.uniqueidentifier.opt(), unsaved.colUniqueidentifier()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.xml.opt(), unsaved.colXml()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colJson()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.hierarchyid.opt(), unsaved.colHierarchyid()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.geography.opt(), unsaved.colGeography()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.geometry.opt(), unsaved.colGeometry()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull()),
            Fragment.lit(
                ")) AS source([col_tinyint], [col_smallint], [col_int], [col_bigint],"
                    + " [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real],"
                    + " [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max],"
                    + " [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext],"
                    + " [col_binary], [col_varbinary], [col_varbinary_max], [col_image],"
                    + " [col_date], [col_time], [col_datetime], [col_smalldatetime],"
                    + " [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml],"
                    + " [col_json], [col_hierarchyid], [col_geography], [col_geometry],"
                    + " [col_not_null])\n"
                    + "ON target.[id] = source.[id]\n"
                    + "WHEN MATCHED THEN UPDATE SET [col_tinyint] = source.[col_tinyint],\n"
                    + "[col_smallint] = source.[col_smallint],\n"
                    + "[col_int] = source.[col_int],\n"
                    + "[col_bigint] = source.[col_bigint],\n"
                    + "[col_decimal] = source.[col_decimal],\n"
                    + "[col_numeric] = source.[col_numeric],\n"
                    + "[col_money] = source.[col_money],\n"
                    + "[col_smallmoney] = source.[col_smallmoney],\n"
                    + "[col_real] = source.[col_real],\n"
                    + "[col_float] = source.[col_float],\n"
                    + "[col_bit] = source.[col_bit],\n"
                    + "[col_char] = source.[col_char],\n"
                    + "[col_varchar] = source.[col_varchar],\n"
                    + "[col_varchar_max] = source.[col_varchar_max],\n"
                    + "[col_text] = source.[col_text],\n"
                    + "[col_nchar] = source.[col_nchar],\n"
                    + "[col_nvarchar] = source.[col_nvarchar],\n"
                    + "[col_nvarchar_max] = source.[col_nvarchar_max],\n"
                    + "[col_ntext] = source.[col_ntext],\n"
                    + "[col_binary] = source.[col_binary],\n"
                    + "[col_varbinary] = source.[col_varbinary],\n"
                    + "[col_varbinary_max] = source.[col_varbinary_max],\n"
                    + "[col_image] = source.[col_image],\n"
                    + "[col_date] = source.[col_date],\n"
                    + "[col_time] = source.[col_time],\n"
                    + "[col_datetime] = source.[col_datetime],\n"
                    + "[col_smalldatetime] = source.[col_smalldatetime],\n"
                    + "[col_datetime2] = source.[col_datetime2],\n"
                    + "[col_datetimeoffset] = source.[col_datetimeoffset],\n"
                    + "[col_uniqueidentifier] = source.[col_uniqueidentifier],\n"
                    + "[col_xml] = source.[col_xml],\n"
                    + "[col_json] = source.[col_json],\n"
                    + "[col_hierarchyid] = source.[col_hierarchyid],\n"
                    + "[col_geography] = source.[col_geography],\n"
                    + "[col_geometry] = source.[col_geometry],\n"
                    + "[col_not_null] = source.[col_not_null]\n"
                    + "WHEN NOT MATCHED THEN INSERT ([col_tinyint], [col_smallint], [col_int],"
                    + " [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney],"
                    + " [col_real], [col_float], [col_bit], [col_char], [col_varchar],"
                    + " [col_varchar_max], [col_text], [col_nchar], [col_nvarchar],"
                    + " [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary],"
                    + " [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime],"
                    + " [col_smalldatetime], [col_datetime2], [col_datetimeoffset],"
                    + " [col_uniqueidentifier], [col_xml], [col_json], [col_hierarchyid],"
                    + " [col_geography], [col_geometry], [col_not_null]) VALUES ("),
            Fragment.encode(SqlServerTypes.tinyint.opt(), unsaved.colTinyint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smallint.opt(), unsaved.colSmallint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.int_.opt(), unsaved.colInt()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.bigint.opt(), unsaved.colBigint()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.decimal.opt(), unsaved.colDecimal()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.decimal.opt(), unsaved.colNumeric()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.money.opt(), unsaved.colMoney()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smallmoney.opt(), unsaved.colSmallmoney()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.real.opt(), unsaved.colReal()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.float_.opt(), unsaved.colFloat()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.bit.opt(), unsaved.colBit()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.char_.opt(), unsaved.colChar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varchar.opt(), unsaved.colVarchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varchar.opt(), unsaved.colVarcharMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.text.opt(), unsaved.colText()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nchar.opt(), unsaved.colNchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colNvarchar()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colNvarcharMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.ntext.opt(), unsaved.colNtext()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.binary.opt(), unsaved.colBinary()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varbinary.opt(), unsaved.colVarbinary()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.varbinary.opt(), unsaved.colVarbinaryMax()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.image.opt(), unsaved.colImage()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.date.opt(), unsaved.colDate()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.time.opt(), unsaved.colTime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime.opt(), unsaved.colDatetime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.smalldatetime.opt(), unsaved.colSmalldatetime()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime2.opt(), unsaved.colDatetime2()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetimeoffset.opt(), unsaved.colDatetimeoffset()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.uniqueidentifier.opt(), unsaved.colUniqueidentifier()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.xml.opt(), unsaved.colXml()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar.opt(), unsaved.colJson()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.hierarchyid.opt(), unsaved.colHierarchyid()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.geography.opt(), unsaved.colGeography()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.geometry.opt(), unsaved.colGeometry()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull()),
            Fragment.lit(
                ")\n"
                    + "OUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint],"
                    + " INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal],"
                    + " INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney],"
                    + " INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit],"
                    + " INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max],"
                    + " INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar],"
                    + " INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary],"
                    + " INSERTED.[col_varbinary], INSERTED.[col_varbinary_max],"
                    + " INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time],"
                    + " INSERTED.[col_datetime], INSERTED.[col_smalldatetime],"
                    + " INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset],"
                    + " INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json],"
                    + " INSERTED.[col_rowversion], INSERTED.[col_hierarchyid],"
                    + " INSERTED.[col_geography], INSERTED.[col_geometry],"
                    + " INSERTED.[col_not_null];"))
        .updateReturning(AllScalarTypesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<AllScalarTypesRow> upsertBatch(Iterator<AllScalarTypesRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "MERGE INTO [all_scalar_types] AS target\n"
                    + "USING (VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,"
                    + " ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)) AS source([id],"
                    + " [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal],"
                    + " [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float],"
                    + " [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text],"
                    + " [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary],"
                    + " [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time],"
                    + " [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset],"
                    + " [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion],"
                    + " [col_hierarchyid], [col_geography], [col_geometry], [col_not_null])\n"
                    + "ON target.[id] = source.[id]\n"
                    + "WHEN MATCHED THEN UPDATE SET [col_tinyint] = source.[col_tinyint],\n"
                    + "[col_smallint] = source.[col_smallint],\n"
                    + "[col_int] = source.[col_int],\n"
                    + "[col_bigint] = source.[col_bigint],\n"
                    + "[col_decimal] = source.[col_decimal],\n"
                    + "[col_numeric] = source.[col_numeric],\n"
                    + "[col_money] = source.[col_money],\n"
                    + "[col_smallmoney] = source.[col_smallmoney],\n"
                    + "[col_real] = source.[col_real],\n"
                    + "[col_float] = source.[col_float],\n"
                    + "[col_bit] = source.[col_bit],\n"
                    + "[col_char] = source.[col_char],\n"
                    + "[col_varchar] = source.[col_varchar],\n"
                    + "[col_varchar_max] = source.[col_varchar_max],\n"
                    + "[col_text] = source.[col_text],\n"
                    + "[col_nchar] = source.[col_nchar],\n"
                    + "[col_nvarchar] = source.[col_nvarchar],\n"
                    + "[col_nvarchar_max] = source.[col_nvarchar_max],\n"
                    + "[col_ntext] = source.[col_ntext],\n"
                    + "[col_binary] = source.[col_binary],\n"
                    + "[col_varbinary] = source.[col_varbinary],\n"
                    + "[col_varbinary_max] = source.[col_varbinary_max],\n"
                    + "[col_image] = source.[col_image],\n"
                    + "[col_date] = source.[col_date],\n"
                    + "[col_time] = source.[col_time],\n"
                    + "[col_datetime] = source.[col_datetime],\n"
                    + "[col_smalldatetime] = source.[col_smalldatetime],\n"
                    + "[col_datetime2] = source.[col_datetime2],\n"
                    + "[col_datetimeoffset] = source.[col_datetimeoffset],\n"
                    + "[col_uniqueidentifier] = source.[col_uniqueidentifier],\n"
                    + "[col_xml] = source.[col_xml],\n"
                    + "[col_json] = source.[col_json],\n"
                    + "[col_rowversion] = source.[col_rowversion],\n"
                    + "[col_hierarchyid] = source.[col_hierarchyid],\n"
                    + "[col_geography] = source.[col_geography],\n"
                    + "[col_geometry] = source.[col_geometry],\n"
                    + "[col_not_null] = source.[col_not_null]\n"
                    + "WHEN NOT MATCHED THEN INSERT ([id], [col_tinyint], [col_smallint],"
                    + " [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money],"
                    + " [col_smallmoney], [col_real], [col_float], [col_bit], [col_char],"
                    + " [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar],"
                    + " [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary],"
                    + " [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime],"
                    + " [col_smalldatetime], [col_datetime2], [col_datetimeoffset],"
                    + " [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion],"
                    + " [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]) VALUES"
                    + " (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,"
                    + " ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n"
                    + "OUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint],"
                    + " INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal],"
                    + " INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney],"
                    + " INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit],"
                    + " INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max],"
                    + " INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar],"
                    + " INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary],"
                    + " INSERTED.[col_varbinary], INSERTED.[col_varbinary_max],"
                    + " INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time],"
                    + " INSERTED.[col_datetime], INSERTED.[col_smalldatetime],"
                    + " INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset],"
                    + " INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json],"
                    + " INSERTED.[col_rowversion], INSERTED.[col_hierarchyid],"
                    + " INSERTED.[col_geography], INSERTED.[col_geometry],"
                    + " INSERTED.[col_not_null];"))
        .updateReturningEach(AllScalarTypesRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
