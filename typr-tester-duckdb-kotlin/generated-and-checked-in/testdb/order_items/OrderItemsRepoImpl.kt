/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.order_items

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typr.kotlindsl.DeleteBuilder
import typr.kotlindsl.Dialect
import typr.kotlindsl.Fragment
import typr.kotlindsl.KotlinDbTypes
import typr.kotlindsl.SelectBuilder
import typr.kotlindsl.UpdateBuilder
import typr.runtime.DuckDbTypes

class OrderItemsRepoImpl() : OrderItemsRepo {
  override fun delete(): DeleteBuilder<OrderItemsFields, OrderItemsRow> = DeleteBuilder.of("\"order_items\"", OrderItemsFields.structure, Dialect.DUCKDB)

  override fun deleteById(
    compositeId: OrderItemsId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"order_items\" where \"order_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, compositeId.orderId), Fragment.lit(" AND \"product_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, compositeId.productId), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    compositeIds: Array<OrderItemsId>,
    c: Connection
  ): Int {
    val orClauses: ArrayList<Fragment> = ArrayList()
    for (id in compositeIds) { orClauses.add(Fragment.interpolate(Fragment.lit("("), Fragment.lit("\"order_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, id.orderId), Fragment.lit(" AND "), Fragment.lit("\"product_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, id.productId), Fragment.lit(")"))) }
    return Fragment.interpolate(Fragment.lit("delete\nfrom \"order_items\"\nwhere "), Fragment.or(orClauses), Fragment.lit("\n")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: OrderItemsRow,
    c: Connection
  ): OrderItemsRow = Fragment.interpolate(Fragment.lit("insert into \"order_items\"(\"order_id\", \"product_id\", \"quantity\", \"unit_price\")\nvalues ("), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, unsaved.orderId), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, unsaved.productId), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, unsaved.quantity), Fragment.lit(", "), Fragment.encode(DuckDbTypes.numeric, unsaved.unitPrice), Fragment.lit(")\nRETURNING \"order_id\", \"product_id\", \"quantity\", \"unit_price\"\n"))
    .updateReturning(OrderItemsRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: OrderItemsRowUnsaved,
    c: Connection
  ): OrderItemsRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("\"order_id\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, unsaved.orderId), Fragment.lit("")))
    columns.add(Fragment.lit("\"product_id\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, unsaved.productId), Fragment.lit("")))
    columns.add(Fragment.lit("\"unit_price\""))
    values.add(Fragment.interpolate(Fragment.encode(DuckDbTypes.numeric, unsaved.unitPrice), Fragment.lit("")))
    unsaved.quantity.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"quantity\""))
      values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into \"order_items\"("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING \"order_id\", \"product_id\", \"quantity\", \"unit_price\"\n"))
    return q.updateReturning(OrderItemsRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<OrderItemsFields, OrderItemsRow> = SelectBuilder.of("\"order_items\"", OrderItemsFields.structure, OrderItemsRow._rowParser, Dialect.DUCKDB)

  override fun selectAll(c: Connection): List<OrderItemsRow> = Fragment.interpolate(Fragment.lit("select \"order_id\", \"product_id\", \"quantity\", \"unit_price\"\nfrom \"order_items\"\n")).query(OrderItemsRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    compositeId: OrderItemsId,
    c: Connection
  ): OrderItemsRow? = Fragment.interpolate(Fragment.lit("select \"order_id\", \"product_id\", \"quantity\", \"unit_price\"\nfrom \"order_items\"\nwhere \"order_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, compositeId.orderId), Fragment.lit(" AND \"product_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, compositeId.productId), Fragment.lit("")).query(OrderItemsRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    compositeIds: Array<OrderItemsId>,
    c: Connection
  ): List<OrderItemsRow> {
    val orClauses: ArrayList<Fragment> = ArrayList()
    for (id in compositeIds) { orClauses.add(Fragment.interpolate(Fragment.lit("("), Fragment.lit("\"order_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, id.orderId), Fragment.lit(" AND "), Fragment.lit("\"product_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, id.productId), Fragment.lit(")"))) }
    return Fragment.interpolate(Fragment.lit("select \"order_id\", \"product_id\", \"quantity\", \"unit_price\"\nfrom \"order_items\"\nwhere "), Fragment.or(orClauses), Fragment.lit("\n")).query(OrderItemsRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    compositeIds: Array<OrderItemsId>,
    c: Connection
  ): Map<OrderItemsId, OrderItemsRow> {
    val ret: MutableMap<OrderItemsId, OrderItemsRow> = mutableMapOf<OrderItemsId, OrderItemsRow>()
    selectByIds(compositeIds, c).forEach({ row -> ret.put(row.compositeId(), row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<OrderItemsFields, OrderItemsRow> = UpdateBuilder.of("\"order_items\"", OrderItemsFields.structure, OrderItemsRow._rowParser, Dialect.DUCKDB)

  override fun update(
    row: OrderItemsRow,
    c: Connection
  ): Boolean {
    val compositeId: OrderItemsId = row.compositeId()
    return Fragment.interpolate(Fragment.lit("update \"order_items\"\nset \"quantity\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, row.quantity), Fragment.lit(",\n\"unit_price\" = "), Fragment.encode(DuckDbTypes.numeric, row.unitPrice), Fragment.lit("\nwhere \"order_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, compositeId.orderId), Fragment.lit(" AND \"product_id\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, compositeId.productId), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: OrderItemsRow,
    c: Connection
  ): OrderItemsRow = Fragment.interpolate(Fragment.lit("INSERT INTO \"order_items\"(\"order_id\", \"product_id\", \"quantity\", \"unit_price\")\nVALUES ("), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, unsaved.orderId), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, unsaved.productId), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer, unsaved.quantity), Fragment.lit(", "), Fragment.encode(DuckDbTypes.numeric, unsaved.unitPrice), Fragment.lit(")\nON CONFLICT (\"order_id\", \"product_id\")\nDO UPDATE SET\n  \"quantity\" = EXCLUDED.\"quantity\",\n\"unit_price\" = EXCLUDED.\"unit_price\"\nRETURNING \"order_id\", \"product_id\", \"quantity\", \"unit_price\""))
    .updateReturning(OrderItemsRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<OrderItemsRow>,
    c: Connection
  ): List<OrderItemsRow> = Fragment.interpolate(Fragment.lit("INSERT INTO \"order_items\"(\"order_id\", \"product_id\", \"quantity\", \"unit_price\")\nVALUES (?, ?, ?, ?)\nON CONFLICT (\"order_id\", \"product_id\")\nDO UPDATE SET\n  \"quantity\" = EXCLUDED.\"quantity\",\n\"unit_price\" = EXCLUDED.\"unit_price\"\nRETURNING \"order_id\", \"product_id\", \"quantity\", \"unit_price\""))
    .updateReturningEach(OrderItemsRow._rowParser, unsaved)
  .runUnchecked(c)
}