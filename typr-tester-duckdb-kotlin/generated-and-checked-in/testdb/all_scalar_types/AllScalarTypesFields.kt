/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.all_scalar_types

import java.math.BigDecimal
import java.math.BigInteger
import java.time.Duration
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.OffsetDateTime
import java.util.UUID
import kotlin.collections.List
import testdb.Mood
import typr.data.Json
import typr.dsl.FieldsExpr
import typr.dsl.Path
import typr.dsl.SqlExpr.FieldLike
import typr.kotlindsl.KotlinDbTypes
import typr.kotlindsl.RelationStructure
import typr.kotlindsl.SqlExpr.Field
import typr.kotlindsl.SqlExpr.IdField
import typr.kotlindsl.SqlExpr.OptField
import typr.runtime.DuckDbTypes
import typr.runtime.RowParser

interface AllScalarTypesFields : FieldsExpr<AllScalarTypesRow> {
  abstract fun colBigint(): OptField<Long, AllScalarTypesRow>

  abstract fun colBlob(): OptField<ByteArray, AllScalarTypesRow>

  abstract fun colBoolean(): OptField<Boolean, AllScalarTypesRow>

  abstract fun colDate(): OptField<LocalDate, AllScalarTypesRow>

  abstract fun colDecimal(): OptField<BigDecimal, AllScalarTypesRow>

  abstract fun colDouble(): OptField<Double, AllScalarTypesRow>

  abstract fun colFloat(): OptField<Float, AllScalarTypesRow>

  abstract fun colHugeint(): OptField<BigInteger, AllScalarTypesRow>

  abstract fun colInteger(): OptField<Int, AllScalarTypesRow>

  abstract fun colInterval(): OptField<Duration, AllScalarTypesRow>

  abstract fun colJson(): OptField<Json, AllScalarTypesRow>

  abstract fun colMood(): OptField<Mood, AllScalarTypesRow>

  abstract fun colNotNull(): Field<String, AllScalarTypesRow>

  abstract fun colSmallint(): OptField<Short, AllScalarTypesRow>

  abstract fun colText(): OptField<String, AllScalarTypesRow>

  abstract fun colTime(): OptField<LocalTime, AllScalarTypesRow>

  abstract fun colTimestamp(): OptField<LocalDateTime, AllScalarTypesRow>

  abstract fun colTimestamptz(): OptField<OffsetDateTime, AllScalarTypesRow>

  abstract fun colTinyint(): OptField<Byte, AllScalarTypesRow>

  abstract fun colUbigint(): OptField<BigInteger, AllScalarTypesRow>

  abstract fun colUinteger(): OptField<Long, AllScalarTypesRow>

  abstract fun colUsmallint(): OptField<Int, AllScalarTypesRow>

  abstract fun colUtinyint(): OptField<Short, AllScalarTypesRow>

  abstract fun colUuid(): OptField<UUID, AllScalarTypesRow>

  abstract fun colVarchar(): OptField<String, AllScalarTypesRow>

  abstract override fun columns(): List<FieldLike<*, AllScalarTypesRow>>

  abstract fun id(): IdField<AllScalarTypesId, AllScalarTypesRow>

  override fun rowParser(): RowParser<AllScalarTypesRow> = AllScalarTypesRow._rowParser.underlying

  companion object {
    data class Impl(val _path: List<Path>) : AllScalarTypesFields, RelationStructure<AllScalarTypesFields, AllScalarTypesRow> {
      override fun id(): IdField<AllScalarTypesId, AllScalarTypesRow> = IdField<AllScalarTypesId, AllScalarTypesRow>(_path, "id", AllScalarTypesRow::id, null, "INTEGER", { row, value -> row.copy(id = value) }, AllScalarTypesId.duckDbType)

      override fun colTinyint(): OptField<Byte, AllScalarTypesRow> = OptField<Byte, AllScalarTypesRow>(_path, "col_tinyint", AllScalarTypesRow::colTinyint, null, "TINYINT", { row, value -> row.copy(colTinyint = value) }, KotlinDbTypes.DuckDbTypes.tinyint)

      override fun colSmallint(): OptField<Short, AllScalarTypesRow> = OptField<Short, AllScalarTypesRow>(_path, "col_smallint", AllScalarTypesRow::colSmallint, null, "SMALLINT", { row, value -> row.copy(colSmallint = value) }, KotlinDbTypes.DuckDbTypes.smallint)

      override fun colInteger(): OptField<Int, AllScalarTypesRow> = OptField<Int, AllScalarTypesRow>(_path, "col_integer", AllScalarTypesRow::colInteger, null, "INTEGER", { row, value -> row.copy(colInteger = value) }, KotlinDbTypes.DuckDbTypes.integer)

      override fun colBigint(): OptField<Long, AllScalarTypesRow> = OptField<Long, AllScalarTypesRow>(_path, "col_bigint", AllScalarTypesRow::colBigint, null, "BIGINT", { row, value -> row.copy(colBigint = value) }, KotlinDbTypes.DuckDbTypes.bigint)

      override fun colHugeint(): OptField<BigInteger, AllScalarTypesRow> = OptField<BigInteger, AllScalarTypesRow>(_path, "col_hugeint", AllScalarTypesRow::colHugeint, null, "HUGEINT", { row, value -> row.copy(colHugeint = value) }, DuckDbTypes.hugeint)

      override fun colUtinyint(): OptField<Short, AllScalarTypesRow> = OptField<Short, AllScalarTypesRow>(_path, "col_utinyint", AllScalarTypesRow::colUtinyint, null, "UTINYINT", { row, value -> row.copy(colUtinyint = value) }, KotlinDbTypes.DuckDbTypes.smallint)

      override fun colUsmallint(): OptField<Int, AllScalarTypesRow> = OptField<Int, AllScalarTypesRow>(_path, "col_usmallint", AllScalarTypesRow::colUsmallint, null, "USMALLINT", { row, value -> row.copy(colUsmallint = value) }, KotlinDbTypes.DuckDbTypes.integer)

      override fun colUinteger(): OptField<Long, AllScalarTypesRow> = OptField<Long, AllScalarTypesRow>(_path, "col_uinteger", AllScalarTypesRow::colUinteger, null, "UINTEGER", { row, value -> row.copy(colUinteger = value) }, KotlinDbTypes.DuckDbTypes.bigint)

      override fun colUbigint(): OptField<BigInteger, AllScalarTypesRow> = OptField<BigInteger, AllScalarTypesRow>(_path, "col_ubigint", AllScalarTypesRow::colUbigint, null, "UBIGINT", { row, value -> row.copy(colUbigint = value) }, DuckDbTypes.ubigint)

      override fun colFloat(): OptField<Float, AllScalarTypesRow> = OptField<Float, AllScalarTypesRow>(_path, "col_float", AllScalarTypesRow::colFloat, null, "FLOAT", { row, value -> row.copy(colFloat = value) }, KotlinDbTypes.DuckDbTypes.float_)

      override fun colDouble(): OptField<Double, AllScalarTypesRow> = OptField<Double, AllScalarTypesRow>(_path, "col_double", AllScalarTypesRow::colDouble, null, "DOUBLE", { row, value -> row.copy(colDouble = value) }, KotlinDbTypes.DuckDbTypes.double_)

      override fun colDecimal(): OptField<BigDecimal, AllScalarTypesRow> = OptField<BigDecimal, AllScalarTypesRow>(_path, "col_decimal", AllScalarTypesRow::colDecimal, null, "DECIMAL(10,2)", { row, value -> row.copy(colDecimal = value) }, DuckDbTypes.numeric)

      override fun colBoolean(): OptField<Boolean, AllScalarTypesRow> = OptField<Boolean, AllScalarTypesRow>(_path, "col_boolean", AllScalarTypesRow::colBoolean, null, null, { row, value -> row.copy(colBoolean = value) }, KotlinDbTypes.DuckDbTypes.boolean_)

      override fun colVarchar(): OptField<String, AllScalarTypesRow> = OptField<String, AllScalarTypesRow>(_path, "col_varchar", AllScalarTypesRow::colVarchar, null, null, { row, value -> row.copy(colVarchar = value) }, DuckDbTypes.varchar)

      override fun colText(): OptField<String, AllScalarTypesRow> = OptField<String, AllScalarTypesRow>(_path, "col_text", AllScalarTypesRow::colText, null, null, { row, value -> row.copy(colText = value) }, DuckDbTypes.varchar)

      override fun colBlob(): OptField<ByteArray, AllScalarTypesRow> = OptField<ByteArray, AllScalarTypesRow>(_path, "col_blob", AllScalarTypesRow::colBlob, null, "BLOB", { row, value -> row.copy(colBlob = value) }, DuckDbTypes.blob)

      override fun colDate(): OptField<LocalDate, AllScalarTypesRow> = OptField<LocalDate, AllScalarTypesRow>(_path, "col_date", AllScalarTypesRow::colDate, null, "DATE", { row, value -> row.copy(colDate = value) }, DuckDbTypes.date)

      override fun colTime(): OptField<LocalTime, AllScalarTypesRow> = OptField<LocalTime, AllScalarTypesRow>(_path, "col_time", AllScalarTypesRow::colTime, null, "TIME", { row, value -> row.copy(colTime = value) }, DuckDbTypes.time)

      override fun colTimestamp(): OptField<LocalDateTime, AllScalarTypesRow> = OptField<LocalDateTime, AllScalarTypesRow>(_path, "col_timestamp", AllScalarTypesRow::colTimestamp, null, "TIMESTAMP", { row, value -> row.copy(colTimestamp = value) }, DuckDbTypes.timestamp)

      override fun colTimestamptz(): OptField<OffsetDateTime, AllScalarTypesRow> = OptField<OffsetDateTime, AllScalarTypesRow>(_path, "col_timestamptz", AllScalarTypesRow::colTimestamptz, null, "TIMESTAMP WITH TIME ZONE", { row, value -> row.copy(colTimestamptz = value) }, DuckDbTypes.timestamptz)

      override fun colInterval(): OptField<Duration, AllScalarTypesRow> = OptField<Duration, AllScalarTypesRow>(_path, "col_interval", AllScalarTypesRow::colInterval, null, "INTERVAL", { row, value -> row.copy(colInterval = value) }, DuckDbTypes.interval)

      override fun colUuid(): OptField<UUID, AllScalarTypesRow> = OptField<UUID, AllScalarTypesRow>(_path, "col_uuid", AllScalarTypesRow::colUuid, null, "UUID", { row, value -> row.copy(colUuid = value) }, DuckDbTypes.uuid)

      override fun colJson(): OptField<Json, AllScalarTypesRow> = OptField<Json, AllScalarTypesRow>(_path, "col_json", AllScalarTypesRow::colJson, null, "JSON", { row, value -> row.copy(colJson = value) }, DuckDbTypes.json)

      override fun colMood(): OptField<Mood, AllScalarTypesRow> = OptField<Mood, AllScalarTypesRow>(_path, "col_mood", AllScalarTypesRow::colMood, null, "mood", { row, value -> row.copy(colMood = value) }, Mood.duckDbType)

      override fun colNotNull(): Field<String, AllScalarTypesRow> = Field<String, AllScalarTypesRow>(_path, "col_not_null", AllScalarTypesRow::colNotNull, null, null, { row, value -> row.copy(colNotNull = value) }, DuckDbTypes.varchar)

      override fun _path(): List<Path> = _path

      override fun columns(): List<FieldLike<*, AllScalarTypesRow>> = listOf(this.id().underlying, this.colTinyint().underlying, this.colSmallint().underlying, this.colInteger().underlying, this.colBigint().underlying, this.colHugeint().underlying, this.colUtinyint().underlying, this.colUsmallint().underlying, this.colUinteger().underlying, this.colUbigint().underlying, this.colFloat().underlying, this.colDouble().underlying, this.colDecimal().underlying, this.colBoolean().underlying, this.colVarchar().underlying, this.colText().underlying, this.colBlob().underlying, this.colDate().underlying, this.colTime().underlying, this.colTimestamp().underlying, this.colTimestamptz().underlying, this.colInterval().underlying, this.colUuid().underlying, this.colJson().underlying, this.colMood().underlying, this.colNotNull().underlying)

      override fun withPaths(_path: List<Path>): RelationStructure<AllScalarTypesFields, AllScalarTypesRow> = Impl(_path)
    }

    val structure: Impl = Impl(emptyList<typr.dsl.Path>())
  }
}