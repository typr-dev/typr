/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.purchasing.productvendor

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.Defaulted.UseDefault
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.math.BigDecimal
import typo.runtime.PgText
import typo.runtime.PgTypes

/** This class corresponds to a row in table `purchasing.productvendor` which has not been persisted yet */
data class ProductvendorRowUnsaved(
  /** Primary key. Foreign key to Product.ProductID.
    * Points to [adventureworks.production.product.ProductRow.productid]
    */
  val productid: ProductId,
  /** Primary key. Foreign key to Vendor.BusinessEntityID.
    * Points to [adventureworks.purchasing.vendor.VendorRow.businessentityid]
    */
  val businessentityid: BusinessentityId,
  /** The average span of time (in days) between placing an order with the vendor and receiving the purchased product.
    * Constraint CK_ProductVendor_AverageLeadTime affecting columns averageleadtime:  ((averageleadtime >= 1))
    */
  val averageleadtime: Int,
  /** The vendor's usual selling price.
    * Constraint CK_ProductVendor_StandardPrice affecting columns standardprice:  ((standardprice > 0.00))
    */
  val standardprice: BigDecimal,
  /** The selling price when last purchased.
    * Constraint CK_ProductVendor_LastReceiptCost affecting columns lastreceiptcost:  ((lastreceiptcost > 0.00))
    */
  val lastreceiptcost: BigDecimal?,
  /** Date the product was last received by the vendor. */
  val lastreceiptdate: TypoLocalDateTime?,
  /** The maximum quantity that should be ordered.
    * Constraint CK_ProductVendor_MinOrderQty affecting columns minorderqty:  ((minorderqty >= 1))
    */
  val minorderqty: Int,
  /** The minimum quantity that should be ordered.
    * Constraint CK_ProductVendor_MaxOrderQty affecting columns maxorderqty:  ((maxorderqty >= 1))
    */
  val maxorderqty: Int,
  /** The quantity currently on order.
    * Constraint CK_ProductVendor_OnOrderQty affecting columns onorderqty:  ((onorderqty >= 0))
    */
  val onorderqty: Int?,
  /** The product's unit of measure.
    * Points to [adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]
    */
  val unitmeasurecode: UnitmeasureId,
  /** Default: now() */
  val modifieddate: Defaulted<TypoLocalDateTime>
) {
  constructor(productid: ProductId, businessentityid: BusinessentityId, averageleadtime: Int, standardprice: BigDecimal, minorderqty: Int, maxorderqty: Int, unitmeasurecode: UnitmeasureId) : this(productid, businessentityid, averageleadtime, standardprice, null, null, minorderqty, maxorderqty, null, unitmeasurecode, UseDefault())

  fun toRow(modifieddateDefault: () -> TypoLocalDateTime): ProductvendorRow = ProductvendorRow(productid = productid, businessentityid = businessentityid, averageleadtime = averageleadtime, standardprice = standardprice, lastreceiptcost = lastreceiptcost, lastreceiptdate = lastreceiptdate, minorderqty = minorderqty, maxorderqty = maxorderqty, onorderqty = onorderqty, unitmeasurecode = unitmeasurecode, modifieddate = modifieddate.getOrElse(modifieddateDefault))

  companion object {
    val pgText: PgText<ProductvendorRowUnsaved> =
      PgText.instance({ row, sb -> {
        ProductId.pgType.pgText.unsafeEncode(row.productid, sb);
        sb.append(PgText.DELIMETER);
        BusinessentityId.pgType.pgText.unsafeEncode(row.businessentityid, sb);
        sb.append(PgText.DELIMETER);
        PgTypes.int4.pgText.unsafeEncode(row.averageleadtime, sb);
        sb.append(PgText.DELIMETER);
        PgTypes.numeric.pgText.unsafeEncode(row.standardprice, sb);
        sb.append(PgText.DELIMETER);
        PgTypes.numeric.opt().pgText.unsafeEncode(row.lastreceiptcost, sb);
        sb.append(PgText.DELIMETER);
        TypoLocalDateTime.pgType.opt().pgText.unsafeEncode(row.lastreceiptdate, sb);
        sb.append(PgText.DELIMETER);
        PgTypes.int4.pgText.unsafeEncode(row.minorderqty, sb);
        sb.append(PgText.DELIMETER);
        PgTypes.int4.pgText.unsafeEncode(row.maxorderqty, sb);
        sb.append(PgText.DELIMETER);
        PgTypes.int4.opt().pgText.unsafeEncode(row.onorderqty, sb);
        sb.append(PgText.DELIMETER);
        UnitmeasureId.pgType.pgText.unsafeEncode(row.unitmeasurecode, sb);
        sb.append(PgText.DELIMETER);
        Defaulted.pgText(TypoLocalDateTime.pgType.pgText).unsafeEncode(row.modifieddate, sb);
      } })
  }
}