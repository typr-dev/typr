/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.document

import adventureworks.customtypes.TypoBytea
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.customtypes.TypoShort
import adventureworks.customtypes.TypoUUID
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.public.Flag
import java.sql.Connection
import java.util.ArrayList
import java.util.HashMap
import java.util.Iterator
import java.util.List
import kotlin.collections.Map
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.PgTypes
import typo.runtime.streamingInsert
import typo.runtime.Fragment.interpolate
import typo.runtime.internal.stringInterpolator.str

data class DocumentRepoImpl() : DocumentRepo {
  fun deleteById(
    documentnode: DocumentId,
    c: Connection
  ): Boolean = interpolate(
    typo.runtime.Fragment.lit("""
    delete from "production"."document" where "documentnode" = 
    """.trimMargin()),
    DocumentId.pgType.encode(documentnode),
    typo.runtime.Fragment.lit("")
  ).update().runUnchecked(c) > 0

  fun deleteByIds(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): Int = interpolate(
             typo.runtime.Fragment.lit("""
               delete
               from "production"."document"
               where "documentnode" = ANY(""".trimMargin()),
             DocumentId.pgTypeArray.encode(documentnodes),
             typo.runtime.Fragment.lit(")")
           )
    .update()
    .runUnchecked(c)

  fun insert(
    unsaved: DocumentRow,
    c: Connection
  ): DocumentRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode")
      values (""".trimMargin()),
    PgTypes.text.encode(unsaved.title),
    typo.runtime.Fragment.lit(", "),
    BusinessentityId.pgType.encode(unsaved.owner),
    typo.runtime.Fragment.lit("::int4, "),
    Flag.pgType.encode(unsaved.folderflag),
    typo.runtime.Fragment.lit("::bool, "),
    PgTypes.text.encode(unsaved.filename),
    typo.runtime.Fragment.lit(", "),
    PgTypes.text.opt().encode(unsaved.fileextension),
    typo.runtime.Fragment.lit(", "),
    PgTypes.text.encode(unsaved.revision),
    typo.runtime.Fragment.lit("::bpchar, "),
    PgTypes.int4.encode(unsaved.changenumber),
    typo.runtime.Fragment.lit("::int4, "),
    TypoShort.pgType.encode(unsaved.status),
    typo.runtime.Fragment.lit("::int2, "),
    PgTypes.text.opt().encode(unsaved.documentsummary),
    typo.runtime.Fragment.lit(", "),
    TypoBytea.pgType.opt().encode(unsaved.document),
    typo.runtime.Fragment.lit("::bytea, "),
    TypoUUID.pgType.encode(unsaved.rowguid),
    typo.runtime.Fragment.lit("::uuid, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("::timestamp, "),
    DocumentId.pgType.encode(unsaved.documentnode),
    typo.runtime.Fragment.lit("""
      )
      returning "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
    """.trimMargin())
  )
    .updateReturning(DocumentRow._rowParser.exactlyOne()).runUnchecked(c)

  fun insert(
    unsaved: DocumentRowUnsaved,
    c: Connection
  ): DocumentRow {
    val columns: List<Literal> = ArrayList()
      val values: List<Fragment> = ArrayList()
      columns.add(Fragment.lit("\"title\""));
      values.add(interpolate(
                   PgTypes.text.encode(unsaved.title),
                   typo.runtime.Fragment.lit("""
                   """.trimMargin())
                 ));
      columns.add(Fragment.lit("\"owner\""));
      values.add(interpolate(
                   BusinessentityId.pgType.encode(unsaved.owner),
                   typo.runtime.Fragment.lit("::int4")
                 ));
      columns.add(Fragment.lit("\"filename\""));
      values.add(interpolate(
                   PgTypes.text.encode(unsaved.filename),
                   typo.runtime.Fragment.lit("""
                   """.trimMargin())
                 ));
      columns.add(Fragment.lit("\"fileextension\""));
      values.add(interpolate(
                   PgTypes.text.opt().encode(unsaved.fileextension),
                   typo.runtime.Fragment.lit("""
                   """.trimMargin())
                 ));
      columns.add(Fragment.lit("\"revision\""));
      values.add(interpolate(
                   PgTypes.text.encode(unsaved.revision),
                   typo.runtime.Fragment.lit("::bpchar")
                 ));
      columns.add(Fragment.lit("\"status\""));
      values.add(interpolate(
                   TypoShort.pgType.encode(unsaved.status),
                   typo.runtime.Fragment.lit("::int2")
                 ));
      columns.add(Fragment.lit("\"documentsummary\""));
      values.add(interpolate(
                   PgTypes.text.opt().encode(unsaved.documentsummary),
                   typo.runtime.Fragment.lit("""
                   """.trimMargin())
                 ));
      columns.add(Fragment.lit("\"document\""));
      values.add(interpolate(
                   TypoBytea.pgType.opt().encode(unsaved.document),
                   typo.runtime.Fragment.lit("::bytea")
                 ));
      unsaved.folderflag.visit(
        { {} },
        { value -> {
        columns.add(Fragment.lit("\"folderflag\""));
        values.add(interpolate(
                     Flag.pgType.encode(value),
                     typo.runtime.Fragment.lit("::bool")
                   ));
      } }
      );
      unsaved.changenumber.visit(
        { {} },
        { value -> {
        columns.add(Fragment.lit("\"changenumber\""));
        values.add(interpolate(
                     PgTypes.int4.encode(value),
                     typo.runtime.Fragment.lit("::int4")
                   ));
      } }
      );
      unsaved.rowguid.visit(
        { {} },
        { value -> {
        columns.add(Fragment.lit("\"rowguid\""));
        values.add(interpolate(
                     TypoUUID.pgType.encode(value),
                     typo.runtime.Fragment.lit("::uuid")
                   ));
      } }
      );
      unsaved.modifieddate.visit(
        { {} },
        { value -> {
        columns.add(Fragment.lit("\"modifieddate\""));
        values.add(interpolate(
                     TypoLocalDateTime.pgType.encode(value),
                     typo.runtime.Fragment.lit("::timestamp")
                   ));
      } }
      );
      unsaved.documentnode.visit(
        { {} },
        { value -> {
        columns.add(Fragment.lit("\"documentnode\""));
        values.add(interpolate(
                     DocumentId.pgType.encode(value),
                     typo.runtime.Fragment.lit("""
                     """.trimMargin())
                   ));
      } }
      );
      val q: Fragment = interpolate(
        typo.runtime.Fragment.lit("""
        insert into "production"."document"(
        """.trimMargin()),
        Fragment.comma(columns),
        typo.runtime.Fragment.lit("""
          )
          values (""".trimMargin()),
        Fragment.comma(values),
        typo.runtime.Fragment.lit("""
          )
          returning "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
        """.trimMargin())
      )
    return q.updateReturning(DocumentRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  fun insertStreaming(
    unsaved: Iterator<DocumentRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode") FROM STDIN
  """.trimMargin()), batchSize, unsaved, c, DocumentRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  fun insertUnsavedStreaming(
    unsaved: Iterator<DocumentRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "production"."document"("title", "owner", "filename", "fileextension", "revision", "status", "documentsummary", "document", "folderflag", "changenumber", "rowguid", "modifieddate", "documentnode") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')
  """.trimMargin()), batchSize, unsaved, c, DocumentRowUnsaved.pgText)

  fun selectAll(c: Connection): kotlin.collections.List<DocumentRow> = interpolate(typo.runtime.Fragment.lit("""
    select "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
    from "production"."document"
  """.trimMargin())).as(DocumentRow._rowParser.all()).runUnchecked(c)

  fun selectById(
    documentnode: DocumentId,
    c: Connection
  ): DocumentRow? = interpolate(
    typo.runtime.Fragment.lit("""
      select "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
      from "production"."document"
      where "documentnode" = """.trimMargin()),
    DocumentId.pgType.encode(documentnode),
    typo.runtime.Fragment.lit("")
  ).as(DocumentRow._rowParser.first()).runUnchecked(c)

  fun selectByIds(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): kotlin.collections.List<DocumentRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
      from "production"."document"
      where "documentnode" = ANY(""".trimMargin()),
    DocumentId.pgTypeArray.encode(documentnodes),
    typo.runtime.Fragment.lit(")")
  ).as(DocumentRow._rowParser.all()).runUnchecked(c)

  fun selectByIdsTracked(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): Map<DocumentId, DocumentRow> {
    val ret: java.util.Map<DocumentId, DocumentRow> = HashMap()
      for (var row : selectByIds(documentnodes, c)) {
          ret.put(row.id(), row);
      }
    return ret
  }

  fun selectByUniqueRowguid(
    rowguid: TypoUUID,
    c: Connection
  ): DocumentRow? = interpolate(
    typo.runtime.Fragment.lit("""
      select "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
      from "production"."document"
      where "rowguid" = """.trimMargin()),
    TypoUUID.pgType.encode(rowguid),
    typo.runtime.Fragment.lit("""


    """.trimMargin())
  ).as(DocumentRow._rowParser.first()).runUnchecked(c)

  fun update(
    row: DocumentRow,
    c: Connection
  ): Boolean {
    val documentnode: DocumentId = row.documentnode
    return interpolate(
             typo.runtime.Fragment.lit("""
               update "production"."document"
               set "title" = """.trimMargin()),
             PgTypes.text.encode(row.title),
             typo.runtime.Fragment.lit("""
               ,
               "owner" = """.trimMargin()),
             BusinessentityId.pgType.encode(row.owner),
             typo.runtime.Fragment.lit("""
               ::int4,
               "folderflag" = """.trimMargin()),
             Flag.pgType.encode(row.folderflag),
             typo.runtime.Fragment.lit("""
               ::bool,
               "filename" = """.trimMargin()),
             PgTypes.text.encode(row.filename),
             typo.runtime.Fragment.lit("""
               ,
               "fileextension" = """.trimMargin()),
             PgTypes.text.opt().encode(row.fileextension),
             typo.runtime.Fragment.lit("""
               ,
               "revision" = """.trimMargin()),
             PgTypes.text.encode(row.revision),
             typo.runtime.Fragment.lit("""
               ::bpchar,
               "changenumber" = """.trimMargin()),
             PgTypes.int4.encode(row.changenumber),
             typo.runtime.Fragment.lit("""
               ::int4,
               "status" = """.trimMargin()),
             TypoShort.pgType.encode(row.status),
             typo.runtime.Fragment.lit("""
               ::int2,
               "documentsummary" = """.trimMargin()),
             PgTypes.text.opt().encode(row.documentsummary),
             typo.runtime.Fragment.lit("""
               ,
               "document" = """.trimMargin()),
             TypoBytea.pgType.opt().encode(row.document),
             typo.runtime.Fragment.lit("""
               ::bytea,
               "rowguid" = """.trimMargin()),
             TypoUUID.pgType.encode(row.rowguid),
             typo.runtime.Fragment.lit("""
               ::uuid,
               "modifieddate" = """.trimMargin()),
             TypoLocalDateTime.pgType.encode(row.modifieddate),
             typo.runtime.Fragment.lit("""
               ::timestamp
               where "documentnode" = """.trimMargin()),
             DocumentId.pgType.encode(documentnode),
             typo.runtime.Fragment.lit("")
           ).update().runUnchecked(c) > 0
  }

  fun upsert(
    unsaved: DocumentRow,
    c: Connection
  ): DocumentRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode")
      values (""".trimMargin()),
    PgTypes.text.encode(unsaved.title),
    typo.runtime.Fragment.lit(", "),
    BusinessentityId.pgType.encode(unsaved.owner),
    typo.runtime.Fragment.lit("::int4, "),
    Flag.pgType.encode(unsaved.folderflag),
    typo.runtime.Fragment.lit("::bool, "),
    PgTypes.text.encode(unsaved.filename),
    typo.runtime.Fragment.lit(", "),
    PgTypes.text.opt().encode(unsaved.fileextension),
    typo.runtime.Fragment.lit(", "),
    PgTypes.text.encode(unsaved.revision),
    typo.runtime.Fragment.lit("::bpchar, "),
    PgTypes.int4.encode(unsaved.changenumber),
    typo.runtime.Fragment.lit("::int4, "),
    TypoShort.pgType.encode(unsaved.status),
    typo.runtime.Fragment.lit("::int2, "),
    PgTypes.text.opt().encode(unsaved.documentsummary),
    typo.runtime.Fragment.lit(", "),
    TypoBytea.pgType.opt().encode(unsaved.document),
    typo.runtime.Fragment.lit("::bytea, "),
    TypoUUID.pgType.encode(unsaved.rowguid),
    typo.runtime.Fragment.lit("::uuid, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("::timestamp, "),
    DocumentId.pgType.encode(unsaved.documentnode),
    typo.runtime.Fragment.lit("""
      )
      on conflict ("documentnode")
      do update set
        "title" = EXCLUDED."title",
      "owner" = EXCLUDED."owner",
      "folderflag" = EXCLUDED."folderflag",
      "filename" = EXCLUDED."filename",
      "fileextension" = EXCLUDED."fileextension",
      "revision" = EXCLUDED."revision",
      "changenumber" = EXCLUDED."changenumber",
      "status" = EXCLUDED."status",
      "documentsummary" = EXCLUDED."documentsummary",
      "document" = EXCLUDED."document",
      "rowguid" = EXCLUDED."rowguid",
      "modifieddate" = EXCLUDED."modifieddate"
      returning "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
    """.trimMargin())
  )
    .updateReturning(DocumentRow._rowParser.exactlyOne())
    .runUnchecked(c)

  fun upsertBatch(
    unsaved: Iterator<DocumentRow>,
    c: Connection
  ): kotlin.collections.List<DocumentRow> = interpolate(typo.runtime.Fragment.lit("""
                                              insert into "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode")
                                              values (?, ?::int4, ?::bool, ?, ?, ?::bpchar, ?::int4, ?::int2, ?, ?::bytea, ?::uuid, ?::timestamp, ?)
                                              on conflict ("documentnode")
                                              do update set
                                                "title" = EXCLUDED."title",
                                              "owner" = EXCLUDED."owner",
                                              "folderflag" = EXCLUDED."folderflag",
                                              "filename" = EXCLUDED."filename",
                                              "fileextension" = EXCLUDED."fileextension",
                                              "revision" = EXCLUDED."revision",
                                              "changenumber" = EXCLUDED."changenumber",
                                              "status" = EXCLUDED."status",
                                              "documentsummary" = EXCLUDED."documentsummary",
                                              "document" = EXCLUDED."document",
                                              "rowguid" = EXCLUDED."rowguid",
                                              "modifieddate" = EXCLUDED."modifieddate"
                                              returning "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
                                            """.trimMargin()))
    .updateManyReturning(DocumentRow._rowParser, unsaved)
    .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  fun upsertStreaming(
    unsaved: Iterator<DocumentRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    interpolate(typo.runtime.Fragment.lit("""
      create temporary table document_TEMP (like "production"."document") on commit drop
      """.trimMargin())).update().runUnchecked(c)
      streamingInsert.insertUnchecked(str("""
      copy document_TEMP("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode") from stdin
      """.trimMargin()), batchSize, unsaved, c, DocumentRow.pgText)
    return interpolate(typo.runtime.Fragment.lit("""
             insert into "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode")
             select * from document_TEMP
             on conflict ("documentnode")
             do update set
               "title" = EXCLUDED."title",
             "owner" = EXCLUDED."owner",
             "folderflag" = EXCLUDED."folderflag",
             "filename" = EXCLUDED."filename",
             "fileextension" = EXCLUDED."fileextension",
             "revision" = EXCLUDED."revision",
             "changenumber" = EXCLUDED."changenumber",
             "status" = EXCLUDED."status",
             "documentsummary" = EXCLUDED."documentsummary",
             "document" = EXCLUDED."document",
             "rowguid" = EXCLUDED."rowguid",
             "modifieddate" = EXCLUDED."modifieddate"
             ;
             drop table document_TEMP;""".trimMargin())).update().runUnchecked(c)
  }
}