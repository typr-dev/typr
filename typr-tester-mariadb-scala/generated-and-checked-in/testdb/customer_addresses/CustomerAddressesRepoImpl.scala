/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.customer_addresses

import java.sql.Connection
import scala.collection.mutable.ListBuffer
import testdb.customers.CustomersId
import typr.runtime.MariaTypes
import typr.scaladsl.DeleteBuilder
import typr.scaladsl.Dialect
import typr.scaladsl.Fragment
import typr.scaladsl.MariaTypeOps
import typr.scaladsl.ScalaDbTypes
import typr.scaladsl.SelectBuilder
import typr.scaladsl.UpdateBuilder
import typr.scaladsl.Fragment.sql

class CustomerAddressesRepoImpl extends CustomerAddressesRepo {
  override def delete: DeleteBuilder[CustomerAddressesFields, CustomerAddressesRow] = DeleteBuilder.of("`customer_addresses`", CustomerAddressesFields.structure, Dialect.MARIADB)

  override def deleteById(addressId: CustomerAddressesId)(using c: Connection): Boolean = sql"delete from `customer_addresses` where `address_id` = ${Fragment.encode(CustomerAddressesId.pgType, addressId)}".update().runUnchecked(c) > 0

  override def deleteByIds(addressIds: Array[CustomerAddressesId])(using c: Connection): Int = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    addressIds.foreach { id => fragments.addOne(Fragment.encode(CustomerAddressesId.pgType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("delete from `customer_addresses` where `address_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: CustomerAddressesRow)(using c: Connection): CustomerAddressesRow = {
  sql"""insert into `customer_addresses`(`customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`)
    values (${Fragment.encode(CustomersId.pgType, unsaved.customerId)}, ${Fragment.encode(MariaTypes.text, unsaved.addressType)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.bool, unsaved.isDefault)}, ${Fragment.encode(MariaTypes.varchar, unsaved.recipientName)}, ${Fragment.encode(MariaTypes.varchar, unsaved.streetLine1)}, ${Fragment.encode(MariaTypes.varchar.nullable, unsaved.streetLine2)}, ${Fragment.encode(MariaTypes.varchar, unsaved.city)}, ${Fragment.encode(MariaTypes.varchar.nullable, unsaved.stateProvince)}, ${Fragment.encode(MariaTypes.varchar, unsaved.postalCode)}, ${Fragment.encode(MariaTypes.char_, unsaved.countryCode)}, ${Fragment.encode(MariaTypes.point.nullable, unsaved.location)}, ${Fragment.encode(MariaTypes.tinytext.nullable, unsaved.deliveryNotes)}, ${Fragment.encode(MariaTypes.datetime, unsaved.createdAt)})
    RETURNING `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`
    """
    .updateReturning(CustomerAddressesRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: CustomerAddressesRowUnsaved)(using c: Connection): CustomerAddressesRow = {
    val columns: ListBuffer[Fragment] = ListBuffer()
    val values: ListBuffer[Fragment] = ListBuffer()
    columns.addOne(Fragment.lit("`customer_id`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(CustomersId.pgType, unsaved.customerId)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`address_type`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.text, unsaved.addressType)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`recipient_name`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.varchar, unsaved.recipientName)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`street_line1`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.varchar, unsaved.streetLine1)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`city`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.varchar, unsaved.city)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`postal_code`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.varchar, unsaved.postalCode)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`country_code`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.char_, unsaved.countryCode)}"): @scala.annotation.nowarn
    unsaved.isDefault.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`is_default`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.bool, value)}"): @scala.annotation.nowarn }
    );
    unsaved.streetLine2.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`street_line2`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.varchar.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.stateProvince.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`state_province`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.varchar.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.location.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`location`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.point.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.deliveryNotes.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`delivery_notes`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.tinytext.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.createdAt.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`created_at`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.datetime, value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      sql"""insert into `customer_addresses`(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      RETURNING `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`
      """
    }
    return q.updateReturning(CustomerAddressesRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[CustomerAddressesFields, CustomerAddressesRow] = SelectBuilder.of("`customer_addresses`", CustomerAddressesFields.structure, CustomerAddressesRow.`_rowParser`, Dialect.MARIADB)

  override def selectAll(using c: Connection): List[CustomerAddressesRow] = {
    sql"""select `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`
    from `customer_addresses`
    """.query(CustomerAddressesRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(addressId: CustomerAddressesId)(using c: Connection): Option[CustomerAddressesRow] = {
    sql"""select `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`
    from `customer_addresses`
    where `address_id` = ${Fragment.encode(CustomerAddressesId.pgType, addressId)}""".query(CustomerAddressesRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(addressIds: Array[CustomerAddressesId])(using c: Connection): List[CustomerAddressesRow] = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    addressIds.foreach { id => fragments.addOne(Fragment.encode(CustomerAddressesId.pgType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("select `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at` from `customer_addresses` where `address_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).query(CustomerAddressesRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(addressIds: Array[CustomerAddressesId])(using c: Connection): Map[CustomerAddressesId, CustomerAddressesRow] = {
    val ret: scala.collection.mutable.Map[CustomerAddressesId, CustomerAddressesRow] = scala.collection.mutable.Map.empty[CustomerAddressesId, CustomerAddressesRow]
    selectByIds(addressIds)(using c).foreach(row => ret.put(row.addressId, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def update: UpdateBuilder[CustomerAddressesFields, CustomerAddressesRow] = UpdateBuilder.of("`customer_addresses`", CustomerAddressesFields.structure, CustomerAddressesRow.`_rowParser`, Dialect.MARIADB)

  override def update(row: CustomerAddressesRow)(using c: Connection): Boolean = {
    val addressId: CustomerAddressesId = row.addressId
    return sql"""update `customer_addresses`
    set `customer_id` = ${Fragment.encode(CustomersId.pgType, row.customerId)},
    `address_type` = ${Fragment.encode(MariaTypes.text, row.addressType)},
    `is_default` = ${Fragment.encode(ScalaDbTypes.MariaTypes.bool, row.isDefault)},
    `recipient_name` = ${Fragment.encode(MariaTypes.varchar, row.recipientName)},
    `street_line1` = ${Fragment.encode(MariaTypes.varchar, row.streetLine1)},
    `street_line2` = ${Fragment.encode(MariaTypes.varchar.nullable, row.streetLine2)},
    `city` = ${Fragment.encode(MariaTypes.varchar, row.city)},
    `state_province` = ${Fragment.encode(MariaTypes.varchar.nullable, row.stateProvince)},
    `postal_code` = ${Fragment.encode(MariaTypes.varchar, row.postalCode)},
    `country_code` = ${Fragment.encode(MariaTypes.char_, row.countryCode)},
    `location` = ${Fragment.encode(MariaTypes.point.nullable, row.location)},
    `delivery_notes` = ${Fragment.encode(MariaTypes.tinytext.nullable, row.deliveryNotes)},
    `created_at` = ${Fragment.encode(MariaTypes.datetime, row.createdAt)}
    where `address_id` = ${Fragment.encode(CustomerAddressesId.pgType, addressId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: CustomerAddressesRow)(using c: Connection): CustomerAddressesRow = {
  sql"""INSERT INTO `customer_addresses`(`customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`)
    VALUES (${Fragment.encode(CustomersId.pgType, unsaved.customerId)}, ${Fragment.encode(MariaTypes.text, unsaved.addressType)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.bool, unsaved.isDefault)}, ${Fragment.encode(MariaTypes.varchar, unsaved.recipientName)}, ${Fragment.encode(MariaTypes.varchar, unsaved.streetLine1)}, ${Fragment.encode(MariaTypes.varchar.nullable, unsaved.streetLine2)}, ${Fragment.encode(MariaTypes.varchar, unsaved.city)}, ${Fragment.encode(MariaTypes.varchar.nullable, unsaved.stateProvince)}, ${Fragment.encode(MariaTypes.varchar, unsaved.postalCode)}, ${Fragment.encode(MariaTypes.char_, unsaved.countryCode)}, ${Fragment.encode(MariaTypes.point.nullable, unsaved.location)}, ${Fragment.encode(MariaTypes.tinytext.nullable, unsaved.deliveryNotes)}, ${Fragment.encode(MariaTypes.datetime, unsaved.createdAt)})
    ON DUPLICATE KEY UPDATE `customer_id` = VALUES(`customer_id`),
    `address_type` = VALUES(`address_type`),
    `is_default` = VALUES(`is_default`),
    `recipient_name` = VALUES(`recipient_name`),
    `street_line1` = VALUES(`street_line1`),
    `street_line2` = VALUES(`street_line2`),
    `city` = VALUES(`city`),
    `state_province` = VALUES(`state_province`),
    `postal_code` = VALUES(`postal_code`),
    `country_code` = VALUES(`country_code`),
    `location` = VALUES(`location`),
    `delivery_notes` = VALUES(`delivery_notes`),
    `created_at` = VALUES(`created_at`)
    RETURNING `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`"""
    .updateReturning(CustomerAddressesRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[CustomerAddressesRow])(using c: Connection): List[CustomerAddressesRow] = {
    sql"""INSERT INTO `customer_addresses`(`address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON DUPLICATE KEY UPDATE `customer_id` = VALUES(`customer_id`),
    `address_type` = VALUES(`address_type`),
    `is_default` = VALUES(`is_default`),
    `recipient_name` = VALUES(`recipient_name`),
    `street_line1` = VALUES(`street_line1`),
    `street_line2` = VALUES(`street_line2`),
    `city` = VALUES(`city`),
    `state_province` = VALUES(`state_province`),
    `postal_code` = VALUES(`postal_code`),
    `country_code` = VALUES(`country_code`),
    `location` = VALUES(`location`),
    `delivery_notes` = VALUES(`delivery_notes`),
    `created_at` = VALUES(`created_at`)
    RETURNING `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`"""
      .updateReturningEach(CustomerAddressesRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}