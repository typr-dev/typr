/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.promotions

import java.sql.Connection
import scala.collection.mutable.ListBuffer
import typr.runtime.MariaTypes
import typr.scaladsl.DeleteBuilder
import typr.scaladsl.Dialect
import typr.scaladsl.Fragment
import typr.scaladsl.MariaTypeOps
import typr.scaladsl.ScalaDbTypes
import typr.scaladsl.SelectBuilder
import typr.scaladsl.UpdateBuilder
import typr.scaladsl.Fragment.sql

class PromotionsRepoImpl extends PromotionsRepo {
  override def delete: DeleteBuilder[PromotionsFields, PromotionsRow] = DeleteBuilder.of("`promotions`", PromotionsFields.structure, Dialect.MARIADB)

  override def deleteById(promotionId: PromotionsId)(using c: Connection): Boolean = sql"delete from `promotions` where `promotion_id` = ${Fragment.encode(PromotionsId.pgType, promotionId)}".update().runUnchecked(c) > 0

  override def deleteByIds(promotionIds: Array[PromotionsId])(using c: Connection): Int = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    promotionIds.foreach { id => fragments.addOne(Fragment.encode(PromotionsId.pgType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("delete from `promotions` where `promotion_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: PromotionsRow)(using c: Connection): PromotionsRow = {
  sql"""insert into `promotions`(`code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`)
    values (${Fragment.encode(MariaTypes.varchar, unsaved.code)}, ${Fragment.encode(MariaTypes.varchar, unsaved.name)}, ${Fragment.encode(MariaTypes.text.nullable, unsaved.description)}, ${Fragment.encode(MariaTypes.text, unsaved.discountType)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.numeric, unsaved.discountValue)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.numeric.nullable, unsaved.minOrderAmount)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.intUnsigned.nullable, unsaved.maxUses)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.intUnsigned, unsaved.usesCount)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.tinyintUnsigned.nullable, unsaved.maxUsesPerCustomer)}, ${Fragment.encode(MariaTypes.set.nullable, unsaved.applicableTo)}, ${Fragment.encode(MariaTypes.longtext.nullable, unsaved.rulesJson)}, ${Fragment.encode(MariaTypes.datetime, unsaved.validFrom)}, ${Fragment.encode(MariaTypes.datetime, unsaved.validTo)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.bool, unsaved.isActive)}, ${Fragment.encode(MariaTypes.datetime, unsaved.createdAt)})
    RETURNING `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
    """
    .updateReturning(PromotionsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: PromotionsRowUnsaved)(using c: Connection): PromotionsRow = {
    val columns: ListBuffer[Fragment] = ListBuffer()
    val values: ListBuffer[Fragment] = ListBuffer()
    columns.addOne(Fragment.lit("`code`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.varchar, unsaved.code)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`name`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.varchar, unsaved.name)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`discount_type`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.text, unsaved.discountType)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`discount_value`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.numeric, unsaved.discountValue)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`valid_from`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.datetime, unsaved.validFrom)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("`valid_to`")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(MariaTypes.datetime, unsaved.validTo)}"): @scala.annotation.nowarn
    unsaved.description.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`description`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.text.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.minOrderAmount.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`min_order_amount`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.numeric.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.maxUses.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`max_uses`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.intUnsigned.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.usesCount.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`uses_count`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.intUnsigned, value)}"): @scala.annotation.nowarn }
    );
    unsaved.maxUsesPerCustomer.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`max_uses_per_customer`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.tinyintUnsigned.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.applicableTo.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`applicable_to`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.set.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.rulesJson.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`rules_json`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.longtext.nullable, value)}"): @scala.annotation.nowarn }
    );
    unsaved.isActive.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`is_active`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.MariaTypes.bool, value)}"): @scala.annotation.nowarn }
    );
    unsaved.createdAt.visit(
      {  },
      value => { columns.addOne(Fragment.lit("`created_at`")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(MariaTypes.datetime, value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      sql"""insert into `promotions`(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      RETURNING `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
      """
    }
    return q.updateReturning(PromotionsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[PromotionsFields, PromotionsRow] = SelectBuilder.of("`promotions`", PromotionsFields.structure, PromotionsRow.`_rowParser`, Dialect.MARIADB)

  override def selectAll(using c: Connection): List[PromotionsRow] = {
    sql"""select `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
    from `promotions`
    """.query(PromotionsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(promotionId: PromotionsId)(using c: Connection): Option[PromotionsRow] = {
    sql"""select `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
    from `promotions`
    where `promotion_id` = ${Fragment.encode(PromotionsId.pgType, promotionId)}""".query(PromotionsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(promotionIds: Array[PromotionsId])(using c: Connection): List[PromotionsRow] = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    promotionIds.foreach { id => fragments.addOne(Fragment.encode(PromotionsId.pgType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("select `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at` from `promotions` where `promotion_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).query(PromotionsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(promotionIds: Array[PromotionsId])(using c: Connection): Map[PromotionsId, PromotionsRow] = {
    val ret: scala.collection.mutable.Map[PromotionsId, PromotionsRow] = scala.collection.mutable.Map.empty[PromotionsId, PromotionsRow]
    selectByIds(promotionIds)(using c).foreach(row => ret.put(row.promotionId, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def selectByUniqueCode(code: String)(using c: Connection): Option[PromotionsRow] = {
    sql"""select `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`
    from `promotions`
    where `code` = ${Fragment.encode(MariaTypes.varchar, code)}
    """.query(PromotionsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def update: UpdateBuilder[PromotionsFields, PromotionsRow] = UpdateBuilder.of("`promotions`", PromotionsFields.structure, PromotionsRow.`_rowParser`, Dialect.MARIADB)

  override def update(row: PromotionsRow)(using c: Connection): Boolean = {
    val promotionId: PromotionsId = row.promotionId
    return sql"""update `promotions`
    set `code` = ${Fragment.encode(MariaTypes.varchar, row.code)},
    `name` = ${Fragment.encode(MariaTypes.varchar, row.name)},
    `description` = ${Fragment.encode(MariaTypes.text.nullable, row.description)},
    `discount_type` = ${Fragment.encode(MariaTypes.text, row.discountType)},
    `discount_value` = ${Fragment.encode(ScalaDbTypes.MariaTypes.numeric, row.discountValue)},
    `min_order_amount` = ${Fragment.encode(ScalaDbTypes.MariaTypes.numeric.nullable, row.minOrderAmount)},
    `max_uses` = ${Fragment.encode(ScalaDbTypes.MariaTypes.intUnsigned.nullable, row.maxUses)},
    `uses_count` = ${Fragment.encode(ScalaDbTypes.MariaTypes.intUnsigned, row.usesCount)},
    `max_uses_per_customer` = ${Fragment.encode(ScalaDbTypes.MariaTypes.tinyintUnsigned.nullable, row.maxUsesPerCustomer)},
    `applicable_to` = ${Fragment.encode(MariaTypes.set.nullable, row.applicableTo)},
    `rules_json` = ${Fragment.encode(MariaTypes.longtext.nullable, row.rulesJson)},
    `valid_from` = ${Fragment.encode(MariaTypes.datetime, row.validFrom)},
    `valid_to` = ${Fragment.encode(MariaTypes.datetime, row.validTo)},
    `is_active` = ${Fragment.encode(ScalaDbTypes.MariaTypes.bool, row.isActive)},
    `created_at` = ${Fragment.encode(MariaTypes.datetime, row.createdAt)}
    where `promotion_id` = ${Fragment.encode(PromotionsId.pgType, promotionId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: PromotionsRow)(using c: Connection): PromotionsRow = {
  sql"""INSERT INTO `promotions`(`code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`)
    VALUES (${Fragment.encode(MariaTypes.varchar, unsaved.code)}, ${Fragment.encode(MariaTypes.varchar, unsaved.name)}, ${Fragment.encode(MariaTypes.text.nullable, unsaved.description)}, ${Fragment.encode(MariaTypes.text, unsaved.discountType)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.numeric, unsaved.discountValue)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.numeric.nullable, unsaved.minOrderAmount)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.intUnsigned.nullable, unsaved.maxUses)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.intUnsigned, unsaved.usesCount)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.tinyintUnsigned.nullable, unsaved.maxUsesPerCustomer)}, ${Fragment.encode(MariaTypes.set.nullable, unsaved.applicableTo)}, ${Fragment.encode(MariaTypes.longtext.nullable, unsaved.rulesJson)}, ${Fragment.encode(MariaTypes.datetime, unsaved.validFrom)}, ${Fragment.encode(MariaTypes.datetime, unsaved.validTo)}, ${Fragment.encode(ScalaDbTypes.MariaTypes.bool, unsaved.isActive)}, ${Fragment.encode(MariaTypes.datetime, unsaved.createdAt)})
    ON DUPLICATE KEY UPDATE `code` = VALUES(`code`),
    `name` = VALUES(`name`),
    `description` = VALUES(`description`),
    `discount_type` = VALUES(`discount_type`),
    `discount_value` = VALUES(`discount_value`),
    `min_order_amount` = VALUES(`min_order_amount`),
    `max_uses` = VALUES(`max_uses`),
    `uses_count` = VALUES(`uses_count`),
    `max_uses_per_customer` = VALUES(`max_uses_per_customer`),
    `applicable_to` = VALUES(`applicable_to`),
    `rules_json` = VALUES(`rules_json`),
    `valid_from` = VALUES(`valid_from`),
    `valid_to` = VALUES(`valid_to`),
    `is_active` = VALUES(`is_active`),
    `created_at` = VALUES(`created_at`)
    RETURNING `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`"""
    .updateReturning(PromotionsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[PromotionsRow])(using c: Connection): List[PromotionsRow] = {
    sql"""INSERT INTO `promotions`(`promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON DUPLICATE KEY UPDATE `code` = VALUES(`code`),
    `name` = VALUES(`name`),
    `description` = VALUES(`description`),
    `discount_type` = VALUES(`discount_type`),
    `discount_value` = VALUES(`discount_value`),
    `min_order_amount` = VALUES(`min_order_amount`),
    `max_uses` = VALUES(`max_uses`),
    `uses_count` = VALUES(`uses_count`),
    `max_uses_per_customer` = VALUES(`max_uses_per_customer`),
    `applicable_to` = VALUES(`applicable_to`),
    `rules_json` = VALUES(`rules_json`),
    `valid_from` = VALUES(`valid_from`),
    `valid_to` = VALUES(`valid_to`),
    `is_active` = VALUES(`is_active`),
    `created_at` = VALUES(`created_at`)
    RETURNING `promotion_id`, `code`, `name`, `description`, `discount_type`, `discount_value`, `min_order_amount`, `max_uses`, `uses_count`, `max_uses_per_customer`, `applicable_to`, `rules_json`, `valid_from`, `valid_to`, `is_active`, `created_at`"""
      .updateReturningEach(PromotionsRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}