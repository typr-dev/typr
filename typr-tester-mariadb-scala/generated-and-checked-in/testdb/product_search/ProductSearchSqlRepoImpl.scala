/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.product_search

import java.sql.Connection
import typr.runtime.MariaTypes
import typr.scaladsl.Fragment
import typr.scaladsl.MariaTypeOps
import typr.scaladsl.ScalaDbTypes
import typr.scaladsl.Fragment.sql

class ProductSearchSqlRepoImpl extends ProductSearchSqlRepo {
  override def apply(
    brandId: Option[Int],
    minPrice: Option[BigDecimal],
    maxPrice: Option[BigDecimal],
    status: Option[String],
    limit: Long
  )(using c: Connection): List[ProductSearchSqlRow] = {
    sql"""-- Search products with optional filters
    SELECT p.product_id,
           p.sku,
           p.name,
           p.short_description,
           p.base_price,
           p.status,
           b.name AS brand_name
    FROM products p
    LEFT JOIN brands b ON p.brand_id = b.brand_id
    WHERE (${Fragment.encode(ScalaDbTypes.MariaTypes.smallintUnsigned.nullable, brandId)} IS NULL OR p.brand_id = ${Fragment.encode(ScalaDbTypes.MariaTypes.smallintUnsigned.nullable, brandId)})
      AND (${Fragment.encode(ScalaDbTypes.MariaTypes.numeric.nullable, minPrice)} IS NULL OR p.base_price >= ${Fragment.encode(ScalaDbTypes.MariaTypes.numeric.nullable, minPrice)})
      AND (${Fragment.encode(ScalaDbTypes.MariaTypes.numeric.nullable, maxPrice)} IS NULL OR p.base_price <= ${Fragment.encode(ScalaDbTypes.MariaTypes.numeric.nullable, maxPrice)})
      AND (${Fragment.encode(MariaTypes.text.nullable, status)} IS NULL OR p.status = ${Fragment.encode(MariaTypes.text.nullable, status)})
    ORDER BY p.name
    LIMIT ${Fragment.encode(ScalaDbTypes.MariaTypes.bigint, limit)}
    """.query(ProductSearchSqlRow.`_rowParser`.all()).runUnchecked(c)
  }
}