/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.all_scalar_types

import java.sql.Connection
import scala.collection.mutable.ListBuffer
import typr.runtime.SqlServerTypes
import typr.scaladsl.DeleteBuilder
import typr.scaladsl.Dialect
import typr.scaladsl.Fragment
import typr.scaladsl.ScalaDbTypes
import typr.scaladsl.SelectBuilder
import typr.scaladsl.SqlServerTypeOps
import typr.scaladsl.UpdateBuilder
import typr.scaladsl.Fragment.sql

class AllScalarTypesRepoImpl extends AllScalarTypesRepo {
  override def delete: DeleteBuilder[AllScalarTypesFields, AllScalarTypesRow] = DeleteBuilder.of("[all_scalar_types]", AllScalarTypesFields.structure, Dialect.SQLSERVER)

  override def deleteById(id: AllScalarTypesId)(using c: Connection): Boolean = sql"delete from [all_scalar_types] where [id] = ${Fragment.encode(AllScalarTypesId.sqlServerType, id)}".update().runUnchecked(c) > 0

  override def deleteByIds(ids: Array[AllScalarTypesId])(using c: Connection): Int = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    ids.foreach { id => fragments.addOne(Fragment.encode(AllScalarTypesId.sqlServerType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("delete from [all_scalar_types] where [id] in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override def insert(unsaved: AllScalarTypesRow)(using c: Connection): AllScalarTypesRow = {
  sql"""insert into [all_scalar_types]([col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null])
    OUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint], INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal], INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney], INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit], INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max], INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar], INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary], INSERTED.[col_varbinary], INSERTED.[col_varbinary_max], INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time], INSERTED.[col_datetime], INSERTED.[col_smalldatetime], INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset], INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json], INSERTED.[col_rowversion], INSERTED.[col_hierarchyid], INSERTED.[col_geography], INSERTED.[col_geometry], INSERTED.[col_not_null]
    values (${Fragment.encode(ScalaDbTypes.SqlServerTypes.tinyint.nullable, unsaved.colTinyint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallint.nullable, unsaved.colSmallint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.int_.nullable, unsaved.colInt)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.bigint.nullable, unsaved.colBigint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, unsaved.colDecimal)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, unsaved.colNumeric)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.money.nullable, unsaved.colMoney)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallmoney.nullable, unsaved.colSmallmoney)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.real.nullable, unsaved.colReal)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.float_.nullable, unsaved.colFloat)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.bit.nullable, unsaved.colBit)}, ${Fragment.encode(SqlServerTypes.char_.nullable, unsaved.colChar)}, ${Fragment.encode(SqlServerTypes.varchar.nullable, unsaved.colVarchar)}, ${Fragment.encode(SqlServerTypes.varchar.nullable, unsaved.colVarcharMax)}, ${Fragment.encode(SqlServerTypes.text.nullable, unsaved.colText)}, ${Fragment.encode(SqlServerTypes.nchar.nullable, unsaved.colNchar)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colNvarchar)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colNvarcharMax)}, ${Fragment.encode(SqlServerTypes.ntext.nullable, unsaved.colNtext)}, ${Fragment.encode(SqlServerTypes.binary.nullable, unsaved.colBinary)}, ${Fragment.encode(SqlServerTypes.varbinary.nullable, unsaved.colVarbinary)}, ${Fragment.encode(SqlServerTypes.varbinary.nullable, unsaved.colVarbinaryMax)}, ${Fragment.encode(SqlServerTypes.image.nullable, unsaved.colImage)}, ${Fragment.encode(SqlServerTypes.date.nullable, unsaved.colDate)}, ${Fragment.encode(SqlServerTypes.time.nullable, unsaved.colTime)}, ${Fragment.encode(SqlServerTypes.datetime.nullable, unsaved.colDatetime)}, ${Fragment.encode(SqlServerTypes.smalldatetime.nullable, unsaved.colSmalldatetime)}, ${Fragment.encode(SqlServerTypes.datetime2.nullable, unsaved.colDatetime2)}, ${Fragment.encode(SqlServerTypes.datetimeoffset.nullable, unsaved.colDatetimeoffset)}, ${Fragment.encode(SqlServerTypes.uniqueidentifier.nullable, unsaved.colUniqueidentifier)}, ${Fragment.encode(SqlServerTypes.xml.nullable, unsaved.colXml)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colJson)}, ${Fragment.encode(SqlServerTypes.hierarchyid.nullable, unsaved.colHierarchyid)}, ${Fragment.encode(SqlServerTypes.geography.nullable, unsaved.colGeography)}, ${Fragment.encode(SqlServerTypes.geometry.nullable, unsaved.colGeometry)}, ${Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull)})
    """
    .updateReturning(AllScalarTypesRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: AllScalarTypesRowUnsaved)(using c: Connection): AllScalarTypesRow = {
    val columns: ListBuffer[Fragment] = ListBuffer()
    val values: ListBuffer[Fragment] = ListBuffer()
    columns.addOne(Fragment.lit("[col_tinyint]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.tinyint.nullable, unsaved.colTinyint)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_smallint]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallint.nullable, unsaved.colSmallint)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_int]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.int_.nullable, unsaved.colInt)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_bigint]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.bigint.nullable, unsaved.colBigint)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_decimal]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, unsaved.colDecimal)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_numeric]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, unsaved.colNumeric)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_money]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.money.nullable, unsaved.colMoney)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_smallmoney]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallmoney.nullable, unsaved.colSmallmoney)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_real]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.real.nullable, unsaved.colReal)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_float]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.float_.nullable, unsaved.colFloat)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_bit]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.SqlServerTypes.bit.nullable, unsaved.colBit)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_char]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.char_.nullable, unsaved.colChar)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_varchar]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.varchar.nullable, unsaved.colVarchar)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_varchar_max]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.varchar.nullable, unsaved.colVarcharMax)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_text]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.text.nullable, unsaved.colText)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_nchar]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.nchar.nullable, unsaved.colNchar)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_nvarchar]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colNvarchar)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_nvarchar_max]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colNvarcharMax)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_ntext]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.ntext.nullable, unsaved.colNtext)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_binary]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.binary.nullable, unsaved.colBinary)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_varbinary]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.varbinary.nullable, unsaved.colVarbinary)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_varbinary_max]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.varbinary.nullable, unsaved.colVarbinaryMax)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_image]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.image.nullable, unsaved.colImage)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_date]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.date.nullable, unsaved.colDate)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_time]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.time.nullable, unsaved.colTime)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_datetime]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.datetime.nullable, unsaved.colDatetime)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_smalldatetime]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.smalldatetime.nullable, unsaved.colSmalldatetime)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_datetime2]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.datetime2.nullable, unsaved.colDatetime2)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_datetimeoffset]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.datetimeoffset.nullable, unsaved.colDatetimeoffset)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_uniqueidentifier]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.uniqueidentifier.nullable, unsaved.colUniqueidentifier)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_xml]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.xml.nullable, unsaved.colXml)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_json]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colJson)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_hierarchyid]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.hierarchyid.nullable, unsaved.colHierarchyid)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_geography]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.geography.nullable, unsaved.colGeography)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit("[col_geometry]")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(SqlServerTypes.geometry.nullable, unsaved.colGeometry)}"): @scala.annotation.nowarn
    unsaved.colNotNull.visit(
      {  },
      value => { columns.addOne(Fragment.lit("[col_not_null]")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(SqlServerTypes.nvarchar, value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      sql"""insert into [all_scalar_types](${Fragment.comma(columns)})
      OUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint], INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal], INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney], INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit], INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max], INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar], INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary], INSERTED.[col_varbinary], INSERTED.[col_varbinary_max], INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time], INSERTED.[col_datetime], INSERTED.[col_smalldatetime], INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset], INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json], INSERTED.[col_rowversion], INSERTED.[col_hierarchyid], INSERTED.[col_geography], INSERTED.[col_geometry], INSERTED.[col_not_null]
      values (${Fragment.comma(values)})
      """
    }
    return q.updateReturning(AllScalarTypesRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[AllScalarTypesFields, AllScalarTypesRow] = SelectBuilder.of("[all_scalar_types]", AllScalarTypesFields.structure, AllScalarTypesRow.`_rowParser`, Dialect.SQLSERVER)

  override def selectAll(using c: Connection): List[AllScalarTypesRow] = {
    sql"""select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]
    from [all_scalar_types]
    """.query(AllScalarTypesRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(id: AllScalarTypesId)(using c: Connection): Option[AllScalarTypesRow] = {
    sql"""select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]
    from [all_scalar_types]
    where [id] = ${Fragment.encode(AllScalarTypesId.sqlServerType, id)}""".query(AllScalarTypesRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(ids: Array[AllScalarTypesId])(using c: Connection): List[AllScalarTypesRow] = {
    val fragments: ListBuffer[Fragment] = ListBuffer()
    ids.foreach { id => fragments.addOne(Fragment.encode(AllScalarTypesId.sqlServerType, id)): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null] from [all_scalar_types] where [id] in ("), Fragment.comma(fragments), Fragment.lit(")")).query(AllScalarTypesRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(ids: Array[AllScalarTypesId])(using c: Connection): Map[AllScalarTypesId, AllScalarTypesRow] = {
    val ret: scala.collection.mutable.Map[AllScalarTypesId, AllScalarTypesRow] = scala.collection.mutable.Map.empty[AllScalarTypesId, AllScalarTypesRow]
    selectByIds(ids)(using c).foreach(row => ret.put(row.id, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def update: UpdateBuilder[AllScalarTypesFields, AllScalarTypesRow] = UpdateBuilder.of("[all_scalar_types]", AllScalarTypesFields.structure, AllScalarTypesRow.`_rowParser`, Dialect.SQLSERVER)

  override def update(row: AllScalarTypesRow)(using c: Connection): Boolean = {
    val id: AllScalarTypesId = row.id
    return sql"""update [all_scalar_types]
    set [col_tinyint] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.tinyint.nullable, row.colTinyint)},
    [col_smallint] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallint.nullable, row.colSmallint)},
    [col_int] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.int_.nullable, row.colInt)},
    [col_bigint] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.bigint.nullable, row.colBigint)},
    [col_decimal] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, row.colDecimal)},
    [col_numeric] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, row.colNumeric)},
    [col_money] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.money.nullable, row.colMoney)},
    [col_smallmoney] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallmoney.nullable, row.colSmallmoney)},
    [col_real] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.real.nullable, row.colReal)},
    [col_float] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.float_.nullable, row.colFloat)},
    [col_bit] = ${Fragment.encode(ScalaDbTypes.SqlServerTypes.bit.nullable, row.colBit)},
    [col_char] = ${Fragment.encode(SqlServerTypes.char_.nullable, row.colChar)},
    [col_varchar] = ${Fragment.encode(SqlServerTypes.varchar.nullable, row.colVarchar)},
    [col_varchar_max] = ${Fragment.encode(SqlServerTypes.varchar.nullable, row.colVarcharMax)},
    [col_text] = ${Fragment.encode(SqlServerTypes.text.nullable, row.colText)},
    [col_nchar] = ${Fragment.encode(SqlServerTypes.nchar.nullable, row.colNchar)},
    [col_nvarchar] = ${Fragment.encode(SqlServerTypes.nvarchar.nullable, row.colNvarchar)},
    [col_nvarchar_max] = ${Fragment.encode(SqlServerTypes.nvarchar.nullable, row.colNvarcharMax)},
    [col_ntext] = ${Fragment.encode(SqlServerTypes.ntext.nullable, row.colNtext)},
    [col_binary] = ${Fragment.encode(SqlServerTypes.binary.nullable, row.colBinary)},
    [col_varbinary] = ${Fragment.encode(SqlServerTypes.varbinary.nullable, row.colVarbinary)},
    [col_varbinary_max] = ${Fragment.encode(SqlServerTypes.varbinary.nullable, row.colVarbinaryMax)},
    [col_image] = ${Fragment.encode(SqlServerTypes.image.nullable, row.colImage)},
    [col_date] = ${Fragment.encode(SqlServerTypes.date.nullable, row.colDate)},
    [col_time] = ${Fragment.encode(SqlServerTypes.time.nullable, row.colTime)},
    [col_datetime] = ${Fragment.encode(SqlServerTypes.datetime.nullable, row.colDatetime)},
    [col_smalldatetime] = ${Fragment.encode(SqlServerTypes.smalldatetime.nullable, row.colSmalldatetime)},
    [col_datetime2] = ${Fragment.encode(SqlServerTypes.datetime2.nullable, row.colDatetime2)},
    [col_datetimeoffset] = ${Fragment.encode(SqlServerTypes.datetimeoffset.nullable, row.colDatetimeoffset)},
    [col_uniqueidentifier] = ${Fragment.encode(SqlServerTypes.uniqueidentifier.nullable, row.colUniqueidentifier)},
    [col_xml] = ${Fragment.encode(SqlServerTypes.xml.nullable, row.colXml)},
    [col_json] = ${Fragment.encode(SqlServerTypes.nvarchar.nullable, row.colJson)},
    [col_hierarchyid] = ${Fragment.encode(SqlServerTypes.hierarchyid.nullable, row.colHierarchyid)},
    [col_geography] = ${Fragment.encode(SqlServerTypes.geography.nullable, row.colGeography)},
    [col_geometry] = ${Fragment.encode(SqlServerTypes.geometry.nullable, row.colGeometry)},
    [col_not_null] = ${Fragment.encode(SqlServerTypes.nvarchar, row.colNotNull)}
    where [id] = ${Fragment.encode(AllScalarTypesId.sqlServerType, id)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: AllScalarTypesRow)(using c: Connection): AllScalarTypesRow = {
  sql"""MERGE INTO [all_scalar_types] AS target
    USING (VALUES (${Fragment.encode(ScalaDbTypes.SqlServerTypes.tinyint.nullable, unsaved.colTinyint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallint.nullable, unsaved.colSmallint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.int_.nullable, unsaved.colInt)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.bigint.nullable, unsaved.colBigint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, unsaved.colDecimal)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, unsaved.colNumeric)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.money.nullable, unsaved.colMoney)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallmoney.nullable, unsaved.colSmallmoney)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.real.nullable, unsaved.colReal)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.float_.nullable, unsaved.colFloat)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.bit.nullable, unsaved.colBit)}, ${Fragment.encode(SqlServerTypes.char_.nullable, unsaved.colChar)}, ${Fragment.encode(SqlServerTypes.varchar.nullable, unsaved.colVarchar)}, ${Fragment.encode(SqlServerTypes.varchar.nullable, unsaved.colVarcharMax)}, ${Fragment.encode(SqlServerTypes.text.nullable, unsaved.colText)}, ${Fragment.encode(SqlServerTypes.nchar.nullable, unsaved.colNchar)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colNvarchar)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colNvarcharMax)}, ${Fragment.encode(SqlServerTypes.ntext.nullable, unsaved.colNtext)}, ${Fragment.encode(SqlServerTypes.binary.nullable, unsaved.colBinary)}, ${Fragment.encode(SqlServerTypes.varbinary.nullable, unsaved.colVarbinary)}, ${Fragment.encode(SqlServerTypes.varbinary.nullable, unsaved.colVarbinaryMax)}, ${Fragment.encode(SqlServerTypes.image.nullable, unsaved.colImage)}, ${Fragment.encode(SqlServerTypes.date.nullable, unsaved.colDate)}, ${Fragment.encode(SqlServerTypes.time.nullable, unsaved.colTime)}, ${Fragment.encode(SqlServerTypes.datetime.nullable, unsaved.colDatetime)}, ${Fragment.encode(SqlServerTypes.smalldatetime.nullable, unsaved.colSmalldatetime)}, ${Fragment.encode(SqlServerTypes.datetime2.nullable, unsaved.colDatetime2)}, ${Fragment.encode(SqlServerTypes.datetimeoffset.nullable, unsaved.colDatetimeoffset)}, ${Fragment.encode(SqlServerTypes.uniqueidentifier.nullable, unsaved.colUniqueidentifier)}, ${Fragment.encode(SqlServerTypes.xml.nullable, unsaved.colXml)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colJson)}, ${Fragment.encode(SqlServerTypes.hierarchyid.nullable, unsaved.colHierarchyid)}, ${Fragment.encode(SqlServerTypes.geography.nullable, unsaved.colGeography)}, ${Fragment.encode(SqlServerTypes.geometry.nullable, unsaved.colGeometry)}, ${Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull)})) AS source([col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null])
    ON target.[id] = source.[id]
    WHEN MATCHED THEN UPDATE SET [col_tinyint] = source.[col_tinyint],
    [col_smallint] = source.[col_smallint],
    [col_int] = source.[col_int],
    [col_bigint] = source.[col_bigint],
    [col_decimal] = source.[col_decimal],
    [col_numeric] = source.[col_numeric],
    [col_money] = source.[col_money],
    [col_smallmoney] = source.[col_smallmoney],
    [col_real] = source.[col_real],
    [col_float] = source.[col_float],
    [col_bit] = source.[col_bit],
    [col_char] = source.[col_char],
    [col_varchar] = source.[col_varchar],
    [col_varchar_max] = source.[col_varchar_max],
    [col_text] = source.[col_text],
    [col_nchar] = source.[col_nchar],
    [col_nvarchar] = source.[col_nvarchar],
    [col_nvarchar_max] = source.[col_nvarchar_max],
    [col_ntext] = source.[col_ntext],
    [col_binary] = source.[col_binary],
    [col_varbinary] = source.[col_varbinary],
    [col_varbinary_max] = source.[col_varbinary_max],
    [col_image] = source.[col_image],
    [col_date] = source.[col_date],
    [col_time] = source.[col_time],
    [col_datetime] = source.[col_datetime],
    [col_smalldatetime] = source.[col_smalldatetime],
    [col_datetime2] = source.[col_datetime2],
    [col_datetimeoffset] = source.[col_datetimeoffset],
    [col_uniqueidentifier] = source.[col_uniqueidentifier],
    [col_xml] = source.[col_xml],
    [col_json] = source.[col_json],
    [col_hierarchyid] = source.[col_hierarchyid],
    [col_geography] = source.[col_geography],
    [col_geometry] = source.[col_geometry],
    [col_not_null] = source.[col_not_null]
    WHEN NOT MATCHED THEN INSERT ([col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]) VALUES (${Fragment.encode(ScalaDbTypes.SqlServerTypes.tinyint.nullable, unsaved.colTinyint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallint.nullable, unsaved.colSmallint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.int_.nullable, unsaved.colInt)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.bigint.nullable, unsaved.colBigint)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, unsaved.colDecimal)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.decimal.nullable, unsaved.colNumeric)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.money.nullable, unsaved.colMoney)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.smallmoney.nullable, unsaved.colSmallmoney)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.real.nullable, unsaved.colReal)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.float_.nullable, unsaved.colFloat)}, ${Fragment.encode(ScalaDbTypes.SqlServerTypes.bit.nullable, unsaved.colBit)}, ${Fragment.encode(SqlServerTypes.char_.nullable, unsaved.colChar)}, ${Fragment.encode(SqlServerTypes.varchar.nullable, unsaved.colVarchar)}, ${Fragment.encode(SqlServerTypes.varchar.nullable, unsaved.colVarcharMax)}, ${Fragment.encode(SqlServerTypes.text.nullable, unsaved.colText)}, ${Fragment.encode(SqlServerTypes.nchar.nullable, unsaved.colNchar)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colNvarchar)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colNvarcharMax)}, ${Fragment.encode(SqlServerTypes.ntext.nullable, unsaved.colNtext)}, ${Fragment.encode(SqlServerTypes.binary.nullable, unsaved.colBinary)}, ${Fragment.encode(SqlServerTypes.varbinary.nullable, unsaved.colVarbinary)}, ${Fragment.encode(SqlServerTypes.varbinary.nullable, unsaved.colVarbinaryMax)}, ${Fragment.encode(SqlServerTypes.image.nullable, unsaved.colImage)}, ${Fragment.encode(SqlServerTypes.date.nullable, unsaved.colDate)}, ${Fragment.encode(SqlServerTypes.time.nullable, unsaved.colTime)}, ${Fragment.encode(SqlServerTypes.datetime.nullable, unsaved.colDatetime)}, ${Fragment.encode(SqlServerTypes.smalldatetime.nullable, unsaved.colSmalldatetime)}, ${Fragment.encode(SqlServerTypes.datetime2.nullable, unsaved.colDatetime2)}, ${Fragment.encode(SqlServerTypes.datetimeoffset.nullable, unsaved.colDatetimeoffset)}, ${Fragment.encode(SqlServerTypes.uniqueidentifier.nullable, unsaved.colUniqueidentifier)}, ${Fragment.encode(SqlServerTypes.xml.nullable, unsaved.colXml)}, ${Fragment.encode(SqlServerTypes.nvarchar.nullable, unsaved.colJson)}, ${Fragment.encode(SqlServerTypes.hierarchyid.nullable, unsaved.colHierarchyid)}, ${Fragment.encode(SqlServerTypes.geography.nullable, unsaved.colGeography)}, ${Fragment.encode(SqlServerTypes.geometry.nullable, unsaved.colGeometry)}, ${Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull)})
    OUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint], INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal], INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney], INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit], INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max], INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar], INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary], INSERTED.[col_varbinary], INSERTED.[col_varbinary_max], INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time], INSERTED.[col_datetime], INSERTED.[col_smalldatetime], INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset], INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json], INSERTED.[col_rowversion], INSERTED.[col_hierarchyid], INSERTED.[col_geography], INSERTED.[col_geometry], INSERTED.[col_not_null];"""
    .updateReturning(AllScalarTypesRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[AllScalarTypesRow])(using c: Connection): List[AllScalarTypesRow] = {
    sql"""MERGE INTO [all_scalar_types] AS target
    USING (VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)) AS source([id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null])
    ON target.[id] = source.[id]
    WHEN MATCHED THEN UPDATE SET [col_tinyint] = source.[col_tinyint],
    [col_smallint] = source.[col_smallint],
    [col_int] = source.[col_int],
    [col_bigint] = source.[col_bigint],
    [col_decimal] = source.[col_decimal],
    [col_numeric] = source.[col_numeric],
    [col_money] = source.[col_money],
    [col_smallmoney] = source.[col_smallmoney],
    [col_real] = source.[col_real],
    [col_float] = source.[col_float],
    [col_bit] = source.[col_bit],
    [col_char] = source.[col_char],
    [col_varchar] = source.[col_varchar],
    [col_varchar_max] = source.[col_varchar_max],
    [col_text] = source.[col_text],
    [col_nchar] = source.[col_nchar],
    [col_nvarchar] = source.[col_nvarchar],
    [col_nvarchar_max] = source.[col_nvarchar_max],
    [col_ntext] = source.[col_ntext],
    [col_binary] = source.[col_binary],
    [col_varbinary] = source.[col_varbinary],
    [col_varbinary_max] = source.[col_varbinary_max],
    [col_image] = source.[col_image],
    [col_date] = source.[col_date],
    [col_time] = source.[col_time],
    [col_datetime] = source.[col_datetime],
    [col_smalldatetime] = source.[col_smalldatetime],
    [col_datetime2] = source.[col_datetime2],
    [col_datetimeoffset] = source.[col_datetimeoffset],
    [col_uniqueidentifier] = source.[col_uniqueidentifier],
    [col_xml] = source.[col_xml],
    [col_json] = source.[col_json],
    [col_rowversion] = source.[col_rowversion],
    [col_hierarchyid] = source.[col_hierarchyid],
    [col_geography] = source.[col_geography],
    [col_geometry] = source.[col_geometry],
    [col_not_null] = source.[col_not_null]
    WHEN NOT MATCHED THEN INSERT ([id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    OUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint], INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal], INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney], INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit], INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max], INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar], INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary], INSERTED.[col_varbinary], INSERTED.[col_varbinary_max], INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time], INSERTED.[col_datetime], INSERTED.[col_smalldatetime], INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset], INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json], INSERTED.[col_rowversion], INSERTED.[col_hierarchyid], INSERTED.[col_geography], INSERTED.[col_geometry], INSERTED.[col_not_null];"""
      .updateReturningEach(AllScalarTypesRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}