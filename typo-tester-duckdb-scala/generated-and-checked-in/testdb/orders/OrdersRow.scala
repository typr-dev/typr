/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.orders

import com.fasterxml.jackson.annotation.JsonProperty
import java.time.LocalDate
import testdb.customtypes.Defaulted
import typo.runtime.DuckDbText
import typo.runtime.DuckDbTypes
import typo.scaladsl.DuckDbTypeOps
import typo.scaladsl.RowParser
import typo.scaladsl.RowParsers
import typo.scaladsl.ScalaDbTypes

/** Table: orders
 * Primary key: order_id
 */
case class OrdersRow(
  @JsonProperty("order_id") orderId: OrdersId,
  @JsonProperty("customer_id") customerId: Int,
  /** Default: current_date */
  @JsonProperty("order_date") orderDate: LocalDate,
  @JsonProperty("total_amount") totalAmount: Option[BigDecimal],
  /** Default: 'pending' */
  status: Option[String]
) {
  def id: OrdersId = orderId

  def toUnsavedRow(
    orderDate: Defaulted[LocalDate] = Defaulted.Provided(this.orderDate),
    status: Defaulted[Option[String]] = Defaulted.Provided(this.status)
  ): OrdersRowUnsaved = {
    new OrdersRowUnsaved(
      orderId,
      customerId,
      totalAmount,
      orderDate,
      status
    )
  }
}

object OrdersRow {
  val `_rowParser`: RowParser[OrdersRow] = {
    RowParsers.of(OrdersId.duckDbType, ScalaDbTypes.DuckDbTypes.integer, DuckDbTypes.date, ScalaDbTypes.DuckDbTypes.numeric.nullable, DuckDbTypes.varchar.nullable)((t0, t1, t2, t3, t4) => new OrdersRow(
      t0,
      t1,
      t2,
      t3,
      t4
    ))(row => Array[Any](row.orderId, row.customerId, row.orderDate, row.totalAmount, row.status))
  }

  given duckDbText: DuckDbText[OrdersRow] = DuckDbText.from(`_rowParser`.underlying)
}