/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.order_items

import java.sql.Connection
import scala.collection.mutable.ListBuffer
import typo.scaladsl.DeleteBuilder
import typo.scaladsl.Dialect
import typo.scaladsl.Fragment
import typo.scaladsl.ScalaDbTypes
import typo.scaladsl.SelectBuilder
import typo.scaladsl.UpdateBuilder
import typo.scaladsl.Fragment.sql

class OrderItemsRepoImpl extends OrderItemsRepo {
  override def delete: DeleteBuilder[OrderItemsFields, OrderItemsRow] = DeleteBuilder.of(""""order_items"""", OrderItemsFields.structure, Dialect.DUCKDB)

  override def deleteById(compositeId: OrderItemsId)(using c: Connection): Boolean = sql"""delete from "order_items" where "order_id" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, compositeId.orderId)} AND "product_id" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, compositeId.productId)}""".update().runUnchecked(c) > 0

  override def deleteByIds(compositeIds: Array[OrderItemsId])(using c: Connection): Int = {
    val orClauses: ListBuffer[Fragment] = ListBuffer()
    compositeIds.foreach { id => orClauses.addOne(Fragment.interpolate(Fragment.lit("("), Fragment.lit(""""order_id" = """), Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, id.orderId), Fragment.lit(" AND "), Fragment.lit(""""product_id" = """), Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, id.productId), Fragment.lit(")"))): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""delete
    from "order_items"
    where """), Fragment.or(orClauses.toList), Fragment.lit("""
    """)).update().runUnchecked(c)
  }

  override def insert(unsaved: OrderItemsRow)(using c: Connection): OrderItemsRow = {
  sql"""insert into "order_items"("order_id", "product_id", "quantity", "unit_price")
    values (${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, unsaved.orderId)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, unsaved.productId)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, unsaved.quantity)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric, unsaved.unitPrice)})
    RETURNING "order_id", "product_id", "quantity", "unit_price"
    """
    .updateReturning(OrderItemsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: OrderItemsRowUnsaved)(using c: Connection): OrderItemsRow = {
    val columns: ListBuffer[Fragment] = ListBuffer()
    val values: ListBuffer[Fragment] = ListBuffer()
    columns.addOne(Fragment.lit(""""order_id"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, unsaved.orderId)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""product_id"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, unsaved.productId)}"): @scala.annotation.nowarn
    columns.addOne(Fragment.lit(""""unit_price"""")): @scala.annotation.nowarn
    values.addOne(sql"${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric, unsaved.unitPrice)}"): @scala.annotation.nowarn
    unsaved.quantity.visit(
      {  },
      value => { columns.addOne(Fragment.lit(""""quantity"""")): @scala.annotation.nowarn; values.addOne(sql"${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, value)}"): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      sql"""insert into "order_items"(${Fragment.comma(columns)})
      values (${Fragment.comma(values)})
      RETURNING "order_id", "product_id", "quantity", "unit_price"
      """
    }
    return q.updateReturning(OrderItemsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[OrderItemsFields, OrderItemsRow] = SelectBuilder.of(""""order_items"""", OrderItemsFields.structure, OrderItemsRow.`_rowParser`, Dialect.DUCKDB)

  override def selectAll(using c: Connection): List[OrderItemsRow] = {
    sql"""select "order_id", "product_id", "quantity", "unit_price"
    from "order_items"
    """.query(OrderItemsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(compositeId: OrderItemsId)(using c: Connection): Option[OrderItemsRow] = {
    sql"""select "order_id", "product_id", "quantity", "unit_price"
    from "order_items"
    where "order_id" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, compositeId.orderId)} AND "product_id" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, compositeId.productId)}""".query(OrderItemsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(compositeIds: Array[OrderItemsId])(using c: Connection): List[OrderItemsRow] = {
    val orClauses: ListBuffer[Fragment] = ListBuffer()
    compositeIds.foreach { id => orClauses.addOne(Fragment.interpolate(Fragment.lit("("), Fragment.lit(""""order_id" = """), Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, id.orderId), Fragment.lit(" AND "), Fragment.lit(""""product_id" = """), Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, id.productId), Fragment.lit(")"))): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""select "order_id", "product_id", "quantity", "unit_price"
    from "order_items"
    where """), Fragment.or(orClauses.toList), Fragment.lit("""
    """)).query(OrderItemsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(compositeIds: Array[OrderItemsId])(using c: Connection): Map[OrderItemsId, OrderItemsRow] = {
    val ret: scala.collection.mutable.Map[OrderItemsId, OrderItemsRow] = scala.collection.mutable.Map.empty[OrderItemsId, OrderItemsRow]
    selectByIds(compositeIds)(using c).foreach(row => ret.put(row.compositeId, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def update: UpdateBuilder[OrderItemsFields, OrderItemsRow] = UpdateBuilder.of(""""order_items"""", OrderItemsFields.structure, OrderItemsRow.`_rowParser`, Dialect.DUCKDB)

  override def update(row: OrderItemsRow)(using c: Connection): Boolean = {
    val compositeId: OrderItemsId = row.compositeId
    return sql"""update "order_items"
    set "quantity" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, row.quantity)},
    "unit_price" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric, row.unitPrice)}
    where "order_id" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, compositeId.orderId)} AND "product_id" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, compositeId.productId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: OrderItemsRow)(using c: Connection): OrderItemsRow = {
  sql"""INSERT INTO "order_items"("order_id", "product_id", "quantity", "unit_price")
    VALUES (${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, unsaved.orderId)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, unsaved.productId)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer, unsaved.quantity)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric, unsaved.unitPrice)})
    ON CONFLICT ("order_id", "product_id")
    DO UPDATE SET
      "quantity" = EXCLUDED."quantity",
    "unit_price" = EXCLUDED."unit_price"
    RETURNING "order_id", "product_id", "quantity", "unit_price""""
    .updateReturning(OrderItemsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[OrderItemsRow])(using c: Connection): List[OrderItemsRow] = {
    sql"""INSERT INTO "order_items"("order_id", "product_id", "quantity", "unit_price")
    VALUES (?, ?, ?, ?)
    ON CONFLICT ("order_id", "product_id")
    DO UPDATE SET
      "quantity" = EXCLUDED."quantity",
    "unit_price" = EXCLUDED."unit_price"
    RETURNING "order_id", "product_id", "quantity", "unit_price""""
      .updateReturningEach(OrderItemsRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}