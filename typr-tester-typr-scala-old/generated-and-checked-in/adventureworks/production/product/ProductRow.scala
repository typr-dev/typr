/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.product

import adventureworks.customtypes.Defaulted
import adventureworks.production.productmodel.ProductmodelId
import adventureworks.production.productsubcategory.ProductsubcategoryId
import adventureworks.production.unitmeasure.UnitmeasureId
import adventureworks.public.Flag
import adventureworks.public.Name
import java.time.LocalDateTime
import java.util.Optional
import java.util.UUID
import typr.runtime.PgText
import typr.runtime.PgTypes
import typr.runtime.RowParser
import typr.runtime.RowParsers
import typr.runtime.RowParsers.Function25

/** Table: production.product
 * Products sold or used in the manfacturing of sold products.
 * Primary key: productid
 */
case class ProductRow(
  /** Primary key for Product records.
   * Default: nextval('production.product_productid_seq'::regclass)
   */
  productid: ProductId,
  /** Name of the product. */
  name: Name,
  /** Unique product identification number. */
  productnumber: String,
  /** 0 = Product is purchased, 1 = Product is manufactured in-house.
   * Default: true
   */
  makeflag: Flag,
  /** 0 = Product is not a salable item. 1 = Product is salable.
   * Default: true
   */
  finishedgoodsflag: Flag,
  /** Product color. */
  color: Optional[/* max 15 chars */ String],
  /** Minimum inventory quantity.
   * Constraint CK_Product_SafetyStockLevel affecting columns safetystocklevel: ((safetystocklevel > 0))
   */
  safetystocklevel: java.lang.Short,
  /** Inventory level that triggers a purchase order or work order.
   * Constraint CK_Product_ReorderPoint affecting columns reorderpoint: ((reorderpoint > 0))
   */
  reorderpoint: java.lang.Short,
  /** Standard cost of the product.
   * Constraint CK_Product_StandardCost affecting columns standardcost: ((standardcost >= 0.00))
   */
  standardcost: java.math.BigDecimal,
  /** Selling price.
   * Constraint CK_Product_ListPrice affecting columns listprice: ((listprice >= 0.00))
   */
  listprice: java.math.BigDecimal,
  /** Product size. */
  size: Optional[/* max 5 chars */ String],
  /** Unit of measure for Size column.
   * Points to [[adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]]
   */
  sizeunitmeasurecode: Optional[UnitmeasureId],
  /** Unit of measure for Weight column.
   * Points to [[adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]]
   */
  weightunitmeasurecode: Optional[UnitmeasureId],
  /** Product weight.
   * Constraint CK_Product_Weight affecting columns weight: ((weight > 0.00))
   */
  weight: Optional[java.math.BigDecimal],
  /** Number of days required to manufacture the product.
   * Constraint CK_Product_DaysToManufacture affecting columns daystomanufacture: ((daystomanufacture >= 0))
   */
  daystomanufacture: Integer,
  /** R = Road, M = Mountain, T = Touring, S = Standard
   * Constraint CK_Product_ProductLine affecting columns productline: (((upper((productline)::text) = ANY (ARRAY['S'::text, 'T'::text, 'M'::text, 'R'::text])) OR (productline IS NULL)))
   */
  productline: Optional[/* bpchar, max 2 chars */ String],
  /** H = High, M = Medium, L = Low
   * Constraint CK_Product_Class affecting columns class: (((upper((class)::text) = ANY (ARRAY['L'::text, 'M'::text, 'H'::text])) OR (class IS NULL)))
   */
  `class`: Optional[/* bpchar, max 2 chars */ String],
  /** W = Womens, M = Mens, U = Universal
   * Constraint CK_Product_Style affecting columns style: (((upper((style)::text) = ANY (ARRAY['W'::text, 'M'::text, 'U'::text])) OR (style IS NULL)))
   */
  style: Optional[/* bpchar, max 2 chars */ String],
  /** Product is a member of this product subcategory. Foreign key to ProductSubCategory.ProductSubCategoryID.
   * Points to [[adventureworks.production.productsubcategory.ProductsubcategoryRow.productsubcategoryid]]
   */
  productsubcategoryid: Optional[ProductsubcategoryId],
  /** Product is a member of this product model. Foreign key to ProductModel.ProductModelID.
   * Points to [[adventureworks.production.productmodel.ProductmodelRow.productmodelid]]
   */
  productmodelid: Optional[ProductmodelId],
  /** Date the product was available for sale.
   * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate: (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
   */
  sellstartdate: LocalDateTime,
  /** Date the product was no longer available for sale.
   * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate: (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
   */
  sellenddate: Optional[LocalDateTime],
  /** Date the product was discontinued. */
  discontinueddate: Optional[LocalDateTime],
  /** Default: uuid_generate_v1() */
  rowguid: UUID,
  /** Default: now() */
  modifieddate: LocalDateTime
) {
  def id: ProductId = productid

  def toUnsavedRow(
    productid: Defaulted[ProductId],
    makeflag: Defaulted[Flag] = Defaulted.Provided(this.makeflag),
    finishedgoodsflag: Defaulted[Flag] = Defaulted.Provided(this.finishedgoodsflag),
    rowguid: Defaulted[UUID] = Defaulted.Provided(this.rowguid),
    modifieddate: Defaulted[LocalDateTime] = Defaulted.Provided(this.modifieddate)
  ): ProductRowUnsaved = {
    new ProductRowUnsaved(
      name,
      productnumber,
      color,
      safetystocklevel,
      reorderpoint,
      standardcost,
      listprice,
      size,
      sizeunitmeasurecode,
      weightunitmeasurecode,
      weight,
      daystomanufacture,
      productline,
      `class`,
      style,
      productsubcategoryid,
      productmodelid,
      sellstartdate,
      sellenddate,
      discontinueddate,
      productid,
      makeflag,
      finishedgoodsflag,
      rowguid,
      modifieddate
    )
  }
}

object ProductRow {
  val `_rowParser`: RowParser[ProductRow] = {
    RowParsers.of(ProductId.pgType, Name.pgType, PgTypes.text, Flag.pgType, Flag.pgType, PgTypes.text.opt(), PgTypes.int2, PgTypes.int2, PgTypes.numeric, PgTypes.numeric, PgTypes.text.opt(), UnitmeasureId.pgType.opt(), UnitmeasureId.pgType.opt(), PgTypes.numeric.opt(), PgTypes.int4, PgTypes.bpchar.opt(), PgTypes.bpchar.opt(), PgTypes.bpchar.opt(), ProductsubcategoryId.pgType.opt(), ProductmodelId.pgType.opt(), PgTypes.timestamp, PgTypes.timestamp.opt(), PgTypes.timestamp.opt(), PgTypes.uuid, PgTypes.timestamp, new Function25[ProductId, Name, String, Flag, Flag, Optional[/* max 15 chars */ String], java.lang.Short, java.lang.Short, java.math.BigDecimal, java.math.BigDecimal, Optional[/* max 5 chars */ String], Optional[UnitmeasureId], Optional[UnitmeasureId], Optional[java.math.BigDecimal], Integer, Optional[/* bpchar, max 2 chars */ String], Optional[/* bpchar, max 2 chars */ String], Optional[/* bpchar, max 2 chars */ String], Optional[ProductsubcategoryId], Optional[ProductmodelId], LocalDateTime, Optional[LocalDateTime], Optional[LocalDateTime], UUID, LocalDateTime, ProductRow] {
      override def apply(
        t0: ProductId,
        t1: Name,
        t2: String,
        t3: Flag,
        t4: Flag,
        t5: Optional[/* max 15 chars */ String],
        t6: java.lang.Short,
        t7: java.lang.Short,
        t8: java.math.BigDecimal,
        t9: java.math.BigDecimal,
        t10: Optional[/* max 5 chars */ String],
        t11: Optional[UnitmeasureId],
        t12: Optional[UnitmeasureId],
        t13: Optional[java.math.BigDecimal],
        t14: Integer,
        t15: Optional[/* bpchar, max 2 chars */ String],
        t16: Optional[/* bpchar, max 2 chars */ String],
        t17: Optional[/* bpchar, max 2 chars */ String],
        t18: Optional[ProductsubcategoryId],
        t19: Optional[ProductmodelId],
        t20: LocalDateTime,
        t21: Optional[LocalDateTime],
        t22: Optional[LocalDateTime],
        t23: UUID,
        t24: LocalDateTime
      ): ProductRow = {
        new ProductRow(
          t0,
          t1,
          t2,
          t3,
          t4,
          t5,
          t6,
          t7,
          t8,
          t9,
          t10,
          t11,
          t12,
          t13,
          t14,
          t15,
          t16,
          t17,
          t18,
          t19,
          t20,
          t21,
          t22,
          t23,
          t24
        )
      }
    }, row => Array[Any](row.productid, row.name, row.productnumber, row.makeflag, row.finishedgoodsflag, row.color, row.safetystocklevel, row.reorderpoint, row.standardcost, row.listprice, row.size, row.sizeunitmeasurecode, row.weightunitmeasurecode, row.weight, row.daystomanufacture, row.productline, row.`class`, row.style, row.productsubcategoryid, row.productmodelid, row.sellstartdate, row.sellenddate, row.discontinueddate, row.rowguid, row.modifieddate))
  }

  given pgText: PgText[ProductRow] = PgText.from(`_rowParser`)
}