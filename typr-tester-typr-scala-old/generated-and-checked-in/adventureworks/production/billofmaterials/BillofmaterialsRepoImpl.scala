/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.billofmaterials

import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.sql.Connection
import java.util.ArrayList
import java.util.HashMap
import java.util.Optional
import typr.dsl.DeleteBuilder
import typr.dsl.Dialect
import typr.dsl.SelectBuilder
import typr.dsl.UpdateBuilder
import typr.runtime.Fragment
import typr.runtime.PgTypes
import typr.runtime.streamingInsert
import typr.runtime.Fragment.interpolate

class BillofmaterialsRepoImpl extends BillofmaterialsRepo {
  override def delete: DeleteBuilder[BillofmaterialsFields, BillofmaterialsRow] = DeleteBuilder.of(""""production"."billofmaterials"""", BillofmaterialsFields.structure, Dialect.POSTGRESQL)

  override def deleteById(billofmaterialsid: Integer)(using c: Connection): java.lang.Boolean = interpolate(Fragment.lit("""delete from "production"."billofmaterials" where "billofmaterialsid" = """), Fragment.encode(PgTypes.int4, billofmaterialsid), Fragment.lit("")).update().runUnchecked(c) > 0

  override def deleteByIds(billofmaterialsids: Array[Integer])(using c: Connection): Integer = {
    interpolate(Fragment.lit("""delete
    from "production"."billofmaterials"
    where "billofmaterialsid" = ANY("""), Fragment.encode(PgTypes.int4Array, billofmaterialsids), Fragment.lit(")"))
      .update()
      .runUnchecked(c)
  }

  override def insert(unsaved: BillofmaterialsRow)(using c: Connection): BillofmaterialsRow = {
  interpolate(Fragment.lit("""insert into "production"."billofmaterials"("billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate")
    values ("""), Fragment.encode(PgTypes.int4, unsaved.billofmaterialsid), Fragment.lit("::int4, "), Fragment.encode(ProductId.pgType.opt(), unsaved.productassemblyid), Fragment.lit("::int4, "), Fragment.encode(ProductId.pgType, unsaved.componentid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.timestamp, unsaved.startdate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.timestamp.opt(), unsaved.enddate), Fragment.lit("::timestamp, "), Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar, "), Fragment.encode(PgTypes.int2, unsaved.bomlevel), Fragment.lit("::int2, "), Fragment.encode(PgTypes.numeric, unsaved.perassemblyqty), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("""::timestamp)
    RETURNING "billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate"
    """))
    .updateReturning(BillofmaterialsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: BillofmaterialsRowUnsaved)(using c: Connection): BillofmaterialsRow = {
    val columns: ArrayList[Fragment] = new ArrayList()
    val values: ArrayList[Fragment] = new ArrayList()
    columns.add(Fragment.lit(""""productassemblyid"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(ProductId.pgType.opt(), unsaved.productassemblyid), Fragment.lit("::int4"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""componentid"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(ProductId.pgType, unsaved.componentid), Fragment.lit("::int4"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""enddate"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.timestamp.opt(), unsaved.enddate), Fragment.lit("::timestamp"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""unitmeasurecode"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""bomlevel"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.int2, unsaved.bomlevel), Fragment.lit("::int2"))): @scala.annotation.nowarn
    unsaved.billofmaterialsid.visit(
      {  },
      value => { columns.add(Fragment.lit(""""billofmaterialsid"""")): @scala.annotation.nowarn; values.add(interpolate(Fragment.encode(PgTypes.int4, value), Fragment.lit("::int4"))): @scala.annotation.nowarn }
    );
    unsaved.startdate.visit(
      {  },
      value => { columns.add(Fragment.lit(""""startdate"""")): @scala.annotation.nowarn; values.add(interpolate(Fragment.encode(PgTypes.timestamp, value), Fragment.lit("::timestamp"))): @scala.annotation.nowarn }
    );
    unsaved.perassemblyqty.visit(
      {  },
      value => { columns.add(Fragment.lit(""""perassemblyqty"""")): @scala.annotation.nowarn; values.add(interpolate(Fragment.encode(PgTypes.numeric, value), Fragment.lit("::numeric"))): @scala.annotation.nowarn }
    );
    unsaved.modifieddate.visit(
      {  },
      value => { columns.add(Fragment.lit(""""modifieddate"""")): @scala.annotation.nowarn; values.add(interpolate(Fragment.encode(PgTypes.timestamp, value), Fragment.lit("::timestamp"))): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      interpolate(Fragment.lit("""insert into "production"."billofmaterials"("""), Fragment.comma(columns), Fragment.lit(""")
      values ("""), Fragment.comma(values), Fragment.lit(""")
      RETURNING "billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate"
      """))
    }
    return q.updateReturning(BillofmaterialsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insertStreaming(
    unsaved: java.util.Iterator[BillofmaterialsRow],
    batchSize: Integer = 10000
  )(using c: Connection): java.lang.Long = streamingInsert.insertUnchecked(s"""COPY "production"."billofmaterials"("billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate") FROM STDIN""", batchSize, unsaved, c, BillofmaterialsRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override def insertUnsavedStreaming(
    unsaved: java.util.Iterator[BillofmaterialsRowUnsaved],
    batchSize: Integer = 10000
  )(using c: Connection): java.lang.Long = streamingInsert.insertUnchecked(s"""COPY "production"."billofmaterials"("productassemblyid", "componentid", "enddate", "unitmeasurecode", "bomlevel", "billofmaterialsid", "startdate", "perassemblyqty", "modifieddate") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')""", batchSize, unsaved, c, BillofmaterialsRowUnsaved.pgText)

  override def select: SelectBuilder[BillofmaterialsFields, BillofmaterialsRow] = SelectBuilder.of(""""production"."billofmaterials"""", BillofmaterialsFields.structure, BillofmaterialsRow.`_rowParser`, Dialect.POSTGRESQL)

  override def selectAll(using c: Connection): java.util.List[BillofmaterialsRow] = {
    interpolate(Fragment.lit("""select "billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate"
    from "production"."billofmaterials"
    """)).query(BillofmaterialsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(billofmaterialsid: Integer)(using c: Connection): Optional[BillofmaterialsRow] = {
    interpolate(Fragment.lit("""select "billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate"
    from "production"."billofmaterials"
    where "billofmaterialsid" = """), Fragment.encode(PgTypes.int4, billofmaterialsid), Fragment.lit("")).query(BillofmaterialsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(billofmaterialsids: Array[Integer])(using c: Connection): java.util.List[BillofmaterialsRow] = {
    interpolate(Fragment.lit("""select "billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate"
    from "production"."billofmaterials"
    where "billofmaterialsid" = ANY("""), Fragment.encode(PgTypes.int4Array, billofmaterialsids), Fragment.lit(")")).query(BillofmaterialsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(billofmaterialsids: Array[Integer])(using c: Connection): java.util.Map[Integer, BillofmaterialsRow] = {
    val ret: HashMap[Integer, BillofmaterialsRow] = new HashMap[Integer, BillofmaterialsRow]()
    selectByIds(billofmaterialsids)(using c).forEach(row => ret.put(row.billofmaterialsid, row): @scala.annotation.nowarn)
    return ret
  }

  override def update: UpdateBuilder[BillofmaterialsFields, BillofmaterialsRow] = UpdateBuilder.of(""""production"."billofmaterials"""", BillofmaterialsFields.structure, BillofmaterialsRow.`_rowParser`, Dialect.POSTGRESQL)

  override def update(row: BillofmaterialsRow)(using c: Connection): java.lang.Boolean = {
    val billofmaterialsid: Integer = row.billofmaterialsid
    return interpolate(Fragment.lit("""update "production"."billofmaterials"
    set "productassemblyid" = """), Fragment.encode(ProductId.pgType.opt(), row.productassemblyid), Fragment.lit("""::int4,
    "componentid" = """), Fragment.encode(ProductId.pgType, row.componentid), Fragment.lit("""::int4,
    "startdate" = """), Fragment.encode(PgTypes.timestamp, row.startdate), Fragment.lit("""::timestamp,
    "enddate" = """), Fragment.encode(PgTypes.timestamp.opt(), row.enddate), Fragment.lit("""::timestamp,
    "unitmeasurecode" = """), Fragment.encode(UnitmeasureId.pgType, row.unitmeasurecode), Fragment.lit("""::bpchar,
    "bomlevel" = """), Fragment.encode(PgTypes.int2, row.bomlevel), Fragment.lit("""::int2,
    "perassemblyqty" = """), Fragment.encode(PgTypes.numeric, row.perassemblyqty), Fragment.lit("""::numeric,
    "modifieddate" = """), Fragment.encode(PgTypes.timestamp, row.modifieddate), Fragment.lit("""::timestamp
    where "billofmaterialsid" = """), Fragment.encode(PgTypes.int4, billofmaterialsid), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: BillofmaterialsRow)(using c: Connection): BillofmaterialsRow = {
  interpolate(Fragment.lit("""insert into "production"."billofmaterials"("billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate")
    values ("""), Fragment.encode(PgTypes.int4, unsaved.billofmaterialsid), Fragment.lit("::int4, "), Fragment.encode(ProductId.pgType.opt(), unsaved.productassemblyid), Fragment.lit("::int4, "), Fragment.encode(ProductId.pgType, unsaved.componentid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.timestamp, unsaved.startdate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.timestamp.opt(), unsaved.enddate), Fragment.lit("::timestamp, "), Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar, "), Fragment.encode(PgTypes.int2, unsaved.bomlevel), Fragment.lit("::int2, "), Fragment.encode(PgTypes.numeric, unsaved.perassemblyqty), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("""::timestamp)
    on conflict ("billofmaterialsid")
    do update set
      "productassemblyid" = EXCLUDED."productassemblyid",
    "componentid" = EXCLUDED."componentid",
    "startdate" = EXCLUDED."startdate",
    "enddate" = EXCLUDED."enddate",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "bomlevel" = EXCLUDED."bomlevel",
    "perassemblyqty" = EXCLUDED."perassemblyqty",
    "modifieddate" = EXCLUDED."modifieddate"
    returning "billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate""""))
    .updateReturning(BillofmaterialsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: java.util.Iterator[BillofmaterialsRow])(using c: Connection): java.util.List[BillofmaterialsRow] = {
    interpolate(Fragment.lit("""insert into "production"."billofmaterials"("billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate")
    values (?::int4, ?::int4, ?::int4, ?::timestamp, ?::timestamp, ?::bpchar, ?::int2, ?::numeric, ?::timestamp)
    on conflict ("billofmaterialsid")
    do update set
      "productassemblyid" = EXCLUDED."productassemblyid",
    "componentid" = EXCLUDED."componentid",
    "startdate" = EXCLUDED."startdate",
    "enddate" = EXCLUDED."enddate",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "bomlevel" = EXCLUDED."bomlevel",
    "perassemblyqty" = EXCLUDED."perassemblyqty",
    "modifieddate" = EXCLUDED."modifieddate"
    returning "billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate""""))
      .updateManyReturning(BillofmaterialsRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override def upsertStreaming(
    unsaved: java.util.Iterator[BillofmaterialsRow],
    batchSize: Integer = 10000
  )(using c: Connection): Integer = {
    interpolate(Fragment.lit("""create temporary table billofmaterials_TEMP (like "production"."billofmaterials") on commit drop""")).update().runUnchecked(c): @scala.annotation.nowarn
    streamingInsert.insertUnchecked(s"""copy billofmaterials_TEMP("billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate") from stdin""", batchSize, unsaved, c, BillofmaterialsRow.pgText): @scala.annotation.nowarn
    return interpolate(Fragment.lit("""insert into "production"."billofmaterials"("billofmaterialsid", "productassemblyid", "componentid", "startdate", "enddate", "unitmeasurecode", "bomlevel", "perassemblyqty", "modifieddate")
    select * from billofmaterials_TEMP
    on conflict ("billofmaterialsid")
    do update set
      "productassemblyid" = EXCLUDED."productassemblyid",
    "componentid" = EXCLUDED."componentid",
    "startdate" = EXCLUDED."startdate",
    "enddate" = EXCLUDED."enddate",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "bomlevel" = EXCLUDED."bomlevel",
    "perassemblyqty" = EXCLUDED."perassemblyqty",
    "modifieddate" = EXCLUDED."modifieddate"
    ;
    drop table billofmaterials_TEMP;""")).update().runUnchecked(c)
  }
}