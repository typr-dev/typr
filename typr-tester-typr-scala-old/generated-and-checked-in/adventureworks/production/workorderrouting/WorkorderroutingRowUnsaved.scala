/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.workorderrouting

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.Defaulted.UseDefault
import adventureworks.production.location.LocationId
import adventureworks.production.workorder.WorkorderId
import java.time.LocalDateTime
import java.util.Optional
import typr.runtime.PgText
import typr.runtime.PgTypes

/** This class corresponds to a row in table `production.workorderrouting` which has not been persisted yet */
case class WorkorderroutingRowUnsaved(
  /** Primary key. Foreign key to WorkOrder.WorkOrderID.
   * Points to [[adventureworks.production.workorder.WorkorderRow.workorderid]]
   */
  workorderid: WorkorderId,
  /** Primary key. Foreign key to Product.ProductID. */
  productid: Integer,
  /** Primary key. Indicates the manufacturing process sequence. */
  operationsequence: java.lang.Short,
  /** Manufacturing location where the part is processed. Foreign key to Location.LocationID.
   * Points to [[adventureworks.production.location.LocationRow.locationid]]
   */
  locationid: LocationId,
  /** Planned manufacturing start date.
   * Constraint CK_WorkOrderRouting_ScheduledEndDate affecting columns scheduledenddate, scheduledstartdate:  ((scheduledenddate >= scheduledstartdate))
   */
  scheduledstartdate: LocalDateTime,
  /** Planned manufacturing end date.
   * Constraint CK_WorkOrderRouting_ScheduledEndDate affecting columns scheduledenddate, scheduledstartdate:  ((scheduledenddate >= scheduledstartdate))
   */
  scheduledenddate: LocalDateTime,
  /** Actual start date.
   * Constraint CK_WorkOrderRouting_ActualEndDate affecting columns actualenddate, actualstartdate:  (((actualenddate >= actualstartdate) OR (actualenddate IS NULL) OR (actualstartdate IS NULL)))
   */
  actualstartdate: Optional[LocalDateTime] = Optional.empty(),
  /** Actual end date.
   * Constraint CK_WorkOrderRouting_ActualEndDate affecting columns actualenddate, actualstartdate:  (((actualenddate >= actualstartdate) OR (actualenddate IS NULL) OR (actualstartdate IS NULL)))
   */
  actualenddate: Optional[LocalDateTime] = Optional.empty(),
  /** Number of manufacturing hours used.
   * Constraint CK_WorkOrderRouting_ActualResourceHrs affecting columns actualresourcehrs:  ((actualresourcehrs >= 0.0000))
   */
  actualresourcehrs: Optional[java.math.BigDecimal] = Optional.empty(),
  /** Estimated manufacturing cost.
   * Constraint CK_WorkOrderRouting_PlannedCost affecting columns plannedcost:  ((plannedcost > 0.00))
   */
  plannedcost: java.math.BigDecimal,
  /** Actual manufacturing cost.
   * Constraint CK_WorkOrderRouting_ActualCost affecting columns actualcost:  ((actualcost > 0.00))
   */
  actualcost: Optional[java.math.BigDecimal] = Optional.empty(),
  /** Default: now() */
  modifieddate: Defaulted[LocalDateTime] = new UseDefault()
) {
  def toRow(modifieddateDefault: => LocalDateTime): WorkorderroutingRow = {
    new WorkorderroutingRow(
      workorderid = workorderid,
      productid = productid,
      operationsequence = operationsequence,
      locationid = locationid,
      scheduledstartdate = scheduledstartdate,
      scheduledenddate = scheduledenddate,
      actualstartdate = actualstartdate,
      actualenddate = actualenddate,
      actualresourcehrs = actualresourcehrs,
      plannedcost = plannedcost,
      actualcost = actualcost,
      modifieddate = modifieddate.getOrElse(modifieddateDefault)
    )
  }
}

object WorkorderroutingRowUnsaved {
  given pgText: PgText[WorkorderroutingRowUnsaved] = PgText.instance((row, sb) => { WorkorderId.pgType.pgText.unsafeEncode(row.workorderid, sb); sb.append(PgText.DELIMETER); PgTypes.int4.pgText.unsafeEncode(row.productid, sb); sb.append(PgText.DELIMETER); PgTypes.int2.pgText.unsafeEncode(row.operationsequence, sb); sb.append(PgText.DELIMETER); LocationId.pgType.pgText.unsafeEncode(row.locationid, sb); sb.append(PgText.DELIMETER); PgTypes.timestamp.pgText.unsafeEncode(row.scheduledstartdate, sb); sb.append(PgText.DELIMETER); PgTypes.timestamp.pgText.unsafeEncode(row.scheduledenddate, sb); sb.append(PgText.DELIMETER); PgTypes.timestamp.opt().pgText.unsafeEncode(row.actualstartdate, sb); sb.append(PgText.DELIMETER); PgTypes.timestamp.opt().pgText.unsafeEncode(row.actualenddate, sb); sb.append(PgText.DELIMETER); PgTypes.numeric.opt().pgText.unsafeEncode(row.actualresourcehrs, sb); sb.append(PgText.DELIMETER); PgTypes.numeric.pgText.unsafeEncode(row.plannedcost, sb); sb.append(PgText.DELIMETER); PgTypes.numeric.opt().pgText.unsafeEncode(row.actualcost, sb); sb.append(PgText.DELIMETER); Defaulted.pgText(using PgTypes.timestamp.pgText).unsafeEncode(row.modifieddate, sb) })
}