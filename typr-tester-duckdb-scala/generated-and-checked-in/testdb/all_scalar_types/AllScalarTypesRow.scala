/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.all_scalar_types

import com.fasterxml.jackson.annotation.JsonProperty
import java.math.BigInteger
import java.time.Duration
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.OffsetDateTime
import java.util.UUID
import testdb.Mood
import typr.data.Json
import typr.runtime.DuckDbTypes
import typr.scaladsl.DuckDbTypeOps
import typr.scaladsl.RowParser
import typr.scaladsl.RowParsers
import typr.scaladsl.ScalaDbTypes

/** Table: all_scalar_types
 * Primary key: id
 */
case class AllScalarTypesRow(
  id: AllScalarTypesId,
  @JsonProperty("col_tinyint") colTinyint: Option[Byte],
  @JsonProperty("col_smallint") colSmallint: Option[Short],
  @JsonProperty("col_integer") colInteger: Option[Int],
  @JsonProperty("col_bigint") colBigint: Option[Long],
  @JsonProperty("col_hugeint") colHugeint: Option[BigInteger],
  @JsonProperty("col_utinyint") colUtinyint: Option[Short],
  @JsonProperty("col_usmallint") colUsmallint: Option[Int],
  @JsonProperty("col_uinteger") colUinteger: Option[Long],
  @JsonProperty("col_ubigint") colUbigint: Option[BigInteger],
  @JsonProperty("col_float") colFloat: Option[Float],
  @JsonProperty("col_double") colDouble: Option[Double],
  @JsonProperty("col_decimal") colDecimal: Option[BigDecimal],
  @JsonProperty("col_boolean") colBoolean: Option[Boolean],
  @JsonProperty("col_varchar") colVarchar: Option[String],
  @JsonProperty("col_text") colText: Option[String],
  @JsonProperty("col_blob") colBlob: Option[Array[Byte]],
  @JsonProperty("col_date") colDate: Option[LocalDate],
  @JsonProperty("col_time") colTime: Option[LocalTime],
  @JsonProperty("col_timestamp") colTimestamp: Option[LocalDateTime],
  @JsonProperty("col_timestamptz") colTimestamptz: Option[OffsetDateTime],
  @JsonProperty("col_interval") colInterval: Option[Duration],
  @JsonProperty("col_uuid") colUuid: Option[UUID],
  @JsonProperty("col_json") colJson: Option[Json],
  @JsonProperty("col_mood") colMood: Option[Mood],
  @JsonProperty("col_not_null") colNotNull: String
)

object AllScalarTypesRow {
  val `_rowParser`: RowParser[AllScalarTypesRow] = RowParsers.of(AllScalarTypesId.duckDbType, ScalaDbTypes.DuckDbTypes.tinyint.nullable, ScalaDbTypes.DuckDbTypes.smallint.nullable, ScalaDbTypes.DuckDbTypes.integer.nullable, ScalaDbTypes.DuckDbTypes.bigint.nullable, DuckDbTypes.hugeint.nullable, ScalaDbTypes.DuckDbTypes.smallint.nullable, ScalaDbTypes.DuckDbTypes.integer.nullable, ScalaDbTypes.DuckDbTypes.bigint.nullable, DuckDbTypes.ubigint.nullable, ScalaDbTypes.DuckDbTypes.float_.nullable, ScalaDbTypes.DuckDbTypes.double_.nullable, ScalaDbTypes.DuckDbTypes.numeric.nullable, ScalaDbTypes.DuckDbTypes.boolean_.nullable, DuckDbTypes.varchar.nullable, DuckDbTypes.varchar.nullable, DuckDbTypes.blob.nullable, DuckDbTypes.date.nullable, DuckDbTypes.time.nullable, DuckDbTypes.timestamp.nullable, DuckDbTypes.timestamptz.nullable, DuckDbTypes.interval.nullable, DuckDbTypes.uuid.nullable, DuckDbTypes.json.nullable, Mood.duckDbType.nullable, DuckDbTypes.varchar)(AllScalarTypesRow.apply)(row => Array[Any](row.id, row.colTinyint, row.colSmallint, row.colInteger, row.colBigint, row.colHugeint, row.colUtinyint, row.colUsmallint, row.colUinteger, row.colUbigint, row.colFloat, row.colDouble, row.colDecimal, row.colBoolean, row.colVarchar, row.colText, row.colBlob, row.colDate, row.colTime, row.colTimestamp, row.colTimestamptz, row.colInterval, row.colUuid, row.colJson, row.colMood, row.colNotNull))
}