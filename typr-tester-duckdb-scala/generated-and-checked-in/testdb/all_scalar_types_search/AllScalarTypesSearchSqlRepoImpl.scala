/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.all_scalar_types_search

import java.sql.Connection
import java.time.LocalDate
import java.time.LocalDateTime
import java.util.UUID
import testdb.Mood
import typr.runtime.DuckDbTypes
import typr.scaladsl.DuckDbTypeOps
import typr.scaladsl.Fragment
import typr.scaladsl.ScalaDbTypes
import typr.scaladsl.Fragment.sql

class AllScalarTypesSearchSqlRepoImpl extends AllScalarTypesSearchSqlRepo {
  override def apply(
    id: Option[Int],
    minInteger: Option[Int],
    maxBigint: Option[Long],
    booleanValue: Option[Boolean],
    varcharPattern: Option[String],
    minDate: Option[LocalDate],
    maxDate: Option[LocalDate],
    afterTimestamp: Option[LocalDateTime],
    uuidValue: Option[UUID],
    moodValue: Option[/* user-picked */ Mood],
    minDecimal: Option[BigDecimal]
  )(using c: Connection): List[AllScalarTypesSearchSqlRow] = {
    sql"""-- Complex query testing all scalar types with various comparisons
    -- Tests: all DuckDB scalar types, optional parameters, range queries, UUID, JSON
  
    SELECT
        id,
        col_tinyint,
        col_smallint,
        col_integer,
        col_bigint,
        col_hugeint,
        col_utinyint,
        col_usmallint,
        col_uinteger,
        col_ubigint,
        col_float,
        col_double,
        col_decimal,
        col_boolean,
        col_varchar,
        col_text,
        col_blob,
        col_date,
        col_time,
        col_timestamp,
        col_timestamptz,
        col_interval,
        col_uuid,
        col_json,
        col_mood,
        col_not_null
    FROM all_scalar_types
    WHERE
        (${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer.nullable, id)} IS NULL OR id = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer.nullable, id)})
        AND (${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer.nullable, minInteger)} IS NULL OR col_integer >= ${Fragment.encode(ScalaDbTypes.DuckDbTypes.integer.nullable, minInteger)})
        AND (${Fragment.encode(ScalaDbTypes.DuckDbTypes.bigint.nullable, maxBigint)} IS NULL OR col_bigint <= ${Fragment.encode(ScalaDbTypes.DuckDbTypes.bigint.nullable, maxBigint)})
        AND (${Fragment.encode(ScalaDbTypes.DuckDbTypes.boolean_.nullable, booleanValue)} IS NULL OR col_boolean = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.boolean_.nullable, booleanValue)})
        AND (${Fragment.encode(DuckDbTypes.varchar.nullable, varcharPattern)} IS NULL OR col_varchar LIKE ${Fragment.encode(DuckDbTypes.varchar.nullable, varcharPattern)})
        AND (${Fragment.encode(DuckDbTypes.date.nullable, minDate)} IS NULL OR col_date >= ${Fragment.encode(DuckDbTypes.date.nullable, minDate)})
        AND (${Fragment.encode(DuckDbTypes.date.nullable, maxDate)} IS NULL OR col_date <= ${Fragment.encode(DuckDbTypes.date.nullable, maxDate)})
        AND (${Fragment.encode(DuckDbTypes.timestamp.nullable, afterTimestamp)} IS NULL OR col_timestamp >= ${Fragment.encode(DuckDbTypes.timestamp.nullable, afterTimestamp)})
        AND (${Fragment.encode(DuckDbTypes.uuid.nullable, uuidValue)} IS NULL OR col_uuid = ${Fragment.encode(DuckDbTypes.uuid.nullable, uuidValue)})
        AND (${Fragment.encode(Mood.duckDbType.nullable, moodValue)} IS NULL OR col_mood = ${Fragment.encode(Mood.duckDbType.nullable, moodValue)})
        AND (${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric.nullable, minDecimal)} IS NULL OR col_decimal >= ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric.nullable, minDecimal)})
    ORDER BY id""".query(AllScalarTypesSearchSqlRow.`_rowParser`.all()).runUnchecked(c)
  }
}