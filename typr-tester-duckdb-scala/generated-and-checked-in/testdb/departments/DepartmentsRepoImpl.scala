/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.departments

import java.sql.Connection
import scala.collection.mutable.ListBuffer
import typr.runtime.DuckDbTypes
import typr.scaladsl.DeleteBuilder
import typr.scaladsl.Dialect
import typr.scaladsl.DuckDbTypeOps
import typr.scaladsl.Fragment
import typr.scaladsl.ScalaDbTypes
import typr.scaladsl.SelectBuilder
import typr.scaladsl.UpdateBuilder
import typr.scaladsl.Fragment.sql

class DepartmentsRepoImpl extends DepartmentsRepo {
  override def delete: DeleteBuilder[DepartmentsFields, DepartmentsRow] = DeleteBuilder.of(""""departments"""", DepartmentsFields.structure, Dialect.DUCKDB)

  override def deleteById(compositeId: DepartmentsId)(using c: Connection): Boolean = sql"""delete from "departments" where "dept_code" = ${Fragment.encode(DuckDbTypes.varchar, compositeId.deptCode)} AND "dept_region" = ${Fragment.encode(DuckDbTypes.varchar, compositeId.deptRegion)}""".update().runUnchecked(c) > 0

  override def deleteByIds(compositeIds: Array[DepartmentsId])(using c: Connection): Int = {
    val orClauses: ListBuffer[Fragment] = ListBuffer()
    compositeIds.foreach { id => orClauses.addOne(Fragment.interpolate(Fragment.lit("("), Fragment.lit(""""dept_code" = """), Fragment.encode(DuckDbTypes.varchar, id.deptCode), Fragment.lit(" AND "), Fragment.lit(""""dept_region" = """), Fragment.encode(DuckDbTypes.varchar, id.deptRegion), Fragment.lit(")"))): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""delete
    from "departments"
    where """), Fragment.or(orClauses.toList), Fragment.lit("""
    """)).update().runUnchecked(c)
  }

  override def insert(unsaved: DepartmentsRow)(using c: Connection): DepartmentsRow = {
  sql"""insert into "departments"("dept_code", "dept_region", "dept_name", "budget")
    values (${Fragment.encode(DuckDbTypes.varchar, unsaved.deptCode)}, ${Fragment.encode(DuckDbTypes.varchar, unsaved.deptRegion)}, ${Fragment.encode(DuckDbTypes.varchar, unsaved.deptName)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric.nullable, unsaved.budget)})
    RETURNING "dept_code", "dept_region", "dept_name", "budget"
    """
    .updateReturning(DepartmentsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[DepartmentsFields, DepartmentsRow] = SelectBuilder.of(""""departments"""", DepartmentsFields.structure, DepartmentsRow.`_rowParser`, Dialect.DUCKDB)

  override def selectAll(using c: Connection): List[DepartmentsRow] = {
    sql"""select "dept_code", "dept_region", "dept_name", "budget"
    from "departments"
    """.query(DepartmentsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(compositeId: DepartmentsId)(using c: Connection): Option[DepartmentsRow] = {
    sql"""select "dept_code", "dept_region", "dept_name", "budget"
    from "departments"
    where "dept_code" = ${Fragment.encode(DuckDbTypes.varchar, compositeId.deptCode)} AND "dept_region" = ${Fragment.encode(DuckDbTypes.varchar, compositeId.deptRegion)}""".query(DepartmentsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(compositeIds: Array[DepartmentsId])(using c: Connection): List[DepartmentsRow] = {
    val orClauses: ListBuffer[Fragment] = ListBuffer()
    compositeIds.foreach { id => orClauses.addOne(Fragment.interpolate(Fragment.lit("("), Fragment.lit(""""dept_code" = """), Fragment.encode(DuckDbTypes.varchar, id.deptCode), Fragment.lit(" AND "), Fragment.lit(""""dept_region" = """), Fragment.encode(DuckDbTypes.varchar, id.deptRegion), Fragment.lit(")"))): @scala.annotation.nowarn }
    return Fragment.interpolate(Fragment.lit("""select "dept_code", "dept_region", "dept_name", "budget"
    from "departments"
    where """), Fragment.or(orClauses.toList), Fragment.lit("""
    """)).query(DepartmentsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(compositeIds: Array[DepartmentsId])(using c: Connection): Map[DepartmentsId, DepartmentsRow] = {
    val ret: scala.collection.mutable.Map[DepartmentsId, DepartmentsRow] = scala.collection.mutable.Map.empty[DepartmentsId, DepartmentsRow]
    selectByIds(compositeIds)(using c).foreach(row => ret.put(row.compositeId, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def update: UpdateBuilder[DepartmentsFields, DepartmentsRow] = UpdateBuilder.of(""""departments"""", DepartmentsFields.structure, DepartmentsRow.`_rowParser`, Dialect.DUCKDB)

  override def update(row: DepartmentsRow)(using c: Connection): Boolean = {
    val compositeId: DepartmentsId = row.compositeId
    return sql"""update "departments"
    set "dept_name" = ${Fragment.encode(DuckDbTypes.varchar, row.deptName)},
    "budget" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric.nullable, row.budget)}
    where "dept_code" = ${Fragment.encode(DuckDbTypes.varchar, compositeId.deptCode)} AND "dept_region" = ${Fragment.encode(DuckDbTypes.varchar, compositeId.deptRegion)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: DepartmentsRow)(using c: Connection): DepartmentsRow = {
  sql"""INSERT INTO "departments"("dept_code", "dept_region", "dept_name", "budget")
    VALUES (${Fragment.encode(DuckDbTypes.varchar, unsaved.deptCode)}, ${Fragment.encode(DuckDbTypes.varchar, unsaved.deptRegion)}, ${Fragment.encode(DuckDbTypes.varchar, unsaved.deptName)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric.nullable, unsaved.budget)})
    ON CONFLICT ("dept_code", "dept_region")
    DO UPDATE SET
      "dept_name" = EXCLUDED."dept_name",
    "budget" = EXCLUDED."budget"
    RETURNING "dept_code", "dept_region", "dept_name", "budget""""
    .updateReturning(DepartmentsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[DepartmentsRow])(using c: Connection): List[DepartmentsRow] = {
    sql"""INSERT INTO "departments"("dept_code", "dept_region", "dept_name", "budget")
    VALUES (?, ?, ?, ?)
    ON CONFLICT ("dept_code", "dept_region")
    DO UPDATE SET
      "dept_name" = EXCLUDED."dept_name",
    "budget" = EXCLUDED."budget"
    RETURNING "dept_code", "dept_region", "dept_name", "budget""""
      .updateReturningEach(DepartmentsRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}