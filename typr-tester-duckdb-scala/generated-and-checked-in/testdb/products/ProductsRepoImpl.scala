/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.products

import java.sql.Connection
import typr.runtime.DuckDbTypes
import typr.scaladsl.DeleteBuilder
import typr.scaladsl.Dialect
import typr.scaladsl.DuckDbTypeOps
import typr.scaladsl.Fragment
import typr.scaladsl.ScalaDbTypes
import typr.scaladsl.SelectBuilder
import typr.scaladsl.UpdateBuilder
import typr.scaladsl.Fragment.sql

class ProductsRepoImpl extends ProductsRepo {
  override def delete: DeleteBuilder[ProductsFields, ProductsRow] = DeleteBuilder.of(""""products"""", ProductsFields.structure, Dialect.DUCKDB)

  override def deleteById(productId: ProductsId)(using c: Connection): Boolean = sql"""delete from "products" where "product_id" = ${Fragment.encode(ProductsId.duckDbType, productId)}""".update().runUnchecked(c) > 0

  override def deleteByIds(productIds: Array[ProductsId])(using c: Connection): Int = {
    sql"""delete
    from "products"
    where "product_id" = ANY(${Fragment.encode(ProductsId.pgTypeArray, productIds)})"""
      .update()
      .runUnchecked(c)
  }

  override def insert(unsaved: ProductsRow)(using c: Connection): ProductsRow = {
  sql"""insert into "products"("product_id", "sku", "name", "price", "metadata")
    values (${Fragment.encode(ProductsId.duckDbType, unsaved.productId)}, ${Fragment.encode(DuckDbTypes.varchar, unsaved.sku)}, ${Fragment.encode(DuckDbTypes.varchar, unsaved.name)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric, unsaved.price)}, ${Fragment.encode(DuckDbTypes.json.nullable, unsaved.metadata)})
    RETURNING "product_id", "sku", "name", "price", "metadata"
    """
    .updateReturning(ProductsRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def select: SelectBuilder[ProductsFields, ProductsRow] = SelectBuilder.of(""""products"""", ProductsFields.structure, ProductsRow.`_rowParser`, Dialect.DUCKDB)

  override def selectAll(using c: Connection): List[ProductsRow] = {
    sql"""select "product_id", "sku", "name", "price", "metadata"
    from "products"
    """.query(ProductsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(productId: ProductsId)(using c: Connection): Option[ProductsRow] = {
    sql"""select "product_id", "sku", "name", "price", "metadata"
    from "products"
    where "product_id" = ${Fragment.encode(ProductsId.duckDbType, productId)}""".query(ProductsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(productIds: Array[ProductsId])(using c: Connection): List[ProductsRow] = {
    sql"""select "product_id", "sku", "name", "price", "metadata"
    from "products"
    where "product_id" = ANY(${Fragment.encode(ProductsId.pgTypeArray, productIds)})""".query(ProductsRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(productIds: Array[ProductsId])(using c: Connection): Map[ProductsId, ProductsRow] = {
    val ret: scala.collection.mutable.Map[ProductsId, ProductsRow] = scala.collection.mutable.Map.empty[ProductsId, ProductsRow]
    selectByIds(productIds)(using c).foreach(row => ret.put(row.productId, row): @scala.annotation.nowarn)
    return ret.toMap
  }

  override def selectByUniqueSku(sku: String)(using c: Connection): Option[ProductsRow] = {
    sql"""select "product_id", "sku", "name", "price", "metadata"
    from "products"
    where "sku" = ${Fragment.encode(DuckDbTypes.varchar, sku)}
    """.query(ProductsRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def update: UpdateBuilder[ProductsFields, ProductsRow] = UpdateBuilder.of(""""products"""", ProductsFields.structure, ProductsRow.`_rowParser`, Dialect.DUCKDB)

  override def update(row: ProductsRow)(using c: Connection): Boolean = {
    val productId: ProductsId = row.productId
    return sql"""update "products"
    set "sku" = ${Fragment.encode(DuckDbTypes.varchar, row.sku)},
    "name" = ${Fragment.encode(DuckDbTypes.varchar, row.name)},
    "price" = ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric, row.price)},
    "metadata" = ${Fragment.encode(DuckDbTypes.json.nullable, row.metadata)}
    where "product_id" = ${Fragment.encode(ProductsId.duckDbType, productId)}""".update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: ProductsRow)(using c: Connection): ProductsRow = {
  sql"""INSERT INTO "products"("product_id", "sku", "name", "price", "metadata")
    VALUES (${Fragment.encode(ProductsId.duckDbType, unsaved.productId)}, ${Fragment.encode(DuckDbTypes.varchar, unsaved.sku)}, ${Fragment.encode(DuckDbTypes.varchar, unsaved.name)}, ${Fragment.encode(ScalaDbTypes.DuckDbTypes.numeric, unsaved.price)}, ${Fragment.encode(DuckDbTypes.json.nullable, unsaved.metadata)})
    ON CONFLICT ("product_id")
    DO UPDATE SET
      "sku" = EXCLUDED."sku",
    "name" = EXCLUDED."name",
    "price" = EXCLUDED."price",
    "metadata" = EXCLUDED."metadata"
    RETURNING "product_id", "sku", "name", "price", "metadata""""
    .updateReturning(ProductsRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: Iterator[ProductsRow])(using c: Connection): List[ProductsRow] = {
    sql"""INSERT INTO "products"("product_id", "sku", "name", "price", "metadata")
    VALUES (?, ?, ?, ?, ?)
    ON CONFLICT ("product_id")
    DO UPDATE SET
      "sku" = EXCLUDED."sku",
    "name" = EXCLUDED."name",
    "price" = EXCLUDED."price",
    "metadata" = EXCLUDED."metadata"
    RETURNING "product_id", "sku", "name", "price", "metadata""""
      .updateReturningEach(ProductsRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }
}