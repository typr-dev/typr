/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.humanresources.employeedepartmenthistory

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDate
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.humanresources.department.DepartmentId
import adventureworks.humanresources.shift.ShiftId
import adventureworks.person.businessentity.BusinessentityId
import java.util.Optional
import typo.runtime.PgText
import typo.runtime.RowParser
import typo.runtime.RowParsers

/** Table: humanresources.employeedepartmenthistory
 * Employee department transfers.
 * Composite primary key: businessentityid, startdate, departmentid, shiftid
 */
case class EmployeedepartmenthistoryRow(
  /** Employee identification number. Foreign key to Employee.BusinessEntityID.
   * Points to [[adventureworks.humanresources.employee.EmployeeRow.businessentityid]]
   */
  businessentityid: BusinessentityId,
  /** Department in which the employee worked including currently. Foreign key to Department.DepartmentID.
   * Points to [[adventureworks.humanresources.department.DepartmentRow.departmentid]]
   */
  departmentid: DepartmentId,
  /** Identifies which 8-hour shift the employee works. Foreign key to Shift.Shift.ID.
   * Points to [[adventureworks.humanresources.shift.ShiftRow.shiftid]]
   */
  shiftid: ShiftId,
  /** Date the employee started work in the department.
   * Constraint CK_EmployeeDepartmentHistory_EndDate affecting columns enddate, startdate: (((enddate >= startdate) OR (enddate IS NULL)))
   */
  startdate: TypoLocalDate,
  /** Date the employee left the department. NULL = Current department.
   * Constraint CK_EmployeeDepartmentHistory_EndDate affecting columns enddate, startdate: (((enddate >= startdate) OR (enddate IS NULL)))
   */
  enddate: Optional[TypoLocalDate],
  /** Default: now() */
  modifieddate: TypoLocalDateTime
) {
  def compositeId: EmployeedepartmenthistoryId = {
    new EmployeedepartmenthistoryId(
      businessentityid,
      startdate,
      departmentid,
      shiftid
    )
  }

  def id: EmployeedepartmenthistoryId = this.compositeId

  def toUnsavedRow(modifieddate: Defaulted[TypoLocalDateTime] = Defaulted.Provided(this.modifieddate)): EmployeedepartmenthistoryRowUnsaved = {
    new EmployeedepartmenthistoryRowUnsaved(
      businessentityid,
      departmentid,
      shiftid,
      startdate,
      enddate,
      modifieddate
    )
  }
}

object EmployeedepartmenthistoryRow {
  val `_rowParser`: RowParser[EmployeedepartmenthistoryRow] = RowParsers.of(BusinessentityId.pgType, DepartmentId.pgType, ShiftId.pgType, TypoLocalDate.pgType, TypoLocalDate.pgType.opt(), TypoLocalDateTime.pgType, EmployeedepartmenthistoryRow.apply, row => Array[Object](row.businessentityid.asInstanceOf[Object], row.departmentid.asInstanceOf[Object], row.shiftid.asInstanceOf[Object], row.startdate.asInstanceOf[Object], row.enddate.asInstanceOf[Object], row.modifieddate.asInstanceOf[Object]))

  def apply(
    compositeId: EmployeedepartmenthistoryId,
    enddate: Optional[TypoLocalDate],
    modifieddate: TypoLocalDateTime
  ): EmployeedepartmenthistoryRow = {
    new EmployeedepartmenthistoryRow(
      compositeId.businessentityid,
      compositeId.departmentid,
      compositeId.shiftid,
      compositeId.startdate,
      enddate,
      modifieddate
    )
  }

  given pgText: PgText[EmployeedepartmenthistoryRow] = PgText.from(`_rowParser`)
}