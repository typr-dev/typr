/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.document

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoBytea
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.customtypes.TypoShort
import adventureworks.customtypes.TypoUUID
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.public.Flag
import java.util.Optional
import typo.runtime.PgText
import typo.runtime.PgTypes
import typo.runtime.RowParser
import typo.runtime.RowParsers

/** Table: production.document
 * Product maintenance documents.
 * Primary key: documentnode
 */
case class DocumentRow(
  /** Title of the document. */
  title: /* max 50 chars */ String,
  /** Employee who controls the document.  Foreign key to Employee.BusinessEntityID
   * Points to [[adventureworks.humanresources.employee.EmployeeRow.businessentityid]]
   */
  owner: BusinessentityId,
  /** 0 = This is a folder, 1 = This is a document.
   * Default: false
   */
  folderflag: Flag,
  /** File name of the document */
  filename: /* max 400 chars */ String,
  /** File extension indicating the document type. For example, .doc or .txt. */
  fileextension: Optional[/* max 8 chars */ String],
  /** Revision number of the document. */
  revision: /* bpchar, max 5 chars */ String,
  /** Engineering change approval number.
   * Default: 0
   */
  changenumber: Integer,
  /** 1 = Pending approval, 2 = Approved, 3 = Obsolete
   * Constraint CK_Document_Status affecting columns status: (((status >= 1) AND (status <= 3)))
   */
  status: TypoShort,
  /** Document abstract. */
  documentsummary: Optional[String],
  /** Complete document. */
  document: Optional[TypoBytea],
  /** ROWGUIDCOL number uniquely identifying the record. Required for FileStream.
   * Default: uuid_generate_v1()
   */
  rowguid: TypoUUID,
  /** Default: now() */
  modifieddate: TypoLocalDateTime,
  /** Primary key for Document records.
   * Default: '/'::character varying
   */
  documentnode: DocumentId
) {
  def id: DocumentId = documentnode

  def toUnsavedRow(
    documentnode: Defaulted[DocumentId],
    folderflag: Defaulted[Flag] = Defaulted.Provided(this.folderflag),
    changenumber: Defaulted[Integer] = Defaulted.Provided(this.changenumber),
    rowguid: Defaulted[TypoUUID] = Defaulted.Provided(this.rowguid),
    modifieddate: Defaulted[TypoLocalDateTime] = Defaulted.Provided(this.modifieddate)
  ): DocumentRowUnsaved = {
    new DocumentRowUnsaved(
      title,
      owner,
      filename,
      fileextension,
      revision,
      status,
      documentsummary,
      document,
      folderflag,
      changenumber,
      rowguid,
      modifieddate,
      documentnode
    )
  }
}

object DocumentRow {
  val `_rowParser`: RowParser[DocumentRow] = RowParsers.of(PgTypes.text, BusinessentityId.pgType, Flag.pgType, PgTypes.text, PgTypes.text.opt(), PgTypes.bpchar, PgTypes.int4, TypoShort.pgType, PgTypes.text.opt(), TypoBytea.pgType.opt(), TypoUUID.pgType, TypoLocalDateTime.pgType, DocumentId.pgType, DocumentRow.apply, row => Array(row.title, row.owner, row.folderflag, row.filename, row.fileextension, row.revision, row.changenumber, row.status, row.documentsummary, row.document, row.rowguid, row.modifieddate, row.documentnode))

  given pgText: PgText[DocumentRow] = PgText.from(`_rowParser`)
}