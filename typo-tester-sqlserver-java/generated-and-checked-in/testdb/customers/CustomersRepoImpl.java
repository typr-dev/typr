/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.customers;

import static typo.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import typo.dsl.DeleteBuilder;
import typo.dsl.Dialect;
import typo.dsl.SelectBuilder;
import typo.dsl.UpdateBuilder;
import typo.runtime.Fragment;
import typo.runtime.SqlServerTypes;

public class CustomersRepoImpl implements CustomersRepo {
  @Override
  public DeleteBuilder<CustomersFields, CustomersRow> delete() {
    return DeleteBuilder.of("[customers]", CustomersFields.structure(), Dialect.SQLSERVER);
  }
  ;

  @Override
  public Boolean deleteById(CustomersId customerId, Connection c) {
    return interpolate(
                Fragment.lit("delete from [customers] where [customer_id] = "),
                Fragment.encode(CustomersId.sqlServerType, customerId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(CustomersId[] customerIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : customerIds) {
      fragments.add(Fragment.encode(CustomersId.sqlServerType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from [customers] where [customer_id] in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public CustomersRow insert(CustomersRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into [customers]([name], [email], [created_at])\n"
                    + "OUTPUT INSERTED.[customer_id], INSERTED.[name], INSERTED.[email],"
                    + " INSERTED.[created_at]\n"
                    + "values ("),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.email()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime2.opt(), unsaved.createdAt()),
            Fragment.lit(")\n"))
        .updateReturning(CustomersRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public CustomersRow insert(CustomersRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("[name]"));
    values.add(
        interpolate(Fragment.encode(SqlServerTypes.nvarchar, unsaved.name()), Fragment.lit("")));
    columns.add(Fragment.lit("[email]"));
    values.add(
        interpolate(Fragment.encode(SqlServerTypes.nvarchar, unsaved.email()), Fragment.lit("")));
    unsaved
        .createdAt()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("[created_at]"));
              values.add(
                  interpolate(
                      Fragment.encode(SqlServerTypes.datetime2.opt(), value), Fragment.lit("")));
            });
    ;
    Fragment q =
        interpolate(
            Fragment.lit("insert into [customers]("),
            Fragment.comma(columns),
            Fragment.lit(
                ")\n"
                    + "OUTPUT INSERTED.[customer_id], INSERTED.[name], INSERTED.[email],"
                    + " INSERTED.[created_at]\n"
                    + "values ("),
            Fragment.comma(values),
            Fragment.lit(")\n"));
    ;
    return q.updateReturning(CustomersRow._rowParser.exactlyOne()).runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<CustomersFields, CustomersRow> select() {
    return SelectBuilder.of(
        "[customers]", CustomersFields.structure(), CustomersRow._rowParser, Dialect.SQLSERVER);
  }
  ;

  @Override
  public List<CustomersRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit("select [customer_id], [name], [email], [created_at]\nfrom [customers]\n"))
        .query(CustomersRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<CustomersRow> selectById(CustomersId customerId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select [customer_id], [name], [email], [created_at]\n"
                    + "from [customers]\n"
                    + "where [customer_id] = "),
            Fragment.encode(CustomersId.sqlServerType, customerId),
            Fragment.lit(""))
        .query(CustomersRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<CustomersRow> selectByIds(CustomersId[] customerIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : customerIds) {
      fragments.add(Fragment.encode(CustomersId.sqlServerType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select [customer_id], [name], [email], [created_at] from [customers] where"
                    + " [customer_id] in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(CustomersRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<CustomersId, CustomersRow> selectByIdsTracked(
      CustomersId[] customerIds, Connection c) {
    HashMap<CustomersId, CustomersRow> ret = new HashMap<CustomersId, CustomersRow>();
    selectByIds(customerIds, c).forEach(row -> ret.put(row.customerId(), row));
    return ret;
  }
  ;

  @Override
  public Optional<CustomersRow> selectByUniqueEmail(String email, Connection c) {
    return interpolate(
            Fragment.lit(
                "select [customer_id], [name], [email], [created_at]\n"
                    + "from [customers]\n"
                    + "where [email] = "),
            Fragment.encode(SqlServerTypes.nvarchar, email),
            Fragment.lit("\n"))
        .query(CustomersRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public UpdateBuilder<CustomersFields, CustomersRow> update() {
    return UpdateBuilder.of(
        "[customers]", CustomersFields.structure(), CustomersRow._rowParser, Dialect.SQLSERVER);
  }
  ;

  @Override
  public Boolean update(CustomersRow row, Connection c) {
    CustomersId customerId = row.customerId();
    ;
    return interpolate(
                Fragment.lit("update [customers]\nset [name] = "),
                Fragment.encode(SqlServerTypes.nvarchar, row.name()),
                Fragment.lit(",\n[email] = "),
                Fragment.encode(SqlServerTypes.nvarchar, row.email()),
                Fragment.lit(",\n[created_at] = "),
                Fragment.encode(SqlServerTypes.datetime2.opt(), row.createdAt()),
                Fragment.lit("\nwhere [customer_id] = "),
                Fragment.encode(CustomersId.sqlServerType, customerId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public CustomersRow upsert(CustomersRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit("MERGE INTO [customers] AS target\nUSING (VALUES ("),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.email()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime2.opt(), unsaved.createdAt()),
            Fragment.lit(
                ")) AS source([name], [email], [created_at])\n"
                    + "ON target.[customer_id] = source.[customer_id]\n"
                    + "WHEN MATCHED THEN UPDATE SET [name] = source.[name],\n"
                    + "[email] = source.[email],\n"
                    + "[created_at] = source.[created_at]\n"
                    + "WHEN NOT MATCHED THEN INSERT ([name], [email], [created_at]) VALUES ("),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.nvarchar, unsaved.email()),
            Fragment.lit(", "),
            Fragment.encode(SqlServerTypes.datetime2.opt(), unsaved.createdAt()),
            Fragment.lit(
                ")\n"
                    + "OUTPUT INSERTED.[customer_id], INSERTED.[name], INSERTED.[email],"
                    + " INSERTED.[created_at];"))
        .updateReturning(CustomersRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<CustomersRow> upsertBatch(Iterator<CustomersRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "MERGE INTO [customers] AS target\n"
                    + "USING (VALUES (?, ?, ?, ?)) AS source([customer_id], [name], [email],"
                    + " [created_at])\n"
                    + "ON target.[customer_id] = source.[customer_id]\n"
                    + "WHEN MATCHED THEN UPDATE SET [name] = source.[name],\n"
                    + "[email] = source.[email],\n"
                    + "[created_at] = source.[created_at]\n"
                    + "WHEN NOT MATCHED THEN INSERT ([customer_id], [name], [email], [created_at])"
                    + " VALUES (?, ?, ?, ?)\n"
                    + "OUTPUT INSERTED.[customer_id], INSERTED.[name], INSERTED.[email],"
                    + " INSERTED.[created_at];"))
        .updateReturningEach(CustomersRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
