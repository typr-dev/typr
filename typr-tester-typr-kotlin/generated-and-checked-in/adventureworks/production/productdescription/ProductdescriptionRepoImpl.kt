/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.productdescription

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typr.kotlindsl.DeleteBuilder
import typr.kotlindsl.Dialect
import typr.kotlindsl.Fragment
import typr.kotlindsl.SelectBuilder
import typr.kotlindsl.UpdateBuilder
import typr.runtime.PgTypes
import typr.runtime.streamingInsert

class ProductdescriptionRepoImpl() : ProductdescriptionRepo {
  override fun delete(): DeleteBuilder<ProductdescriptionFields, ProductdescriptionRow> = DeleteBuilder.of("\"production\".\"productdescription\"", ProductdescriptionFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    productdescriptionid: ProductdescriptionId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"production\".\"productdescription\" where \"productdescriptionid\" = "), Fragment.encode(ProductdescriptionId.pgType, productdescriptionid), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    productdescriptionids: Array<ProductdescriptionId>,
    c: Connection
  ): Int = Fragment.interpolate(Fragment.lit("delete\nfrom \"production\".\"productdescription\"\nwhere \"productdescriptionid\" = ANY("), Fragment.encode(ProductdescriptionId.pgTypeArray, productdescriptionids), Fragment.lit(")"))
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: ProductdescriptionRow,
    c: Connection
  ): ProductdescriptionRow = Fragment.interpolate(Fragment.lit("insert into \"production\".\"productdescription\"(\"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\")\nvalues ("), Fragment.encode(ProductdescriptionId.pgType, unsaved.productdescriptionid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.text, unsaved.description), Fragment.lit(", "), Fragment.encode(PgTypes.uuid, unsaved.rowguid), Fragment.lit("::uuid, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp)\nRETURNING \"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\"\n"))
    .updateReturning(ProductdescriptionRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: ProductdescriptionRowUnsaved,
    c: Connection
  ): ProductdescriptionRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("\"description\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.text, unsaved.description), Fragment.lit("")))
    unsaved.productdescriptionid.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"productdescriptionid\""))
      values.add(Fragment.interpolate(Fragment.encode(ProductdescriptionId.pgType, value), Fragment.lit("::int4"))) }
    );
    unsaved.rowguid.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"rowguid\""))
      values.add(Fragment.interpolate(Fragment.encode(PgTypes.uuid, value), Fragment.lit("::uuid"))) }
    );
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp, value), Fragment.lit("::timestamp"))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into \"production\".\"productdescription\"("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING \"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\"\n"))
    return q.updateReturning(ProductdescriptionRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: Iterator<ProductdescriptionRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"production\".\"productdescription\"(\"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\") FROM STDIN", batchSize, unsaved, c, ProductdescriptionRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: Iterator<ProductdescriptionRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"production\".\"productdescription\"(\"description\", \"productdescriptionid\", \"rowguid\", \"modifieddate\") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')", batchSize, unsaved, c, ProductdescriptionRowUnsaved.pgText)

  override fun select(): SelectBuilder<ProductdescriptionFields, ProductdescriptionRow> = SelectBuilder.of("\"production\".\"productdescription\"", ProductdescriptionFields.structure, ProductdescriptionRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<ProductdescriptionRow> = Fragment.interpolate(Fragment.lit("select \"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\"\nfrom \"production\".\"productdescription\"\n")).query(ProductdescriptionRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    productdescriptionid: ProductdescriptionId,
    c: Connection
  ): ProductdescriptionRow? = Fragment.interpolate(Fragment.lit("select \"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\"\nfrom \"production\".\"productdescription\"\nwhere \"productdescriptionid\" = "), Fragment.encode(ProductdescriptionId.pgType, productdescriptionid), Fragment.lit("")).query(ProductdescriptionRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    productdescriptionids: Array<ProductdescriptionId>,
    c: Connection
  ): List<ProductdescriptionRow> = Fragment.interpolate(Fragment.lit("select \"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\"\nfrom \"production\".\"productdescription\"\nwhere \"productdescriptionid\" = ANY("), Fragment.encode(ProductdescriptionId.pgTypeArray, productdescriptionids), Fragment.lit(")")).query(ProductdescriptionRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    productdescriptionids: Array<ProductdescriptionId>,
    c: Connection
  ): Map<ProductdescriptionId, ProductdescriptionRow> {
    val ret: MutableMap<ProductdescriptionId, ProductdescriptionRow> = mutableMapOf<ProductdescriptionId, ProductdescriptionRow>()
    selectByIds(productdescriptionids, c).forEach({ row -> ret.put(row.productdescriptionid, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<ProductdescriptionFields, ProductdescriptionRow> = UpdateBuilder.of("\"production\".\"productdescription\"", ProductdescriptionFields.structure, ProductdescriptionRow._rowParser, Dialect.POSTGRESQL)

  override fun update(
    row: ProductdescriptionRow,
    c: Connection
  ): Boolean {
    val productdescriptionid: ProductdescriptionId = row.productdescriptionid
    return Fragment.interpolate(Fragment.lit("update \"production\".\"productdescription\"\nset \"description\" = "), Fragment.encode(PgTypes.text, row.description), Fragment.lit(",\n\"rowguid\" = "), Fragment.encode(PgTypes.uuid, row.rowguid), Fragment.lit("::uuid,\n\"modifieddate\" = "), Fragment.encode(PgTypes.timestamp, row.modifieddate), Fragment.lit("::timestamp\nwhere \"productdescriptionid\" = "), Fragment.encode(ProductdescriptionId.pgType, productdescriptionid), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: ProductdescriptionRow,
    c: Connection
  ): ProductdescriptionRow = Fragment.interpolate(Fragment.lit("insert into \"production\".\"productdescription\"(\"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\")\nvalues ("), Fragment.encode(ProductdescriptionId.pgType, unsaved.productdescriptionid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.text, unsaved.description), Fragment.lit(", "), Fragment.encode(PgTypes.uuid, unsaved.rowguid), Fragment.lit("::uuid, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp)\non conflict (\"productdescriptionid\")\ndo update set\n  \"description\" = EXCLUDED.\"description\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\""))
    .updateReturning(ProductdescriptionRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<ProductdescriptionRow>,
    c: Connection
  ): List<ProductdescriptionRow> = Fragment.interpolate(Fragment.lit("insert into \"production\".\"productdescription\"(\"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\")\nvalues (?::int4, ?, ?::uuid, ?::timestamp)\non conflict (\"productdescriptionid\")\ndo update set\n  \"description\" = EXCLUDED.\"description\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\""))
    .updateManyReturning(ProductdescriptionRow._rowParser, unsaved)
  .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: Iterator<ProductdescriptionRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    Fragment.interpolate(Fragment.lit("create temporary table productdescription_TEMP (like \"production\".\"productdescription\") on commit drop")).update().runUnchecked(c)
    streamingInsert.insertUnchecked("copy productdescription_TEMP(\"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\") from stdin", batchSize, unsaved, c, ProductdescriptionRow.pgText)
    return Fragment.interpolate(Fragment.lit("insert into \"production\".\"productdescription\"(\"productdescriptionid\", \"description\", \"rowguid\", \"modifieddate\")\nselect * from productdescription_TEMP\non conflict (\"productdescriptionid\")\ndo update set\n  \"description\" = EXCLUDED.\"description\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\n;\ndrop table productdescription_TEMP;")).update().runUnchecked(c)
  }
}