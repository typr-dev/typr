/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.purchasing.productvendor

import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typr.kotlindsl.DeleteBuilder
import typr.kotlindsl.Dialect
import typr.kotlindsl.Fragment
import typr.kotlindsl.KotlinDbTypes
import typr.kotlindsl.SelectBuilder
import typr.kotlindsl.UpdateBuilder
import typr.kotlindsl.nullable
import typr.runtime.PgTypes
import typr.runtime.internal.arrayMap
import typr.runtime.streamingInsert

class ProductvendorRepoImpl() : ProductvendorRepo {
  override fun delete(): DeleteBuilder<ProductvendorFields, ProductvendorRow> = DeleteBuilder.of("\"purchasing\".\"productvendor\"", ProductvendorFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    compositeId: ProductvendorId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"purchasing\".\"productvendor\" where \"productid\" = "), Fragment.encode(ProductId.pgType, compositeId.productid), Fragment.lit(" AND \"businessentityid\" = "), Fragment.encode(BusinessentityId.pgType, compositeId.businessentityid), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    compositeIds: Array<ProductvendorId>,
    c: Connection
  ): Int {
    val productid: Array<ProductId> = arrayMap.map(compositeIds, ProductvendorId::productid, ProductId::class.java)
    val businessentityid: Array<BusinessentityId> = arrayMap.map(compositeIds, ProductvendorId::businessentityid, BusinessentityId::class.java)
    return Fragment.interpolate(Fragment.lit("delete\nfrom \"purchasing\".\"productvendor\"\nwhere (\"productid\", \"businessentityid\")\nin (select * from unnest("), Fragment.encode(ProductId.pgTypeArray, productid), Fragment.lit(", "), Fragment.encode(BusinessentityId.pgTypeArray, businessentityid), Fragment.lit("))\n")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: ProductvendorRow,
    c: Connection
  ): ProductvendorRow = Fragment.interpolate(Fragment.lit("insert into \"purchasing\".\"productvendor\"(\"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\")\nvalues ("), Fragment.encode(ProductId.pgType, unsaved.productid), Fragment.lit("::int4, "), Fragment.encode(BusinessentityId.pgType, unsaved.businessentityid), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.averageleadtime), Fragment.lit("::int4, "), Fragment.encode(PgTypes.numeric, unsaved.standardprice), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.numeric.nullable(), unsaved.lastreceiptcost), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.timestamp.nullable(), unsaved.lastreceiptdate), Fragment.lit("::timestamp, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.minorderqty), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.maxorderqty), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int4.nullable(), unsaved.onorderqty), Fragment.lit("::int4, "), Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp)\nRETURNING \"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\"\n"))
    .updateReturning(ProductvendorRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: ProductvendorRowUnsaved,
    c: Connection
  ): ProductvendorRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("\"productid\""))
    values.add(Fragment.interpolate(Fragment.encode(ProductId.pgType, unsaved.productid), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"businessentityid\""))
    values.add(Fragment.interpolate(Fragment.encode(BusinessentityId.pgType, unsaved.businessentityid), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"averageleadtime\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.averageleadtime), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"standardprice\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.numeric, unsaved.standardprice), Fragment.lit("::numeric")))
    columns.add(Fragment.lit("\"lastreceiptcost\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.numeric.nullable(), unsaved.lastreceiptcost), Fragment.lit("::numeric")))
    columns.add(Fragment.lit("\"lastreceiptdate\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp.nullable(), unsaved.lastreceiptdate), Fragment.lit("::timestamp")))
    columns.add(Fragment.lit("\"minorderqty\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.minorderqty), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"maxorderqty\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.maxorderqty), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"onorderqty\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int4.nullable(), unsaved.onorderqty), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"unitmeasurecode\""))
    values.add(Fragment.interpolate(Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar")))
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp, value), Fragment.lit("::timestamp"))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into \"purchasing\".\"productvendor\"("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING \"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\"\n"))
    return q.updateReturning(ProductvendorRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: Iterator<ProductvendorRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"purchasing\".\"productvendor\"(\"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\") FROM STDIN", batchSize, unsaved, c, ProductvendorRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: Iterator<ProductvendorRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"purchasing\".\"productvendor\"(\"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')", batchSize, unsaved, c, ProductvendorRowUnsaved.pgText)

  override fun select(): SelectBuilder<ProductvendorFields, ProductvendorRow> = SelectBuilder.of("\"purchasing\".\"productvendor\"", ProductvendorFields.structure, ProductvendorRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<ProductvendorRow> = Fragment.interpolate(Fragment.lit("select \"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\"\nfrom \"purchasing\".\"productvendor\"\n")).query(ProductvendorRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    compositeId: ProductvendorId,
    c: Connection
  ): ProductvendorRow? = Fragment.interpolate(Fragment.lit("select \"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\"\nfrom \"purchasing\".\"productvendor\"\nwhere \"productid\" = "), Fragment.encode(ProductId.pgType, compositeId.productid), Fragment.lit(" AND \"businessentityid\" = "), Fragment.encode(BusinessentityId.pgType, compositeId.businessentityid), Fragment.lit("")).query(ProductvendorRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    compositeIds: Array<ProductvendorId>,
    c: Connection
  ): List<ProductvendorRow> {
    val productid: Array<ProductId> = arrayMap.map(compositeIds, ProductvendorId::productid, ProductId::class.java)
    val businessentityid: Array<BusinessentityId> = arrayMap.map(compositeIds, ProductvendorId::businessentityid, BusinessentityId::class.java)
    return Fragment.interpolate(Fragment.lit("select \"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\"\nfrom \"purchasing\".\"productvendor\"\nwhere (\"productid\", \"businessentityid\")\nin (select * from unnest("), Fragment.encode(ProductId.pgTypeArray, productid), Fragment.lit(", "), Fragment.encode(BusinessentityId.pgTypeArray, businessentityid), Fragment.lit("))\n")).query(ProductvendorRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    compositeIds: Array<ProductvendorId>,
    c: Connection
  ): Map<ProductvendorId, ProductvendorRow> {
    val ret: MutableMap<ProductvendorId, ProductvendorRow> = mutableMapOf<ProductvendorId, ProductvendorRow>()
    selectByIds(compositeIds, c).forEach({ row -> ret.put(row.compositeId(), row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<ProductvendorFields, ProductvendorRow> = UpdateBuilder.of("\"purchasing\".\"productvendor\"", ProductvendorFields.structure, ProductvendorRow._rowParser, Dialect.POSTGRESQL)

  override fun update(
    row: ProductvendorRow,
    c: Connection
  ): Boolean {
    val compositeId: ProductvendorId = row.compositeId()
    return Fragment.interpolate(Fragment.lit("update \"purchasing\".\"productvendor\"\nset \"averageleadtime\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4, row.averageleadtime), Fragment.lit("::int4,\n\"standardprice\" = "), Fragment.encode(PgTypes.numeric, row.standardprice), Fragment.lit("::numeric,\n\"lastreceiptcost\" = "), Fragment.encode(PgTypes.numeric.nullable(), row.lastreceiptcost), Fragment.lit("::numeric,\n\"lastreceiptdate\" = "), Fragment.encode(PgTypes.timestamp.nullable(), row.lastreceiptdate), Fragment.lit("::timestamp,\n\"minorderqty\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4, row.minorderqty), Fragment.lit("::int4,\n\"maxorderqty\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4, row.maxorderqty), Fragment.lit("::int4,\n\"onorderqty\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4.nullable(), row.onorderqty), Fragment.lit("::int4,\n\"unitmeasurecode\" = "), Fragment.encode(UnitmeasureId.pgType, row.unitmeasurecode), Fragment.lit("::bpchar,\n\"modifieddate\" = "), Fragment.encode(PgTypes.timestamp, row.modifieddate), Fragment.lit("::timestamp\nwhere \"productid\" = "), Fragment.encode(ProductId.pgType, compositeId.productid), Fragment.lit(" AND \"businessentityid\" = "), Fragment.encode(BusinessentityId.pgType, compositeId.businessentityid), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: ProductvendorRow,
    c: Connection
  ): ProductvendorRow = Fragment.interpolate(Fragment.lit("insert into \"purchasing\".\"productvendor\"(\"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\")\nvalues ("), Fragment.encode(ProductId.pgType, unsaved.productid), Fragment.lit("::int4, "), Fragment.encode(BusinessentityId.pgType, unsaved.businessentityid), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.averageleadtime), Fragment.lit("::int4, "), Fragment.encode(PgTypes.numeric, unsaved.standardprice), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.numeric.nullable(), unsaved.lastreceiptcost), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.timestamp.nullable(), unsaved.lastreceiptdate), Fragment.lit("::timestamp, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.minorderqty), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.maxorderqty), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int4.nullable(), unsaved.onorderqty), Fragment.lit("::int4, "), Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp)\non conflict (\"productid\", \"businessentityid\")\ndo update set\n  \"averageleadtime\" = EXCLUDED.\"averageleadtime\",\n\"standardprice\" = EXCLUDED.\"standardprice\",\n\"lastreceiptcost\" = EXCLUDED.\"lastreceiptcost\",\n\"lastreceiptdate\" = EXCLUDED.\"lastreceiptdate\",\n\"minorderqty\" = EXCLUDED.\"minorderqty\",\n\"maxorderqty\" = EXCLUDED.\"maxorderqty\",\n\"onorderqty\" = EXCLUDED.\"onorderqty\",\n\"unitmeasurecode\" = EXCLUDED.\"unitmeasurecode\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\""))
    .updateReturning(ProductvendorRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<ProductvendorRow>,
    c: Connection
  ): List<ProductvendorRow> = Fragment.interpolate(Fragment.lit("insert into \"purchasing\".\"productvendor\"(\"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\")\nvalues (?::int4, ?::int4, ?::int4, ?::numeric, ?::numeric, ?::timestamp, ?::int4, ?::int4, ?::int4, ?::bpchar, ?::timestamp)\non conflict (\"productid\", \"businessentityid\")\ndo update set\n  \"averageleadtime\" = EXCLUDED.\"averageleadtime\",\n\"standardprice\" = EXCLUDED.\"standardprice\",\n\"lastreceiptcost\" = EXCLUDED.\"lastreceiptcost\",\n\"lastreceiptdate\" = EXCLUDED.\"lastreceiptdate\",\n\"minorderqty\" = EXCLUDED.\"minorderqty\",\n\"maxorderqty\" = EXCLUDED.\"maxorderqty\",\n\"onorderqty\" = EXCLUDED.\"onorderqty\",\n\"unitmeasurecode\" = EXCLUDED.\"unitmeasurecode\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\""))
    .updateManyReturning(ProductvendorRow._rowParser, unsaved)
  .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: Iterator<ProductvendorRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    Fragment.interpolate(Fragment.lit("create temporary table productvendor_TEMP (like \"purchasing\".\"productvendor\") on commit drop")).update().runUnchecked(c)
    streamingInsert.insertUnchecked("copy productvendor_TEMP(\"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\") from stdin", batchSize, unsaved, c, ProductvendorRow.pgText)
    return Fragment.interpolate(Fragment.lit("insert into \"purchasing\".\"productvendor\"(\"productid\", \"businessentityid\", \"averageleadtime\", \"standardprice\", \"lastreceiptcost\", \"lastreceiptdate\", \"minorderqty\", \"maxorderqty\", \"onorderqty\", \"unitmeasurecode\", \"modifieddate\")\nselect * from productvendor_TEMP\non conflict (\"productid\", \"businessentityid\")\ndo update set\n  \"averageleadtime\" = EXCLUDED.\"averageleadtime\",\n\"standardprice\" = EXCLUDED.\"standardprice\",\n\"lastreceiptcost\" = EXCLUDED.\"lastreceiptcost\",\n\"lastreceiptdate\" = EXCLUDED.\"lastreceiptdate\",\n\"minorderqty\" = EXCLUDED.\"minorderqty\",\n\"maxorderqty\" = EXCLUDED.\"maxorderqty\",\n\"onorderqty\" = EXCLUDED.\"onorderqty\",\n\"unitmeasurecode\" = EXCLUDED.\"unitmeasurecode\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\n;\ndrop table productvendor_TEMP;")).update().runUnchecked(c)
  }
}