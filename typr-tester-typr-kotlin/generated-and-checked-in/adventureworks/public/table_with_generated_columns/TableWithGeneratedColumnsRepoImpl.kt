/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.public.table_with_generated_columns

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typr.kotlindsl.DeleteBuilder
import typr.kotlindsl.Dialect
import typr.kotlindsl.Fragment
import typr.kotlindsl.SelectBuilder
import typr.kotlindsl.UpdateBuilder
import typr.runtime.streamingInsert

class TableWithGeneratedColumnsRepoImpl() : TableWithGeneratedColumnsRepo {
  override fun delete(): DeleteBuilder<TableWithGeneratedColumnsFields, TableWithGeneratedColumnsRow> = DeleteBuilder.of("\"public\".\"table-with-generated-columns\"", TableWithGeneratedColumnsFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    name: TableWithGeneratedColumnsId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"public\".\"table-with-generated-columns\" where \"name\" = "), Fragment.encode(TableWithGeneratedColumnsId.pgType, name), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    names: Array<TableWithGeneratedColumnsId>,
    c: Connection
  ): Int = Fragment.interpolate(Fragment.lit("delete\nfrom \"public\".\"table-with-generated-columns\"\nwhere \"name\" = ANY("), Fragment.encode(TableWithGeneratedColumnsId.pgTypeArray, names), Fragment.lit(")"))
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: TableWithGeneratedColumnsRow,
    c: Connection
  ): TableWithGeneratedColumnsRow = Fragment.interpolate(Fragment.lit("insert into \"public\".\"table-with-generated-columns\"(\"name\")\nvalues ("), Fragment.encode(TableWithGeneratedColumnsId.pgType, unsaved.name), Fragment.lit(")\nRETURNING \"name\", \"name-type-always\"\n"))
    .updateReturning(TableWithGeneratedColumnsRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: TableWithGeneratedColumnsRowUnsaved,
    c: Connection
  ): TableWithGeneratedColumnsRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("\"name\""))
    values.add(Fragment.interpolate(Fragment.encode(TableWithGeneratedColumnsId.pgType, unsaved.name), Fragment.lit("")))
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into \"public\".\"table-with-generated-columns\"("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING \"name\", \"name-type-always\"\n"))
    return q.updateReturning(TableWithGeneratedColumnsRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: Iterator<TableWithGeneratedColumnsRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"public\".\"table-with-generated-columns\"(\"name\") FROM STDIN", batchSize, unsaved, c, TableWithGeneratedColumnsRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: Iterator<TableWithGeneratedColumnsRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"public\".\"table-with-generated-columns\"(\"name\") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')", batchSize, unsaved, c, TableWithGeneratedColumnsRowUnsaved.pgText)

  override fun select(): SelectBuilder<TableWithGeneratedColumnsFields, TableWithGeneratedColumnsRow> = SelectBuilder.of("\"public\".\"table-with-generated-columns\"", TableWithGeneratedColumnsFields.structure, TableWithGeneratedColumnsRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<TableWithGeneratedColumnsRow> = Fragment.interpolate(Fragment.lit("select \"name\", \"name-type-always\"\nfrom \"public\".\"table-with-generated-columns\"\n")).query(TableWithGeneratedColumnsRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    name: TableWithGeneratedColumnsId,
    c: Connection
  ): TableWithGeneratedColumnsRow? = Fragment.interpolate(Fragment.lit("select \"name\", \"name-type-always\"\nfrom \"public\".\"table-with-generated-columns\"\nwhere \"name\" = "), Fragment.encode(TableWithGeneratedColumnsId.pgType, name), Fragment.lit("")).query(TableWithGeneratedColumnsRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    names: Array<TableWithGeneratedColumnsId>,
    c: Connection
  ): List<TableWithGeneratedColumnsRow> = Fragment.interpolate(Fragment.lit("select \"name\", \"name-type-always\"\nfrom \"public\".\"table-with-generated-columns\"\nwhere \"name\" = ANY("), Fragment.encode(TableWithGeneratedColumnsId.pgTypeArray, names), Fragment.lit(")")).query(TableWithGeneratedColumnsRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    names: Array<TableWithGeneratedColumnsId>,
    c: Connection
  ): Map<TableWithGeneratedColumnsId, TableWithGeneratedColumnsRow> {
    val ret: MutableMap<TableWithGeneratedColumnsId, TableWithGeneratedColumnsRow> = mutableMapOf<TableWithGeneratedColumnsId, TableWithGeneratedColumnsRow>()
    selectByIds(names, c).forEach({ row -> ret.put(row.name, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<TableWithGeneratedColumnsFields, TableWithGeneratedColumnsRow> = UpdateBuilder.of("\"public\".\"table-with-generated-columns\"", TableWithGeneratedColumnsFields.structure, TableWithGeneratedColumnsRow._rowParser, Dialect.POSTGRESQL)

  override fun upsert(
    unsaved: TableWithGeneratedColumnsRow,
    c: Connection
  ): TableWithGeneratedColumnsRow = Fragment.interpolate(Fragment.lit("insert into \"public\".\"table-with-generated-columns\"(\"name\")\nvalues ("), Fragment.encode(TableWithGeneratedColumnsId.pgType, unsaved.name), Fragment.lit(")\non conflict (\"name\")\ndo update set \"name\" = EXCLUDED.\"name\"\nreturning \"name\", \"name-type-always\""))
    .updateReturning(TableWithGeneratedColumnsRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<TableWithGeneratedColumnsRow>,
    c: Connection
  ): List<TableWithGeneratedColumnsRow> = Fragment.interpolate(Fragment.lit("insert into \"public\".\"table-with-generated-columns\"(\"name\")\nvalues (?)\non conflict (\"name\")\ndo update set \"name\" = EXCLUDED.\"name\"\nreturning \"name\", \"name-type-always\""))
    .updateManyReturning(TableWithGeneratedColumnsRow._rowParser, unsaved)
  .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: Iterator<TableWithGeneratedColumnsRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    Fragment.interpolate(Fragment.lit("create temporary table table-with-generated-columns_TEMP (like \"public\".\"table-with-generated-columns\") on commit drop")).update().runUnchecked(c)
    streamingInsert.insertUnchecked("copy table-with-generated-columns_TEMP(\"name\") from stdin", batchSize, unsaved, c, TableWithGeneratedColumnsRow.pgText)
    return Fragment.interpolate(Fragment.lit("insert into \"public\".\"table-with-generated-columns\"(\"name\")\nselect * from table-with-generated-columns_TEMP\non conflict (\"name\")\ndo nothing\n;\ndrop table table-with-generated-columns_TEMP;")).update().runUnchecked(c)
  }
}