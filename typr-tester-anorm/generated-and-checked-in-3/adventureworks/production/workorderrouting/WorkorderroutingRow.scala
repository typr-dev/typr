/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.workorderrouting

import adventureworks.Text
import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.customtypes.TypoShort
import adventureworks.production.location.LocationId
import adventureworks.production.workorder.WorkorderId
import anorm.Column
import anorm.RowParser
import anorm.Success
import play.api.libs.json.JsObject
import play.api.libs.json.JsResult
import play.api.libs.json.JsValue
import play.api.libs.json.OWrites
import play.api.libs.json.Reads
import play.api.libs.json.Writes
import scala.collection.immutable.ListMap
import scala.util.Try

/** Table: production.workorderrouting
 * Work order details.
 * Composite primary key: workorderid, productid, operationsequence
 */
case class WorkorderroutingRow(
  /** Primary key. Foreign key to WorkOrder.WorkOrderID.
   * Points to [[adventureworks.production.workorder.WorkorderRow.workorderid]]
   */
  workorderid: WorkorderId,
  /** Primary key. Foreign key to Product.ProductID. */
  productid: Int,
  /** Primary key. Indicates the manufacturing process sequence. */
  operationsequence: TypoShort,
  /** Manufacturing location where the part is processed. Foreign key to Location.LocationID.
   * Points to [[adventureworks.production.location.LocationRow.locationid]]
   */
  locationid: LocationId,
  /** Planned manufacturing start date.
   * Constraint CK_WorkOrderRouting_ScheduledEndDate affecting columns scheduledenddate, scheduledstartdate: ((scheduledenddate >= scheduledstartdate))
   */
  scheduledstartdate: TypoLocalDateTime,
  /** Planned manufacturing end date.
   * Constraint CK_WorkOrderRouting_ScheduledEndDate affecting columns scheduledenddate, scheduledstartdate: ((scheduledenddate >= scheduledstartdate))
   */
  scheduledenddate: TypoLocalDateTime,
  /** Actual start date.
   * Constraint CK_WorkOrderRouting_ActualEndDate affecting columns actualenddate, actualstartdate: (((actualenddate >= actualstartdate) OR (actualenddate IS NULL) OR (actualstartdate IS NULL)))
   */
  actualstartdate: Option[TypoLocalDateTime],
  /** Actual end date.
   * Constraint CK_WorkOrderRouting_ActualEndDate affecting columns actualenddate, actualstartdate: (((actualenddate >= actualstartdate) OR (actualenddate IS NULL) OR (actualstartdate IS NULL)))
   */
  actualenddate: Option[TypoLocalDateTime],
  /** Number of manufacturing hours used.
   * Constraint CK_WorkOrderRouting_ActualResourceHrs affecting columns actualresourcehrs: ((actualresourcehrs >= 0.0000))
   */
  actualresourcehrs: Option[BigDecimal],
  /** Estimated manufacturing cost.
   * Constraint CK_WorkOrderRouting_PlannedCost affecting columns plannedcost: ((plannedcost > 0.00))
   */
  plannedcost: BigDecimal,
  /** Actual manufacturing cost.
   * Constraint CK_WorkOrderRouting_ActualCost affecting columns actualcost: ((actualcost > 0.00))
   */
  actualcost: Option[BigDecimal],
  /** Default: now() */
  modifieddate: TypoLocalDateTime
) {
  def compositeId: WorkorderroutingId = new WorkorderroutingId(workorderid, productid, operationsequence)

  def id: WorkorderroutingId = this.compositeId

  def toUnsavedRow(modifieddate: Defaulted[TypoLocalDateTime] = Defaulted.Provided(this.modifieddate)): WorkorderroutingRowUnsaved = {
    new WorkorderroutingRowUnsaved(
      workorderid,
      productid,
      operationsequence,
      locationid,
      scheduledstartdate,
      scheduledenddate,
      actualstartdate,
      actualenddate,
      actualresourcehrs,
      plannedcost,
      actualcost,
      modifieddate
    )
  }
}

object WorkorderroutingRow {
  def apply(
    compositeId: WorkorderroutingId,
    locationid: LocationId,
    scheduledstartdate: TypoLocalDateTime,
    scheduledenddate: TypoLocalDateTime,
    actualstartdate: Option[TypoLocalDateTime],
    actualenddate: Option[TypoLocalDateTime],
    actualresourcehrs: Option[BigDecimal],
    plannedcost: BigDecimal,
    actualcost: Option[BigDecimal],
    modifieddate: TypoLocalDateTime
  ): WorkorderroutingRow = {
    new WorkorderroutingRow(
      compositeId.workorderid,
      compositeId.productid,
      compositeId.operationsequence,
      locationid,
      scheduledstartdate,
      scheduledenddate,
      actualstartdate,
      actualenddate,
      actualresourcehrs,
      plannedcost,
      actualcost,
      modifieddate
    )
  }

  given pgText: Text[WorkorderroutingRow] = {
    Text.instance[WorkorderroutingRow]{ (row, sb) =>
      WorkorderId.pgText.unsafeEncode(row.workorderid, sb)
      sb.append(Text.DELIMETER)
      Text.intInstance.unsafeEncode(row.productid, sb)
      sb.append(Text.DELIMETER)
      TypoShort.pgText.unsafeEncode(row.operationsequence, sb)
      sb.append(Text.DELIMETER)
      LocationId.pgText.unsafeEncode(row.locationid, sb)
      sb.append(Text.DELIMETER)
      TypoLocalDateTime.pgText.unsafeEncode(row.scheduledstartdate, sb)
      sb.append(Text.DELIMETER)
      TypoLocalDateTime.pgText.unsafeEncode(row.scheduledenddate, sb)
      sb.append(Text.DELIMETER)
      Text.option(using TypoLocalDateTime.pgText).unsafeEncode(row.actualstartdate, sb)
      sb.append(Text.DELIMETER)
      Text.option(using TypoLocalDateTime.pgText).unsafeEncode(row.actualenddate, sb)
      sb.append(Text.DELIMETER)
      Text.option(using Text.bigDecimalInstance).unsafeEncode(row.actualresourcehrs, sb)
      sb.append(Text.DELIMETER)
      Text.bigDecimalInstance.unsafeEncode(row.plannedcost, sb)
      sb.append(Text.DELIMETER)
      Text.option(using Text.bigDecimalInstance).unsafeEncode(row.actualcost, sb)
      sb.append(Text.DELIMETER)
      TypoLocalDateTime.pgText.unsafeEncode(row.modifieddate, sb)
    }
  }

  given reads: Reads[WorkorderroutingRow] = {
    Reads[WorkorderroutingRow](json => JsResult.fromTry(
        Try(
          WorkorderroutingRow(
            workorderid = json.\("workorderid").as(using WorkorderId.reads),
            productid = json.\("productid").as(using Reads.IntReads),
            operationsequence = json.\("operationsequence").as(using TypoShort.reads),
            locationid = json.\("locationid").as(using LocationId.reads),
            scheduledstartdate = json.\("scheduledstartdate").as(using TypoLocalDateTime.reads),
            scheduledenddate = json.\("scheduledenddate").as(using TypoLocalDateTime.reads),
            actualstartdate = json.\("actualstartdate").toOption.map(_.as(using TypoLocalDateTime.reads)),
            actualenddate = json.\("actualenddate").toOption.map(_.as(using TypoLocalDateTime.reads)),
            actualresourcehrs = json.\("actualresourcehrs").toOption.map(_.as(using Reads.bigDecReads)),
            plannedcost = json.\("plannedcost").as(using Reads.bigDecReads),
            actualcost = json.\("actualcost").toOption.map(_.as(using Reads.bigDecReads)),
            modifieddate = json.\("modifieddate").as(using TypoLocalDateTime.reads)
          )
        )
      ),
    )
  }

  def rowParser(idx: Int): RowParser[WorkorderroutingRow] = {
    RowParser[WorkorderroutingRow] { row =>
      Success(
        WorkorderroutingRow(
          workorderid = row(idx + 0)(using WorkorderId.column),
          productid = row(idx + 1)(using Column.columnToInt),
          operationsequence = row(idx + 2)(using TypoShort.column),
          locationid = row(idx + 3)(using LocationId.column),
          scheduledstartdate = row(idx + 4)(using TypoLocalDateTime.column),
          scheduledenddate = row(idx + 5)(using TypoLocalDateTime.column),
          actualstartdate = row(idx + 6)(using Column.columnToOption(using TypoLocalDateTime.column)),
          actualenddate = row(idx + 7)(using Column.columnToOption(using TypoLocalDateTime.column)),
          actualresourcehrs = row(idx + 8)(using Column.columnToOption(using Column.columnToScalaBigDecimal)),
          plannedcost = row(idx + 9)(using Column.columnToScalaBigDecimal),
          actualcost = row(idx + 10)(using Column.columnToOption(using Column.columnToScalaBigDecimal)),
          modifieddate = row(idx + 11)(using TypoLocalDateTime.column)
        )
      )
    }
  }

  given writes: OWrites[WorkorderroutingRow] = {
    OWrites[WorkorderroutingRow](o =>
      new JsObject(ListMap[String, JsValue](
        "workorderid" -> WorkorderId.writes.writes(o.workorderid),
        "productid" -> Writes.IntWrites.writes(o.productid),
        "operationsequence" -> TypoShort.writes.writes(o.operationsequence),
        "locationid" -> LocationId.writes.writes(o.locationid),
        "scheduledstartdate" -> TypoLocalDateTime.writes.writes(o.scheduledstartdate),
        "scheduledenddate" -> TypoLocalDateTime.writes.writes(o.scheduledenddate),
        "actualstartdate" -> Writes.OptionWrites(using TypoLocalDateTime.writes).writes(o.actualstartdate),
        "actualenddate" -> Writes.OptionWrites(using TypoLocalDateTime.writes).writes(o.actualenddate),
        "actualresourcehrs" -> Writes.OptionWrites(using Writes.BigDecimalWrites).writes(o.actualresourcehrs),
        "plannedcost" -> Writes.BigDecimalWrites.writes(o.plannedcost),
        "actualcost" -> Writes.OptionWrites(using Writes.BigDecimalWrites).writes(o.actualcost),
        "modifieddate" -> TypoLocalDateTime.writes.writes(o.modifieddate)
      ))
    )
  }
}