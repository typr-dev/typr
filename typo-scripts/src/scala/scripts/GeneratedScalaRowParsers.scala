package scripts
import bleep.internal.FileUtils
import bleep.{Commands, Started}

object GeneratedScalaRowParsers extends bleep.BleepCodegenScript("GeneratedScalaRowParsers") {
  val N = 100

  override def run(started: Started, commands: Commands, targets: List[GeneratedScalaRowParsers.Target], args: List[String]): Unit = {
    // Generate curried wrapper methods for RowParsers
    val wrapperMethods = 1
      .until(N)
      .map { n =>
        val range = 0.until(n)
        val tparamsDecl = range.map(nn => s"T$nn").mkString(", ")
        val params = range.map(nn => s"t$nn: typo.runtime.DbType[T$nn]").mkString(", ")

        // Build decode parameter type based on arity
        val decodeParamType = range.map(nn => s"T$nn").mkString("(", ", ", ")")

        s"""|  def of[$tparamsDecl, Row]($params)(decode: $decodeParamType => Row)(encode: Row => Array[Any]): typo.scaladsl.RowParser[Row] =
            |    new typo.scaladsl.RowParser(typo.runtime.RowParsers.of(${range.map(nn => s"t$nn").mkString(", ")}, ${generateDecodeAdapter(n)}, encode(_).asInstanceOf[Array[Object]]))""".stripMargin
      }

    val contents =
      s"""|// This file is generated by GeneratedScalaRowParsers script
          |// DO NOT EDIT MANUALLY
          |
          |object RowParsers {
          |${wrapperMethods.mkString("\n\n")}
          |}
          |""".stripMargin

    targets.foreach { target =>
      FileUtils.writeString(started.logger, Some("writing"), target.sources.resolve("typo/scaladsl/GeneratedRowParsers.scala"), contents)
    }
  }

  private def generateDecodeAdapter(n: Int): String = {
    val params = 0.until(n).map(nn => s"a$nn").mkString(", ")
    if (n == 1) {
      s"a => decode(a)"
    } else {
      s"($params) => decode($params)"
    }
  }
}
