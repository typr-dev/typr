/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.product_prices;

import static typr.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import testdb.price_tiers.PriceTiersId;
import testdb.products.ProductsId;
import typr.dsl.DeleteBuilder;
import typr.dsl.Dialect;
import typr.dsl.SelectBuilder;
import typr.dsl.UpdateBuilder;
import typr.runtime.Fragment;
import typr.runtime.MariaTypes;

public class ProductPricesRepoImpl implements ProductPricesRepo {
  @Override
  public DeleteBuilder<ProductPricesFields, ProductPricesRow> delete() {
    return DeleteBuilder.of("`product_prices`", ProductPricesFields.structure(), Dialect.MARIADB);
  }
  ;

  @Override
  public Boolean deleteById(ProductPricesId priceId, Connection c) {
    return interpolate(
                Fragment.lit("delete from `product_prices` where `price_id` = "),
                Fragment.encode(ProductPricesId.pgType, priceId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(ProductPricesId[] priceIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : priceIds) {
      fragments.add(Fragment.encode(ProductPricesId.pgType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from `product_prices` where `price_id` in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public ProductPricesRow insert(ProductPricesRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into `product_prices`(`product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to`)\n"
                    + "values ("),
            Fragment.encode(ProductsId.pgType, unsaved.productId()),
            Fragment.lit(", "),
            Fragment.encode(PriceTiersId.pgType.opt(), unsaved.tierId()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.numeric, unsaved.price()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.char_, unsaved.currencyCode()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.date, unsaved.validFrom()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.date.opt(), unsaved.validTo()),
            Fragment.lit(
                ")\n"
                    + "RETURNING `price_id`, `product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to`\n"))
        .updateReturning(ProductPricesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public ProductPricesRow insert(ProductPricesRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("`product_id`"));
    values.add(
        interpolate(Fragment.encode(ProductsId.pgType, unsaved.productId()), Fragment.lit("")));
    columns.add(Fragment.lit("`price`"));
    values.add(interpolate(Fragment.encode(MariaTypes.numeric, unsaved.price()), Fragment.lit("")));
    columns.add(Fragment.lit("`valid_from`"));
    values.add(
        interpolate(Fragment.encode(MariaTypes.date, unsaved.validFrom()), Fragment.lit("")));
    unsaved
        .tierId()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`tier_id`"));
              values.add(
                  interpolate(Fragment.encode(PriceTiersId.pgType.opt(), value), Fragment.lit("")));
            });
    ;
    unsaved
        .currencyCode()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`currency_code`"));
              values.add(interpolate(Fragment.encode(MariaTypes.char_, value), Fragment.lit("")));
            });
    ;
    unsaved
        .validTo()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("`valid_to`"));
              values.add(
                  interpolate(Fragment.encode(MariaTypes.date.opt(), value), Fragment.lit("")));
            });
    ;
    Fragment q =
        interpolate(
            Fragment.lit("insert into `product_prices`("),
            Fragment.comma(columns),
            Fragment.lit(")\nvalues ("),
            Fragment.comma(values),
            Fragment.lit(
                ")\n"
                    + "RETURNING `price_id`, `product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to`\n"));
    ;
    return q.updateReturning(ProductPricesRow._rowParser.exactlyOne()).runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<ProductPricesFields, ProductPricesRow> select() {
    return SelectBuilder.of(
        "`product_prices`",
        ProductPricesFields.structure(),
        ProductPricesRow._rowParser,
        Dialect.MARIADB);
  }
  ;

  @Override
  public List<ProductPricesRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit(
                "select `price_id`, `product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to`\n"
                    + "from `product_prices`\n"))
        .query(ProductPricesRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<ProductPricesRow> selectById(ProductPricesId priceId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select `price_id`, `product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to`\n"
                    + "from `product_prices`\n"
                    + "where `price_id` = "),
            Fragment.encode(ProductPricesId.pgType, priceId),
            Fragment.lit(""))
        .query(ProductPricesRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<ProductPricesRow> selectByIds(ProductPricesId[] priceIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : priceIds) {
      fragments.add(Fragment.encode(ProductPricesId.pgType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select `price_id`, `product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to` from `product_prices` where `price_id` in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(ProductPricesRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<ProductPricesId, ProductPricesRow> selectByIdsTracked(
      ProductPricesId[] priceIds, Connection c) {
    HashMap<ProductPricesId, ProductPricesRow> ret =
        new HashMap<ProductPricesId, ProductPricesRow>();
    selectByIds(priceIds, c).forEach(row -> ret.put(row.priceId(), row));
    return ret;
  }
  ;

  @Override
  public UpdateBuilder<ProductPricesFields, ProductPricesRow> update() {
    return UpdateBuilder.of(
        "`product_prices`",
        ProductPricesFields.structure(),
        ProductPricesRow._rowParser,
        Dialect.MARIADB);
  }
  ;

  @Override
  public Boolean update(ProductPricesRow row, Connection c) {
    ProductPricesId priceId = row.priceId();
    ;
    return interpolate(
                Fragment.lit("update `product_prices`\nset `product_id` = "),
                Fragment.encode(ProductsId.pgType, row.productId()),
                Fragment.lit(",\n`tier_id` = "),
                Fragment.encode(PriceTiersId.pgType.opt(), row.tierId()),
                Fragment.lit(",\n`price` = "),
                Fragment.encode(MariaTypes.numeric, row.price()),
                Fragment.lit(",\n`currency_code` = "),
                Fragment.encode(MariaTypes.char_, row.currencyCode()),
                Fragment.lit(",\n`valid_from` = "),
                Fragment.encode(MariaTypes.date, row.validFrom()),
                Fragment.lit(",\n`valid_to` = "),
                Fragment.encode(MariaTypes.date.opt(), row.validTo()),
                Fragment.lit("\nwhere `price_id` = "),
                Fragment.encode(ProductPricesId.pgType, priceId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public ProductPricesRow upsert(ProductPricesRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "INSERT INTO `product_prices`(`product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to`)\n"
                    + "VALUES ("),
            Fragment.encode(ProductsId.pgType, unsaved.productId()),
            Fragment.lit(", "),
            Fragment.encode(PriceTiersId.pgType.opt(), unsaved.tierId()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.numeric, unsaved.price()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.char_, unsaved.currencyCode()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.date, unsaved.validFrom()),
            Fragment.lit(", "),
            Fragment.encode(MariaTypes.date.opt(), unsaved.validTo()),
            Fragment.lit(
                ")\n"
                    + "ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),\n"
                    + "`tier_id` = VALUES(`tier_id`),\n"
                    + "`price` = VALUES(`price`),\n"
                    + "`currency_code` = VALUES(`currency_code`),\n"
                    + "`valid_from` = VALUES(`valid_from`),\n"
                    + "`valid_to` = VALUES(`valid_to`)\n"
                    + "RETURNING `price_id`, `product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to`"))
        .updateReturning(ProductPricesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<ProductPricesRow> upsertBatch(Iterator<ProductPricesRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "INSERT INTO `product_prices`(`price_id`, `product_id`, `tier_id`, `price`,"
                    + " `currency_code`, `valid_from`, `valid_to`)\n"
                    + "VALUES (?, ?, ?, ?, ?, ?, ?)\n"
                    + "ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),\n"
                    + "`tier_id` = VALUES(`tier_id`),\n"
                    + "`price` = VALUES(`price`),\n"
                    + "`currency_code` = VALUES(`currency_code`),\n"
                    + "`valid_from` = VALUES(`valid_from`),\n"
                    + "`valid_to` = VALUES(`valid_to`)\n"
                    + "RETURNING `price_id`, `product_id`, `tier_id`, `price`, `currency_code`,"
                    + " `valid_from`, `valid_to`"))
        .updateReturningEach(ProductPricesRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
