/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.all_scalar_types

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.KotlinDbTypes
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.kotlindsl.nullable
import typo.runtime.SqlServerTypes

class AllScalarTypesRepoImpl() : AllScalarTypesRepo {
  override fun delete(): DeleteBuilder<AllScalarTypesFields, AllScalarTypesRow> = DeleteBuilder.of("[all_scalar_types]", AllScalarTypesFields.structure, Dialect.SQLSERVER)

  override fun deleteById(
    id: AllScalarTypesId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from [all_scalar_types] where [id] = "), Fragment.encode(AllScalarTypesId.sqlServerType, id), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    ids: Array<AllScalarTypesId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in ids) { fragments.add(Fragment.encode(AllScalarTypesId.sqlServerType, id)) }
    return Fragment.interpolate(Fragment.lit("delete from [all_scalar_types] where [id] in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: AllScalarTypesRow,
    c: Connection
  ): AllScalarTypesRow = Fragment.interpolate(Fragment.lit("insert into [all_scalar_types]([col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null])\nOUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint], INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal], INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney], INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit], INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max], INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar], INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary], INSERTED.[col_varbinary], INSERTED.[col_varbinary_max], INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time], INSERTED.[col_datetime], INSERTED.[col_smalldatetime], INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset], INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json], INSERTED.[col_rowversion], INSERTED.[col_hierarchyid], INSERTED.[col_geography], INSERTED.[col_geometry], INSERTED.[col_not_null]\nvalues ("), Fragment.encode(KotlinDbTypes.SqlServerTypes.tinyint.nullable(), unsaved.colTinyint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.smallint.nullable(), unsaved.colSmallint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.int_.nullable(), unsaved.colInt), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.bigint.nullable(), unsaved.colBigint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), unsaved.colDecimal), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), unsaved.colNumeric), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.money.nullable(), unsaved.colMoney), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.smallmoney.nullable(), unsaved.colSmallmoney), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.real.nullable(), unsaved.colReal), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.float_.nullable(), unsaved.colFloat), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.bit.nullable(), unsaved.colBit), Fragment.lit(", "), Fragment.encode(SqlServerTypes.char_.nullable(), unsaved.colChar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varchar.nullable(), unsaved.colVarchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varchar.nullable(), unsaved.colVarcharMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.text.nullable(), unsaved.colText), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nchar.nullable(), unsaved.colNchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colNvarchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colNvarcharMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.ntext.nullable(), unsaved.colNtext), Fragment.lit(", "), Fragment.encode(SqlServerTypes.binary.nullable(), unsaved.colBinary), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varbinary.nullable(), unsaved.colVarbinary), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varbinary.nullable(), unsaved.colVarbinaryMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.image.nullable(), unsaved.colImage), Fragment.lit(", "), Fragment.encode(SqlServerTypes.date.nullable(), unsaved.colDate), Fragment.lit(", "), Fragment.encode(SqlServerTypes.time.nullable(), unsaved.colTime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime.nullable(), unsaved.colDatetime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.smalldatetime.nullable(), unsaved.colSmalldatetime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime2.nullable(), unsaved.colDatetime2), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetimeoffset.nullable(), unsaved.colDatetimeoffset), Fragment.lit(", "), Fragment.encode(SqlServerTypes.uniqueidentifier.nullable(), unsaved.colUniqueidentifier), Fragment.lit(", "), Fragment.encode(SqlServerTypes.xml.nullable(), unsaved.colXml), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colJson), Fragment.lit(", "), Fragment.encode(SqlServerTypes.hierarchyid.nullable(), unsaved.colHierarchyid), Fragment.lit(", "), Fragment.encode(SqlServerTypes.geography.nullable(), unsaved.colGeography), Fragment.lit(", "), Fragment.encode(SqlServerTypes.geometry.nullable(), unsaved.colGeometry), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull), Fragment.lit(")\n"))
    .updateReturning(AllScalarTypesRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: AllScalarTypesRowUnsaved,
    c: Connection
  ): AllScalarTypesRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("[col_tinyint]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.tinyint.nullable(), unsaved.colTinyint), Fragment.lit("")))
    columns.add(Fragment.lit("[col_smallint]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.smallint.nullable(), unsaved.colSmallint), Fragment.lit("")))
    columns.add(Fragment.lit("[col_int]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.int_.nullable(), unsaved.colInt), Fragment.lit("")))
    columns.add(Fragment.lit("[col_bigint]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.bigint.nullable(), unsaved.colBigint), Fragment.lit("")))
    columns.add(Fragment.lit("[col_decimal]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), unsaved.colDecimal), Fragment.lit("")))
    columns.add(Fragment.lit("[col_numeric]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), unsaved.colNumeric), Fragment.lit("")))
    columns.add(Fragment.lit("[col_money]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.money.nullable(), unsaved.colMoney), Fragment.lit("")))
    columns.add(Fragment.lit("[col_smallmoney]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.smallmoney.nullable(), unsaved.colSmallmoney), Fragment.lit("")))
    columns.add(Fragment.lit("[col_real]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.real.nullable(), unsaved.colReal), Fragment.lit("")))
    columns.add(Fragment.lit("[col_float]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.float_.nullable(), unsaved.colFloat), Fragment.lit("")))
    columns.add(Fragment.lit("[col_bit]"))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.SqlServerTypes.bit.nullable(), unsaved.colBit), Fragment.lit("")))
    columns.add(Fragment.lit("[col_char]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.char_.nullable(), unsaved.colChar), Fragment.lit("")))
    columns.add(Fragment.lit("[col_varchar]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.varchar.nullable(), unsaved.colVarchar), Fragment.lit("")))
    columns.add(Fragment.lit("[col_varchar_max]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.varchar.nullable(), unsaved.colVarcharMax), Fragment.lit("")))
    columns.add(Fragment.lit("[col_text]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.text.nullable(), unsaved.colText), Fragment.lit("")))
    columns.add(Fragment.lit("[col_nchar]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.nchar.nullable(), unsaved.colNchar), Fragment.lit("")))
    columns.add(Fragment.lit("[col_nvarchar]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colNvarchar), Fragment.lit("")))
    columns.add(Fragment.lit("[col_nvarchar_max]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colNvarcharMax), Fragment.lit("")))
    columns.add(Fragment.lit("[col_ntext]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.ntext.nullable(), unsaved.colNtext), Fragment.lit("")))
    columns.add(Fragment.lit("[col_binary]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.binary.nullable(), unsaved.colBinary), Fragment.lit("")))
    columns.add(Fragment.lit("[col_varbinary]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.varbinary.nullable(), unsaved.colVarbinary), Fragment.lit("")))
    columns.add(Fragment.lit("[col_varbinary_max]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.varbinary.nullable(), unsaved.colVarbinaryMax), Fragment.lit("")))
    columns.add(Fragment.lit("[col_image]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.image.nullable(), unsaved.colImage), Fragment.lit("")))
    columns.add(Fragment.lit("[col_date]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.date.nullable(), unsaved.colDate), Fragment.lit("")))
    columns.add(Fragment.lit("[col_time]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.time.nullable(), unsaved.colTime), Fragment.lit("")))
    columns.add(Fragment.lit("[col_datetime]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.datetime.nullable(), unsaved.colDatetime), Fragment.lit("")))
    columns.add(Fragment.lit("[col_smalldatetime]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.smalldatetime.nullable(), unsaved.colSmalldatetime), Fragment.lit("")))
    columns.add(Fragment.lit("[col_datetime2]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.datetime2.nullable(), unsaved.colDatetime2), Fragment.lit("")))
    columns.add(Fragment.lit("[col_datetimeoffset]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.datetimeoffset.nullable(), unsaved.colDatetimeoffset), Fragment.lit("")))
    columns.add(Fragment.lit("[col_uniqueidentifier]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.uniqueidentifier.nullable(), unsaved.colUniqueidentifier), Fragment.lit("")))
    columns.add(Fragment.lit("[col_xml]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.xml.nullable(), unsaved.colXml), Fragment.lit("")))
    columns.add(Fragment.lit("[col_json]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colJson), Fragment.lit("")))
    columns.add(Fragment.lit("[col_hierarchyid]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.hierarchyid.nullable(), unsaved.colHierarchyid), Fragment.lit("")))
    columns.add(Fragment.lit("[col_geography]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.geography.nullable(), unsaved.colGeography), Fragment.lit("")))
    columns.add(Fragment.lit("[col_geometry]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.geometry.nullable(), unsaved.colGeometry), Fragment.lit("")))
    unsaved.colNotNull.visit(
      {  },
      { value -> columns.add(Fragment.lit("[col_not_null]"))
      values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.nvarchar, value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into [all_scalar_types]("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nOUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint], INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal], INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney], INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit], INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max], INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar], INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary], INSERTED.[col_varbinary], INSERTED.[col_varbinary_max], INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time], INSERTED.[col_datetime], INSERTED.[col_smalldatetime], INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset], INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json], INSERTED.[col_rowversion], INSERTED.[col_hierarchyid], INSERTED.[col_geography], INSERTED.[col_geometry], INSERTED.[col_not_null]\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\n"))
    return q.updateReturning(AllScalarTypesRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<AllScalarTypesFields, AllScalarTypesRow> = SelectBuilder.of("[all_scalar_types]", AllScalarTypesFields.structure, AllScalarTypesRow._rowParser, Dialect.SQLSERVER)

  override fun selectAll(c: Connection): List<AllScalarTypesRow> = Fragment.interpolate(Fragment.lit("select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]\nfrom [all_scalar_types]\n")).query(AllScalarTypesRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    id: AllScalarTypesId,
    c: Connection
  ): AllScalarTypesRow? = Fragment.interpolate(Fragment.lit("select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]\nfrom [all_scalar_types]\nwhere [id] = "), Fragment.encode(AllScalarTypesId.sqlServerType, id), Fragment.lit("")).query(AllScalarTypesRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    ids: Array<AllScalarTypesId>,
    c: Connection
  ): List<AllScalarTypesRow> {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in ids) { fragments.add(Fragment.encode(AllScalarTypesId.sqlServerType, id)) }
    return Fragment.interpolate(Fragment.lit("select [id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null] from [all_scalar_types] where [id] in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).query(AllScalarTypesRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    ids: Array<AllScalarTypesId>,
    c: Connection
  ): Map<AllScalarTypesId, AllScalarTypesRow> {
    val ret: MutableMap<AllScalarTypesId, AllScalarTypesRow> = mutableMapOf<AllScalarTypesId, AllScalarTypesRow>()
    selectByIds(ids, c).forEach({ row -> ret.put(row.id, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<AllScalarTypesFields, AllScalarTypesRow> = UpdateBuilder.of("[all_scalar_types]", AllScalarTypesFields.structure, AllScalarTypesRow._rowParser, Dialect.SQLSERVER)

  override fun update(
    row: AllScalarTypesRow,
    c: Connection
  ): Boolean {
    val id: AllScalarTypesId = row.id
    return Fragment.interpolate(Fragment.lit("update [all_scalar_types]\nset [col_tinyint] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.tinyint.nullable(), row.colTinyint), Fragment.lit(",\n[col_smallint] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.smallint.nullable(), row.colSmallint), Fragment.lit(",\n[col_int] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.int_.nullable(), row.colInt), Fragment.lit(",\n[col_bigint] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.bigint.nullable(), row.colBigint), Fragment.lit(",\n[col_decimal] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), row.colDecimal), Fragment.lit(",\n[col_numeric] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), row.colNumeric), Fragment.lit(",\n[col_money] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.money.nullable(), row.colMoney), Fragment.lit(",\n[col_smallmoney] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.smallmoney.nullable(), row.colSmallmoney), Fragment.lit(",\n[col_real] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.real.nullable(), row.colReal), Fragment.lit(",\n[col_float] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.float_.nullable(), row.colFloat), Fragment.lit(",\n[col_bit] = "), Fragment.encode(KotlinDbTypes.SqlServerTypes.bit.nullable(), row.colBit), Fragment.lit(",\n[col_char] = "), Fragment.encode(SqlServerTypes.char_.nullable(), row.colChar), Fragment.lit(",\n[col_varchar] = "), Fragment.encode(SqlServerTypes.varchar.nullable(), row.colVarchar), Fragment.lit(",\n[col_varchar_max] = "), Fragment.encode(SqlServerTypes.varchar.nullable(), row.colVarcharMax), Fragment.lit(",\n[col_text] = "), Fragment.encode(SqlServerTypes.text.nullable(), row.colText), Fragment.lit(",\n[col_nchar] = "), Fragment.encode(SqlServerTypes.nchar.nullable(), row.colNchar), Fragment.lit(",\n[col_nvarchar] = "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), row.colNvarchar), Fragment.lit(",\n[col_nvarchar_max] = "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), row.colNvarcharMax), Fragment.lit(",\n[col_ntext] = "), Fragment.encode(SqlServerTypes.ntext.nullable(), row.colNtext), Fragment.lit(",\n[col_binary] = "), Fragment.encode(SqlServerTypes.binary.nullable(), row.colBinary), Fragment.lit(",\n[col_varbinary] = "), Fragment.encode(SqlServerTypes.varbinary.nullable(), row.colVarbinary), Fragment.lit(",\n[col_varbinary_max] = "), Fragment.encode(SqlServerTypes.varbinary.nullable(), row.colVarbinaryMax), Fragment.lit(",\n[col_image] = "), Fragment.encode(SqlServerTypes.image.nullable(), row.colImage), Fragment.lit(",\n[col_date] = "), Fragment.encode(SqlServerTypes.date.nullable(), row.colDate), Fragment.lit(",\n[col_time] = "), Fragment.encode(SqlServerTypes.time.nullable(), row.colTime), Fragment.lit(",\n[col_datetime] = "), Fragment.encode(SqlServerTypes.datetime.nullable(), row.colDatetime), Fragment.lit(",\n[col_smalldatetime] = "), Fragment.encode(SqlServerTypes.smalldatetime.nullable(), row.colSmalldatetime), Fragment.lit(",\n[col_datetime2] = "), Fragment.encode(SqlServerTypes.datetime2.nullable(), row.colDatetime2), Fragment.lit(",\n[col_datetimeoffset] = "), Fragment.encode(SqlServerTypes.datetimeoffset.nullable(), row.colDatetimeoffset), Fragment.lit(",\n[col_uniqueidentifier] = "), Fragment.encode(SqlServerTypes.uniqueidentifier.nullable(), row.colUniqueidentifier), Fragment.lit(",\n[col_xml] = "), Fragment.encode(SqlServerTypes.xml.nullable(), row.colXml), Fragment.lit(",\n[col_json] = "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), row.colJson), Fragment.lit(",\n[col_hierarchyid] = "), Fragment.encode(SqlServerTypes.hierarchyid.nullable(), row.colHierarchyid), Fragment.lit(",\n[col_geography] = "), Fragment.encode(SqlServerTypes.geography.nullable(), row.colGeography), Fragment.lit(",\n[col_geometry] = "), Fragment.encode(SqlServerTypes.geometry.nullable(), row.colGeometry), Fragment.lit(",\n[col_not_null] = "), Fragment.encode(SqlServerTypes.nvarchar, row.colNotNull), Fragment.lit("\nwhere [id] = "), Fragment.encode(AllScalarTypesId.sqlServerType, id), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: AllScalarTypesRow,
    c: Connection
  ): AllScalarTypesRow = Fragment.interpolate(Fragment.lit("MERGE INTO [all_scalar_types] AS target\nUSING (VALUES ("), Fragment.encode(KotlinDbTypes.SqlServerTypes.tinyint.nullable(), unsaved.colTinyint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.smallint.nullable(), unsaved.colSmallint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.int_.nullable(), unsaved.colInt), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.bigint.nullable(), unsaved.colBigint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), unsaved.colDecimal), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), unsaved.colNumeric), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.money.nullable(), unsaved.colMoney), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.smallmoney.nullable(), unsaved.colSmallmoney), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.real.nullable(), unsaved.colReal), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.float_.nullable(), unsaved.colFloat), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.bit.nullable(), unsaved.colBit), Fragment.lit(", "), Fragment.encode(SqlServerTypes.char_.nullable(), unsaved.colChar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varchar.nullable(), unsaved.colVarchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varchar.nullable(), unsaved.colVarcharMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.text.nullable(), unsaved.colText), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nchar.nullable(), unsaved.colNchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colNvarchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colNvarcharMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.ntext.nullable(), unsaved.colNtext), Fragment.lit(", "), Fragment.encode(SqlServerTypes.binary.nullable(), unsaved.colBinary), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varbinary.nullable(), unsaved.colVarbinary), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varbinary.nullable(), unsaved.colVarbinaryMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.image.nullable(), unsaved.colImage), Fragment.lit(", "), Fragment.encode(SqlServerTypes.date.nullable(), unsaved.colDate), Fragment.lit(", "), Fragment.encode(SqlServerTypes.time.nullable(), unsaved.colTime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime.nullable(), unsaved.colDatetime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.smalldatetime.nullable(), unsaved.colSmalldatetime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime2.nullable(), unsaved.colDatetime2), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetimeoffset.nullable(), unsaved.colDatetimeoffset), Fragment.lit(", "), Fragment.encode(SqlServerTypes.uniqueidentifier.nullable(), unsaved.colUniqueidentifier), Fragment.lit(", "), Fragment.encode(SqlServerTypes.xml.nullable(), unsaved.colXml), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colJson), Fragment.lit(", "), Fragment.encode(SqlServerTypes.hierarchyid.nullable(), unsaved.colHierarchyid), Fragment.lit(", "), Fragment.encode(SqlServerTypes.geography.nullable(), unsaved.colGeography), Fragment.lit(", "), Fragment.encode(SqlServerTypes.geometry.nullable(), unsaved.colGeometry), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull), Fragment.lit(")) AS source([col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null])\nON target.[id] = source.[id]\nWHEN MATCHED THEN UPDATE SET [col_tinyint] = source.[col_tinyint],\n[col_smallint] = source.[col_smallint],\n[col_int] = source.[col_int],\n[col_bigint] = source.[col_bigint],\n[col_decimal] = source.[col_decimal],\n[col_numeric] = source.[col_numeric],\n[col_money] = source.[col_money],\n[col_smallmoney] = source.[col_smallmoney],\n[col_real] = source.[col_real],\n[col_float] = source.[col_float],\n[col_bit] = source.[col_bit],\n[col_char] = source.[col_char],\n[col_varchar] = source.[col_varchar],\n[col_varchar_max] = source.[col_varchar_max],\n[col_text] = source.[col_text],\n[col_nchar] = source.[col_nchar],\n[col_nvarchar] = source.[col_nvarchar],\n[col_nvarchar_max] = source.[col_nvarchar_max],\n[col_ntext] = source.[col_ntext],\n[col_binary] = source.[col_binary],\n[col_varbinary] = source.[col_varbinary],\n[col_varbinary_max] = source.[col_varbinary_max],\n[col_image] = source.[col_image],\n[col_date] = source.[col_date],\n[col_time] = source.[col_time],\n[col_datetime] = source.[col_datetime],\n[col_smalldatetime] = source.[col_smalldatetime],\n[col_datetime2] = source.[col_datetime2],\n[col_datetimeoffset] = source.[col_datetimeoffset],\n[col_uniqueidentifier] = source.[col_uniqueidentifier],\n[col_xml] = source.[col_xml],\n[col_json] = source.[col_json],\n[col_hierarchyid] = source.[col_hierarchyid],\n[col_geography] = source.[col_geography],\n[col_geometry] = source.[col_geometry],\n[col_not_null] = source.[col_not_null]\nWHEN NOT MATCHED THEN INSERT ([col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]) VALUES ("), Fragment.encode(KotlinDbTypes.SqlServerTypes.tinyint.nullable(), unsaved.colTinyint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.smallint.nullable(), unsaved.colSmallint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.int_.nullable(), unsaved.colInt), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.bigint.nullable(), unsaved.colBigint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), unsaved.colDecimal), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.decimal.nullable(), unsaved.colNumeric), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.money.nullable(), unsaved.colMoney), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.smallmoney.nullable(), unsaved.colSmallmoney), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.real.nullable(), unsaved.colReal), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.float_.nullable(), unsaved.colFloat), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.SqlServerTypes.bit.nullable(), unsaved.colBit), Fragment.lit(", "), Fragment.encode(SqlServerTypes.char_.nullable(), unsaved.colChar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varchar.nullable(), unsaved.colVarchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varchar.nullable(), unsaved.colVarcharMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.text.nullable(), unsaved.colText), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nchar.nullable(), unsaved.colNchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colNvarchar), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colNvarcharMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.ntext.nullable(), unsaved.colNtext), Fragment.lit(", "), Fragment.encode(SqlServerTypes.binary.nullable(), unsaved.colBinary), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varbinary.nullable(), unsaved.colVarbinary), Fragment.lit(", "), Fragment.encode(SqlServerTypes.varbinary.nullable(), unsaved.colVarbinaryMax), Fragment.lit(", "), Fragment.encode(SqlServerTypes.image.nullable(), unsaved.colImage), Fragment.lit(", "), Fragment.encode(SqlServerTypes.date.nullable(), unsaved.colDate), Fragment.lit(", "), Fragment.encode(SqlServerTypes.time.nullable(), unsaved.colTime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime.nullable(), unsaved.colDatetime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.smalldatetime.nullable(), unsaved.colSmalldatetime), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime2.nullable(), unsaved.colDatetime2), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetimeoffset.nullable(), unsaved.colDatetimeoffset), Fragment.lit(", "), Fragment.encode(SqlServerTypes.uniqueidentifier.nullable(), unsaved.colUniqueidentifier), Fragment.lit(", "), Fragment.encode(SqlServerTypes.xml.nullable(), unsaved.colXml), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar.nullable(), unsaved.colJson), Fragment.lit(", "), Fragment.encode(SqlServerTypes.hierarchyid.nullable(), unsaved.colHierarchyid), Fragment.lit(", "), Fragment.encode(SqlServerTypes.geography.nullable(), unsaved.colGeography), Fragment.lit(", "), Fragment.encode(SqlServerTypes.geometry.nullable(), unsaved.colGeometry), Fragment.lit(", "), Fragment.encode(SqlServerTypes.nvarchar, unsaved.colNotNull), Fragment.lit(")\nOUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint], INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal], INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney], INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit], INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max], INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar], INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary], INSERTED.[col_varbinary], INSERTED.[col_varbinary_max], INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time], INSERTED.[col_datetime], INSERTED.[col_smalldatetime], INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset], INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json], INSERTED.[col_rowversion], INSERTED.[col_hierarchyid], INSERTED.[col_geography], INSERTED.[col_geometry], INSERTED.[col_not_null];"))
    .updateReturning(AllScalarTypesRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<AllScalarTypesRow>,
    c: Connection
  ): List<AllScalarTypesRow> = Fragment.interpolate(Fragment.lit("MERGE INTO [all_scalar_types] AS target\nUSING (VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)) AS source([id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null])\nON target.[id] = source.[id]\nWHEN MATCHED THEN UPDATE SET [col_tinyint] = source.[col_tinyint],\n[col_smallint] = source.[col_smallint],\n[col_int] = source.[col_int],\n[col_bigint] = source.[col_bigint],\n[col_decimal] = source.[col_decimal],\n[col_numeric] = source.[col_numeric],\n[col_money] = source.[col_money],\n[col_smallmoney] = source.[col_smallmoney],\n[col_real] = source.[col_real],\n[col_float] = source.[col_float],\n[col_bit] = source.[col_bit],\n[col_char] = source.[col_char],\n[col_varchar] = source.[col_varchar],\n[col_varchar_max] = source.[col_varchar_max],\n[col_text] = source.[col_text],\n[col_nchar] = source.[col_nchar],\n[col_nvarchar] = source.[col_nvarchar],\n[col_nvarchar_max] = source.[col_nvarchar_max],\n[col_ntext] = source.[col_ntext],\n[col_binary] = source.[col_binary],\n[col_varbinary] = source.[col_varbinary],\n[col_varbinary_max] = source.[col_varbinary_max],\n[col_image] = source.[col_image],\n[col_date] = source.[col_date],\n[col_time] = source.[col_time],\n[col_datetime] = source.[col_datetime],\n[col_smalldatetime] = source.[col_smalldatetime],\n[col_datetime2] = source.[col_datetime2],\n[col_datetimeoffset] = source.[col_datetimeoffset],\n[col_uniqueidentifier] = source.[col_uniqueidentifier],\n[col_xml] = source.[col_xml],\n[col_json] = source.[col_json],\n[col_rowversion] = source.[col_rowversion],\n[col_hierarchyid] = source.[col_hierarchyid],\n[col_geography] = source.[col_geography],\n[col_geometry] = source.[col_geometry],\n[col_not_null] = source.[col_not_null]\nWHEN NOT MATCHED THEN INSERT ([id], [col_tinyint], [col_smallint], [col_int], [col_bigint], [col_decimal], [col_numeric], [col_money], [col_smallmoney], [col_real], [col_float], [col_bit], [col_char], [col_varchar], [col_varchar_max], [col_text], [col_nchar], [col_nvarchar], [col_nvarchar_max], [col_ntext], [col_binary], [col_varbinary], [col_varbinary_max], [col_image], [col_date], [col_time], [col_datetime], [col_smalldatetime], [col_datetime2], [col_datetimeoffset], [col_uniqueidentifier], [col_xml], [col_json], [col_rowversion], [col_hierarchyid], [col_geography], [col_geometry], [col_not_null]) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\nOUTPUT INSERTED.[id], INSERTED.[col_tinyint], INSERTED.[col_smallint], INSERTED.[col_int], INSERTED.[col_bigint], INSERTED.[col_decimal], INSERTED.[col_numeric], INSERTED.[col_money], INSERTED.[col_smallmoney], INSERTED.[col_real], INSERTED.[col_float], INSERTED.[col_bit], INSERTED.[col_char], INSERTED.[col_varchar], INSERTED.[col_varchar_max], INSERTED.[col_text], INSERTED.[col_nchar], INSERTED.[col_nvarchar], INSERTED.[col_nvarchar_max], INSERTED.[col_ntext], INSERTED.[col_binary], INSERTED.[col_varbinary], INSERTED.[col_varbinary_max], INSERTED.[col_image], INSERTED.[col_date], INSERTED.[col_time], INSERTED.[col_datetime], INSERTED.[col_smalldatetime], INSERTED.[col_datetime2], INSERTED.[col_datetimeoffset], INSERTED.[col_uniqueidentifier], INSERTED.[col_xml], INSERTED.[col_json], INSERTED.[col_rowversion], INSERTED.[col_hierarchyid], INSERTED.[col_geography], INSERTED.[col_geometry], INSERTED.[col_not_null];"))
    .updateReturningEach(AllScalarTypesRow._rowParser, unsaved)
  .runUnchecked(c)
}