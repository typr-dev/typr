/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.test_connection

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.kotlindsl.nullable
import typo.runtime.SqlServerTypes

class TestConnectionRepoImpl() : TestConnectionRepo {
  override fun delete(): DeleteBuilder<TestConnectionFields, TestConnectionRow> = DeleteBuilder.of("[test_connection]", TestConnectionFields.structure, Dialect.SQLSERVER)

  override fun deleteById(
    id: TestConnectionId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from [test_connection] where [id] = "), Fragment.encode(TestConnectionId.sqlServerType, id), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    ids: Array<TestConnectionId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in ids) { fragments.add(Fragment.encode(TestConnectionId.sqlServerType, id)) }
    return Fragment.interpolate(Fragment.lit("delete from [test_connection] where [id] in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: TestConnectionRow,
    c: Connection
  ): TestConnectionRow = Fragment.interpolate(Fragment.lit("insert into [test_connection]([message], [created_at])\nOUTPUT INSERTED.[id], INSERTED.[message], INSERTED.[created_at]\nvalues ("), Fragment.encode(SqlServerTypes.nvarchar, unsaved.message), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime2.nullable(), unsaved.createdAt), Fragment.lit(")\n"))
    .updateReturning(TestConnectionRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: TestConnectionRowUnsaved,
    c: Connection
  ): TestConnectionRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("[message]"))
    values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.nvarchar, unsaved.message), Fragment.lit("")))
    unsaved.createdAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("[created_at]"))
      values.add(Fragment.interpolate(Fragment.encode(SqlServerTypes.datetime2.nullable(), value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into [test_connection]("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nOUTPUT INSERTED.[id], INSERTED.[message], INSERTED.[created_at]\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\n"))
    return q.updateReturning(TestConnectionRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<TestConnectionFields, TestConnectionRow> = SelectBuilder.of("[test_connection]", TestConnectionFields.structure, TestConnectionRow._rowParser, Dialect.SQLSERVER)

  override fun selectAll(c: Connection): List<TestConnectionRow> = Fragment.interpolate(Fragment.lit("select [id], [message], [created_at]\nfrom [test_connection]\n")).query(TestConnectionRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    id: TestConnectionId,
    c: Connection
  ): TestConnectionRow? = Fragment.interpolate(Fragment.lit("select [id], [message], [created_at]\nfrom [test_connection]\nwhere [id] = "), Fragment.encode(TestConnectionId.sqlServerType, id), Fragment.lit("")).query(TestConnectionRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    ids: Array<TestConnectionId>,
    c: Connection
  ): List<TestConnectionRow> {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in ids) { fragments.add(Fragment.encode(TestConnectionId.sqlServerType, id)) }
    return Fragment.interpolate(Fragment.lit("select [id], [message], [created_at] from [test_connection] where [id] in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).query(TestConnectionRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    ids: Array<TestConnectionId>,
    c: Connection
  ): Map<TestConnectionId, TestConnectionRow> {
    val ret: MutableMap<TestConnectionId, TestConnectionRow> = mutableMapOf<TestConnectionId, TestConnectionRow>()
    selectByIds(ids, c).forEach({ row -> ret.put(row.id, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<TestConnectionFields, TestConnectionRow> = UpdateBuilder.of("[test_connection]", TestConnectionFields.structure, TestConnectionRow._rowParser, Dialect.SQLSERVER)

  override fun update(
    row: TestConnectionRow,
    c: Connection
  ): Boolean {
    val id: TestConnectionId = row.id
    return Fragment.interpolate(Fragment.lit("update [test_connection]\nset [message] = "), Fragment.encode(SqlServerTypes.nvarchar, row.message), Fragment.lit(",\n[created_at] = "), Fragment.encode(SqlServerTypes.datetime2.nullable(), row.createdAt), Fragment.lit("\nwhere [id] = "), Fragment.encode(TestConnectionId.sqlServerType, id), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: TestConnectionRow,
    c: Connection
  ): TestConnectionRow = Fragment.interpolate(Fragment.lit("MERGE INTO [test_connection] AS target\nUSING (VALUES ("), Fragment.encode(SqlServerTypes.nvarchar, unsaved.message), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime2.nullable(), unsaved.createdAt), Fragment.lit(")) AS source([message], [created_at])\nON target.[id] = source.[id]\nWHEN MATCHED THEN UPDATE SET [message] = source.[message],\n[created_at] = source.[created_at]\nWHEN NOT MATCHED THEN INSERT ([message], [created_at]) VALUES ("), Fragment.encode(SqlServerTypes.nvarchar, unsaved.message), Fragment.lit(", "), Fragment.encode(SqlServerTypes.datetime2.nullable(), unsaved.createdAt), Fragment.lit(")\nOUTPUT INSERTED.[id], INSERTED.[message], INSERTED.[created_at];"))
    .updateReturning(TestConnectionRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<TestConnectionRow>,
    c: Connection
  ): List<TestConnectionRow> = Fragment.interpolate(Fragment.lit("MERGE INTO [test_connection] AS target\nUSING (VALUES (?, ?, ?)) AS source([id], [message], [created_at])\nON target.[id] = source.[id]\nWHEN MATCHED THEN UPDATE SET [message] = source.[message],\n[created_at] = source.[created_at]\nWHEN NOT MATCHED THEN INSERT ([id], [message], [created_at]) VALUES (?, ?, ?)\nOUTPUT INSERTED.[id], INSERTED.[message], INSERTED.[created_at];"))
    .updateReturningEach(TestConnectionRow._rowParser, unsaved)
  .runUnchecked(c)
}