/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.all_scalar_types_search;

import static typr.runtime.Fragment.interpolate;

import java.math.BigDecimal;
import java.sql.Connection;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import testdb.Mood;
import typr.runtime.DuckDbTypes;
import typr.runtime.Fragment;

public class AllScalarTypesSearchSqlRepoImpl implements AllScalarTypesSearchSqlRepo {
  @Override
  public List<AllScalarTypesSearchSqlRow> apply(
      Optional<Integer> id,
      Optional<Integer> minInteger,
      Optional<Long> maxBigint,
      Optional<Boolean> booleanValue,
      Optional<String> varcharPattern,
      Optional<LocalDate> minDate,
      Optional<LocalDate> maxDate,
      Optional<LocalDateTime> afterTimestamp,
      Optional<UUID> uuidValue,
      Optional</* user-picked */ Mood> moodValue,
      Optional<BigDecimal> minDecimal,
      Connection c) {
    return interpolate(
            Fragment.lit(
                "-- Complex query testing all scalar types with various comparisons\n"
                    + "-- Tests: all DuckDB scalar types, optional parameters, range queries, UUID,"
                    + " JSON\n\n"
                    + "SELECT\n"
                    + "    id,\n"
                    + "    col_tinyint,\n"
                    + "    col_smallint,\n"
                    + "    col_integer,\n"
                    + "    col_bigint,\n"
                    + "    col_hugeint,\n"
                    + "    col_utinyint,\n"
                    + "    col_usmallint,\n"
                    + "    col_uinteger,\n"
                    + "    col_ubigint,\n"
                    + "    col_float,\n"
                    + "    col_double,\n"
                    + "    col_decimal,\n"
                    + "    col_boolean,\n"
                    + "    col_varchar,\n"
                    + "    col_text,\n"
                    + "    col_blob,\n"
                    + "    col_date,\n"
                    + "    col_time,\n"
                    + "    col_timestamp,\n"
                    + "    col_timestamptz,\n"
                    + "    col_interval,\n"
                    + "    col_uuid,\n"
                    + "    col_json,\n"
                    + "    col_mood,\n"
                    + "    col_not_null\n"
                    + "FROM all_scalar_types\n"
                    + "WHERE\n"
                    + "    ("),
            Fragment.encode(DuckDbTypes.integer.opt(), id),
            Fragment.lit(" IS NULL OR id = "),
            Fragment.encode(DuckDbTypes.integer.opt(), id),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.integer.opt(), minInteger),
            Fragment.lit(" IS NULL OR col_integer >= "),
            Fragment.encode(DuckDbTypes.integer.opt(), minInteger),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.bigint.opt(), maxBigint),
            Fragment.lit(" IS NULL OR col_bigint <= "),
            Fragment.encode(DuckDbTypes.bigint.opt(), maxBigint),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.boolean_.opt(), booleanValue),
            Fragment.lit(" IS NULL OR col_boolean = "),
            Fragment.encode(DuckDbTypes.boolean_.opt(), booleanValue),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.varchar.opt(), varcharPattern),
            Fragment.lit(" IS NULL OR col_varchar LIKE "),
            Fragment.encode(DuckDbTypes.varchar.opt(), varcharPattern),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.date.opt(), minDate),
            Fragment.lit(" IS NULL OR col_date >= "),
            Fragment.encode(DuckDbTypes.date.opt(), minDate),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.date.opt(), maxDate),
            Fragment.lit(" IS NULL OR col_date <= "),
            Fragment.encode(DuckDbTypes.date.opt(), maxDate),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.timestamp.opt(), afterTimestamp),
            Fragment.lit(" IS NULL OR col_timestamp >= "),
            Fragment.encode(DuckDbTypes.timestamp.opt(), afterTimestamp),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.uuid.opt(), uuidValue),
            Fragment.lit(" IS NULL OR col_uuid = "),
            Fragment.encode(DuckDbTypes.uuid.opt(), uuidValue),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(Mood.duckDbType.opt(), moodValue),
            Fragment.lit(" IS NULL OR col_mood = "),
            Fragment.encode(Mood.duckDbType.opt(), moodValue),
            Fragment.lit(")\n    AND ("),
            Fragment.encode(DuckDbTypes.numeric.opt(), minDecimal),
            Fragment.lit(" IS NULL OR col_decimal >= "),
            Fragment.encode(DuckDbTypes.numeric.opt(), minDecimal),
            Fragment.lit(")\nORDER BY id"))
        .query(AllScalarTypesSearchSqlRow._rowParser.all())
        .runUnchecked(c);
  }
  ;
}
