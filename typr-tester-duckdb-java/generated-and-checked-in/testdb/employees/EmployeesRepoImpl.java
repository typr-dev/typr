/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.employees;

import static typr.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import typr.dsl.DeleteBuilder;
import typr.dsl.Dialect;
import typr.dsl.SelectBuilder;
import typr.dsl.UpdateBuilder;
import typr.runtime.DuckDbTypes;
import typr.runtime.Fragment;

public class EmployeesRepoImpl implements EmployeesRepo {
  @Override
  public DeleteBuilder<EmployeesFields, EmployeesRow> delete() {
    return DeleteBuilder.of("\"employees\"", EmployeesFields.structure(), Dialect.DUCKDB);
  }
  ;

  @Override
  public Boolean deleteById(EmployeesId compositeId, Connection c) {
    return interpolate(
                Fragment.lit("delete from \"employees\" where \"emp_number\" = "),
                Fragment.encode(DuckDbTypes.integer, compositeId.empNumber()),
                Fragment.lit(" AND \"emp_suffix\" = "),
                Fragment.encode(DuckDbTypes.varchar, compositeId.empSuffix()),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(EmployeesId[] compositeIds, Connection c) {
    ArrayList<Fragment> orClauses = new ArrayList<>();
    for (var id : compositeIds) {
      orClauses.add(
          Fragment.interpolate(
              Fragment.lit("("),
              Fragment.lit("\"emp_number\" = "),
              Fragment.encode(DuckDbTypes.integer, id.empNumber()),
              Fragment.lit(" AND "),
              Fragment.lit("\"emp_suffix\" = "),
              Fragment.encode(DuckDbTypes.varchar, id.empSuffix()),
              Fragment.lit(")")));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete\nfrom \"employees\"\nwhere "),
            Fragment.or(orClauses),
            Fragment.lit("\n"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public EmployeesRow insert(EmployeesRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into \"employees\"(\"emp_number\", \"emp_suffix\", \"dept_code\","
                    + " \"dept_region\", \"emp_name\", \"salary\", \"hire_date\")\n"
                    + "values ("),
            Fragment.encode(DuckDbTypes.integer, unsaved.empNumber()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.varchar, unsaved.empSuffix()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.varchar, unsaved.deptCode()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.varchar, unsaved.deptRegion()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.varchar, unsaved.empName()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.numeric.opt(), unsaved.salary()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.date, unsaved.hireDate()),
            Fragment.lit(
                ")\n"
                    + "RETURNING \"emp_number\", \"emp_suffix\", \"dept_code\", \"dept_region\","
                    + " \"emp_name\", \"salary\", \"hire_date\"\n"))
        .updateReturning(EmployeesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public EmployeesRow insert(EmployeesRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("\"emp_number\""));
    values.add(
        interpolate(Fragment.encode(DuckDbTypes.integer, unsaved.empNumber()), Fragment.lit("")));
    columns.add(Fragment.lit("\"emp_suffix\""));
    values.add(
        interpolate(Fragment.encode(DuckDbTypes.varchar, unsaved.empSuffix()), Fragment.lit("")));
    columns.add(Fragment.lit("\"dept_code\""));
    values.add(
        interpolate(Fragment.encode(DuckDbTypes.varchar, unsaved.deptCode()), Fragment.lit("")));
    columns.add(Fragment.lit("\"dept_region\""));
    values.add(
        interpolate(Fragment.encode(DuckDbTypes.varchar, unsaved.deptRegion()), Fragment.lit("")));
    columns.add(Fragment.lit("\"emp_name\""));
    values.add(
        interpolate(Fragment.encode(DuckDbTypes.varchar, unsaved.empName()), Fragment.lit("")));
    columns.add(Fragment.lit("\"salary\""));
    values.add(
        interpolate(
            Fragment.encode(DuckDbTypes.numeric.opt(), unsaved.salary()), Fragment.lit("")));
    unsaved
        .hireDate()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("\"hire_date\""));
              values.add(interpolate(Fragment.encode(DuckDbTypes.date, value), Fragment.lit("")));
            });
    ;
    Fragment q =
        interpolate(
            Fragment.lit("insert into \"employees\"("),
            Fragment.comma(columns),
            Fragment.lit(")\nvalues ("),
            Fragment.comma(values),
            Fragment.lit(
                ")\n"
                    + "RETURNING \"emp_number\", \"emp_suffix\", \"dept_code\", \"dept_region\","
                    + " \"emp_name\", \"salary\", \"hire_date\"\n"));
    ;
    return q.updateReturning(EmployeesRow._rowParser.exactlyOne()).runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<EmployeesFields, EmployeesRow> select() {
    return SelectBuilder.of(
        "\"employees\"", EmployeesFields.structure(), EmployeesRow._rowParser, Dialect.DUCKDB);
  }
  ;

  @Override
  public List<EmployeesRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit(
                "select \"emp_number\", \"emp_suffix\", \"dept_code\", \"dept_region\","
                    + " \"emp_name\", \"salary\", \"hire_date\"\n"
                    + "from \"employees\"\n"))
        .query(EmployeesRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<EmployeesRow> selectById(EmployeesId compositeId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select \"emp_number\", \"emp_suffix\", \"dept_code\", \"dept_region\","
                    + " \"emp_name\", \"salary\", \"hire_date\"\n"
                    + "from \"employees\"\n"
                    + "where \"emp_number\" = "),
            Fragment.encode(DuckDbTypes.integer, compositeId.empNumber()),
            Fragment.lit(" AND \"emp_suffix\" = "),
            Fragment.encode(DuckDbTypes.varchar, compositeId.empSuffix()),
            Fragment.lit(""))
        .query(EmployeesRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<EmployeesRow> selectByIds(EmployeesId[] compositeIds, Connection c) {
    ArrayList<Fragment> orClauses = new ArrayList<>();
    for (var id : compositeIds) {
      orClauses.add(
          Fragment.interpolate(
              Fragment.lit("("),
              Fragment.lit("\"emp_number\" = "),
              Fragment.encode(DuckDbTypes.integer, id.empNumber()),
              Fragment.lit(" AND "),
              Fragment.lit("\"emp_suffix\" = "),
              Fragment.encode(DuckDbTypes.varchar, id.empSuffix()),
              Fragment.lit(")")));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select \"emp_number\", \"emp_suffix\", \"dept_code\", \"dept_region\","
                    + " \"emp_name\", \"salary\", \"hire_date\"\n"
                    + "from \"employees\"\n"
                    + "where "),
            Fragment.or(orClauses),
            Fragment.lit("\n"))
        .query(EmployeesRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<EmployeesId, EmployeesRow> selectByIdsTracked(
      EmployeesId[] compositeIds, Connection c) {
    HashMap<EmployeesId, EmployeesRow> ret = new HashMap<EmployeesId, EmployeesRow>();
    selectByIds(compositeIds, c).forEach(row -> ret.put(row.compositeId(), row));
    return ret;
  }
  ;

  @Override
  public UpdateBuilder<EmployeesFields, EmployeesRow> update() {
    return UpdateBuilder.of(
        "\"employees\"", EmployeesFields.structure(), EmployeesRow._rowParser, Dialect.DUCKDB);
  }
  ;

  @Override
  public Boolean update(EmployeesRow row, Connection c) {
    EmployeesId compositeId = row.compositeId();
    ;
    return interpolate(
                Fragment.lit("update \"employees\"\nset \"dept_code\" = "),
                Fragment.encode(DuckDbTypes.varchar, row.deptCode()),
                Fragment.lit(",\n\"dept_region\" = "),
                Fragment.encode(DuckDbTypes.varchar, row.deptRegion()),
                Fragment.lit(",\n\"emp_name\" = "),
                Fragment.encode(DuckDbTypes.varchar, row.empName()),
                Fragment.lit(",\n\"salary\" = "),
                Fragment.encode(DuckDbTypes.numeric.opt(), row.salary()),
                Fragment.lit(",\n\"hire_date\" = "),
                Fragment.encode(DuckDbTypes.date, row.hireDate()),
                Fragment.lit("\nwhere \"emp_number\" = "),
                Fragment.encode(DuckDbTypes.integer, compositeId.empNumber()),
                Fragment.lit(" AND \"emp_suffix\" = "),
                Fragment.encode(DuckDbTypes.varchar, compositeId.empSuffix()),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public EmployeesRow upsert(EmployeesRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "INSERT INTO \"employees\"(\"emp_number\", \"emp_suffix\", \"dept_code\","
                    + " \"dept_region\", \"emp_name\", \"salary\", \"hire_date\")\n"
                    + "VALUES ("),
            Fragment.encode(DuckDbTypes.integer, unsaved.empNumber()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.varchar, unsaved.empSuffix()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.varchar, unsaved.deptCode()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.varchar, unsaved.deptRegion()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.varchar, unsaved.empName()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.numeric.opt(), unsaved.salary()),
            Fragment.lit(", "),
            Fragment.encode(DuckDbTypes.date, unsaved.hireDate()),
            Fragment.lit(
                ")\n"
                    + "ON CONFLICT (\"emp_number\", \"emp_suffix\")\n"
                    + "DO UPDATE SET\n"
                    + "  \"dept_code\" = EXCLUDED.\"dept_code\",\n"
                    + "\"dept_region\" = EXCLUDED.\"dept_region\",\n"
                    + "\"emp_name\" = EXCLUDED.\"emp_name\",\n"
                    + "\"salary\" = EXCLUDED.\"salary\",\n"
                    + "\"hire_date\" = EXCLUDED.\"hire_date\"\n"
                    + "RETURNING \"emp_number\", \"emp_suffix\", \"dept_code\", \"dept_region\","
                    + " \"emp_name\", \"salary\", \"hire_date\""))
        .updateReturning(EmployeesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<EmployeesRow> upsertBatch(Iterator<EmployeesRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "INSERT INTO \"employees\"(\"emp_number\", \"emp_suffix\", \"dept_code\","
                    + " \"dept_region\", \"emp_name\", \"salary\", \"hire_date\")\n"
                    + "VALUES (?, ?, ?, ?, ?, ?, ?)\n"
                    + "ON CONFLICT (\"emp_number\", \"emp_suffix\")\n"
                    + "DO UPDATE SET\n"
                    + "  \"dept_code\" = EXCLUDED.\"dept_code\",\n"
                    + "\"dept_region\" = EXCLUDED.\"dept_region\",\n"
                    + "\"emp_name\" = EXCLUDED.\"emp_name\",\n"
                    + "\"salary\" = EXCLUDED.\"salary\",\n"
                    + "\"hire_date\" = EXCLUDED.\"hire_date\"\n"
                    + "RETURNING \"emp_number\", \"emp_suffix\", \"dept_code\", \"dept_region\","
                    + " \"emp_name\", \"salary\", \"hire_date\""))
        .updateReturningEach(EmployeesRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
