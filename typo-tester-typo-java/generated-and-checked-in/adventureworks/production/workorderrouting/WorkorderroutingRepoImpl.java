/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.workorderrouting;

import adventureworks.customtypes.TypoLocalDateTime;
import adventureworks.customtypes.TypoShort;
import adventureworks.production.location.LocationId;
import adventureworks.production.workorder.WorkorderId;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import typo.dsl.DeleteBuilder;
import typo.dsl.Dialect;
import typo.dsl.SelectBuilder;
import typo.dsl.UpdateBuilder;
import typo.runtime.Fragment;
import typo.runtime.Fragment.Literal;
import typo.runtime.PgTypes;
import typo.runtime.internal.arrayMap;
import typo.runtime.streamingInsert;
import static typo.runtime.Fragment.interpolate;
import static typo.runtime.internal.stringInterpolator.str;

public class WorkorderroutingRepoImpl implements WorkorderroutingRepo {
  @Override
  public DeleteBuilder<WorkorderroutingFields, WorkorderroutingRow> delete() {
    return DeleteBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure(), Dialect.POSTGRESQL);
  };

  @Override
  public Boolean deleteById(
    WorkorderroutingId compositeId,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
      delete from "production"."workorderrouting" where "workorderid" = 
      """),
      WorkorderId.pgType.encode(compositeId.workorderid()),
      typo.runtime.Fragment.lit("""
       AND "productid" = 
      """),
      PgTypes.int4.encode(compositeId.productid()),
      typo.runtime.Fragment.lit("""
       AND "operationsequence" = 
      """),
      TypoShort.pgType.encode(compositeId.operationsequence()),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0;
  };

  @Override
  public Integer deleteByIds(
    WorkorderroutingId[] compositeIds,
    Connection c
  ) {
    WorkorderId[] workorderid = arrayMap.map(compositeIds, WorkorderroutingId::workorderid, WorkorderId.class);;
    Integer[] productid = arrayMap.map(compositeIds, WorkorderroutingId::productid, Integer.class);;
    TypoShort[] operationsequence = arrayMap.map(compositeIds, WorkorderroutingId::operationsequence, TypoShort.class);;
    return interpolate(
      typo.runtime.Fragment.lit("""
         delete
         from "production"."workorderrouting"
         where ("workorderid", "productid", "operationsequence")
         in (select unnest("""),
      WorkorderId.pgTypeArray.encode(workorderid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      PgTypes.int4Array.encode(productid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      TypoShort.pgTypeArray.encode(operationsequence),
      typo.runtime.Fragment.lit("""
      ::int2[]))

      """)
    ).update().runUnchecked(c);
  };

  @Override
  public WorkorderroutingRow insert(
    WorkorderroutingRow unsaved,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
         insert into "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate")
         values ("""),
      WorkorderId.pgType.encode(unsaved.workorderid()),
      typo.runtime.Fragment.lit("::int4, "),
      PgTypes.int4.encode(unsaved.productid()),
      typo.runtime.Fragment.lit("::int4, "),
      TypoShort.pgType.encode(unsaved.operationsequence()),
      typo.runtime.Fragment.lit("::int2, "),
      LocationId.pgType.encode(unsaved.locationid()),
      typo.runtime.Fragment.lit("::int2, "),
      TypoLocalDateTime.pgType.encode(unsaved.scheduledstartdate()),
      typo.runtime.Fragment.lit("::timestamp, "),
      TypoLocalDateTime.pgType.encode(unsaved.scheduledenddate()),
      typo.runtime.Fragment.lit("::timestamp, "),
      TypoLocalDateTime.pgType.opt().encode(unsaved.actualstartdate()),
      typo.runtime.Fragment.lit("::timestamp, "),
      TypoLocalDateTime.pgType.opt().encode(unsaved.actualenddate()),
      typo.runtime.Fragment.lit("::timestamp, "),
      PgTypes.numeric.opt().encode(unsaved.actualresourcehrs()),
      typo.runtime.Fragment.lit("::numeric, "),
      PgTypes.numeric.encode(unsaved.plannedcost()),
      typo.runtime.Fragment.lit("::numeric, "),
      PgTypes.numeric.opt().encode(unsaved.actualcost()),
      typo.runtime.Fragment.lit("::numeric, "),
      TypoLocalDateTime.pgType.encode(unsaved.modifieddate()),
      typo.runtime.Fragment.lit("""
         ::timestamp)
         returning "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
      """)
    )
      .updateReturning(WorkorderroutingRow._rowParser.exactlyOne()).runUnchecked(c);
  };

  @Override
  public WorkorderroutingRow insert(
    WorkorderroutingRowUnsaved unsaved,
    Connection c
  ) {
    ArrayList<Literal> columns = new ArrayList<Literal>();;
    ArrayList<Fragment> values = new ArrayList<Fragment>();;
    columns.add(Fragment.lit("\"workorderid\""));
    values.add(interpolate(
      WorkorderId.pgType.encode(unsaved.workorderid()),
      typo.runtime.Fragment.lit("::int4")
    ));
    columns.add(Fragment.lit("\"productid\""));
    values.add(interpolate(
      PgTypes.int4.encode(unsaved.productid()),
      typo.runtime.Fragment.lit("::int4")
    ));
    columns.add(Fragment.lit("\"operationsequence\""));
    values.add(interpolate(
      TypoShort.pgType.encode(unsaved.operationsequence()),
      typo.runtime.Fragment.lit("::int2")
    ));
    columns.add(Fragment.lit("\"locationid\""));
    values.add(interpolate(
      LocationId.pgType.encode(unsaved.locationid()),
      typo.runtime.Fragment.lit("::int2")
    ));
    columns.add(Fragment.lit("\"scheduledstartdate\""));
    values.add(interpolate(
      TypoLocalDateTime.pgType.encode(unsaved.scheduledstartdate()),
      typo.runtime.Fragment.lit("::timestamp")
    ));
    columns.add(Fragment.lit("\"scheduledenddate\""));
    values.add(interpolate(
      TypoLocalDateTime.pgType.encode(unsaved.scheduledenddate()),
      typo.runtime.Fragment.lit("::timestamp")
    ));
    columns.add(Fragment.lit("\"actualstartdate\""));
    values.add(interpolate(
      TypoLocalDateTime.pgType.opt().encode(unsaved.actualstartdate()),
      typo.runtime.Fragment.lit("::timestamp")
    ));
    columns.add(Fragment.lit("\"actualenddate\""));
    values.add(interpolate(
      TypoLocalDateTime.pgType.opt().encode(unsaved.actualenddate()),
      typo.runtime.Fragment.lit("::timestamp")
    ));
    columns.add(Fragment.lit("\"actualresourcehrs\""));
    values.add(interpolate(
      PgTypes.numeric.opt().encode(unsaved.actualresourcehrs()),
      typo.runtime.Fragment.lit("::numeric")
    ));
    columns.add(Fragment.lit("\"plannedcost\""));
    values.add(interpolate(
      PgTypes.numeric.encode(unsaved.plannedcost()),
      typo.runtime.Fragment.lit("::numeric")
    ));
    columns.add(Fragment.lit("\"actualcost\""));
    values.add(interpolate(
      PgTypes.numeric.opt().encode(unsaved.actualcost()),
      typo.runtime.Fragment.lit("::numeric")
    ));
    unsaved.modifieddate().visit(
      () -> {
  
      },
      value -> {
        columns.add(Fragment.lit("\"modifieddate\""));
        values.add(interpolate(
        TypoLocalDateTime.pgType.encode(value),
        typo.runtime.Fragment.lit("::timestamp")
      ));
      }
    );;
    Fragment q = interpolate(
      typo.runtime.Fragment.lit("""
      insert into "production"."workorderrouting"(
      """),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
         )
         values ("""),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
         )
         returning "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
      """)
    );;
    return q.updateReturning(WorkorderroutingRow._rowParser.exactlyOne()).runUnchecked(c);
  };

  @Override
  public Long insertStreaming(
    Iterator<WorkorderroutingRow> unsaved,
    Integer batchSize,
    Connection c
  ) {
    return streamingInsert.insertUnchecked(str("""
    COPY "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate") FROM STDIN
    """), batchSize, unsaved, c, WorkorderroutingRow.pgText);
  };

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  @Override
  public Long insertUnsavedStreaming(
    Iterator<WorkorderroutingRowUnsaved> unsaved,
    Integer batchSize,
    Connection c
  ) {
    return streamingInsert.insertUnchecked(str("""
    COPY "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')
    """), batchSize, unsaved, c, WorkorderroutingRowUnsaved.pgText);
  };

  @Override
  public SelectBuilder<WorkorderroutingFields, WorkorderroutingRow> select() {
    return SelectBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure(), WorkorderroutingRow._rowParser, Dialect.POSTGRESQL);
  };

  @Override
  public List<WorkorderroutingRow> selectAll(Connection c) {
    return interpolate(typo.runtime.Fragment.lit("""
       select "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
       from "production"."workorderrouting"
    """)).query(WorkorderroutingRow._rowParser.all()).runUnchecked(c);
  };

  @Override
  public Optional<WorkorderroutingRow> selectById(
    WorkorderroutingId compositeId,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
         select "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
         from "production"."workorderrouting"
         where "workorderid" = """),
      WorkorderId.pgType.encode(compositeId.workorderid()),
      typo.runtime.Fragment.lit("""
       AND "productid" = 
      """),
      PgTypes.int4.encode(compositeId.productid()),
      typo.runtime.Fragment.lit("""
       AND "operationsequence" = 
      """),
      TypoShort.pgType.encode(compositeId.operationsequence()),
      typo.runtime.Fragment.lit("")
    ).query(WorkorderroutingRow._rowParser.first()).runUnchecked(c);
  };

  @Override
  public List<WorkorderroutingRow> selectByIds(
    WorkorderroutingId[] compositeIds,
    Connection c
  ) {
    WorkorderId[] workorderid = arrayMap.map(compositeIds, WorkorderroutingId::workorderid, WorkorderId.class);;
    Integer[] productid = arrayMap.map(compositeIds, WorkorderroutingId::productid, Integer.class);;
    TypoShort[] operationsequence = arrayMap.map(compositeIds, WorkorderroutingId::operationsequence, TypoShort.class);;
    return interpolate(
      typo.runtime.Fragment.lit("""
         select "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
         from "production"."workorderrouting"
         where ("workorderid", "productid", "operationsequence")
         in (select unnest("""),
      WorkorderId.pgTypeArray.encode(workorderid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      PgTypes.int4Array.encode(productid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      TypoShort.pgTypeArray.encode(operationsequence),
      typo.runtime.Fragment.lit("""
      ::int2[]))

      """)
    ).query(WorkorderroutingRow._rowParser.all()).runUnchecked(c);
  };

  @Override
  public Map<WorkorderroutingId, WorkorderroutingRow> selectByIdsTracked(
    WorkorderroutingId[] compositeIds,
    Connection c
  ) {
    HashMap<WorkorderroutingId, WorkorderroutingRow> ret = new HashMap<WorkorderroutingId, WorkorderroutingRow>();
    selectByIds(compositeIds, c).forEach(row -> ret.put(row.compositeId(), row));
    return ret;
  };

  @Override
  public UpdateBuilder<WorkorderroutingFields, WorkorderroutingRow> update() {
    return UpdateBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure(), WorkorderroutingRow._rowParser.all(), Dialect.POSTGRESQL);
  };

  @Override
  public Boolean update(
    WorkorderroutingRow row,
    Connection c
  ) {
    WorkorderroutingId compositeId = row.compositeId();;
    return interpolate(
      typo.runtime.Fragment.lit("""
         update "production"."workorderrouting"
         set "locationid" = """),
      LocationId.pgType.encode(row.locationid()),
      typo.runtime.Fragment.lit("""
         ::int2,
         "scheduledstartdate" = """),
      TypoLocalDateTime.pgType.encode(row.scheduledstartdate()),
      typo.runtime.Fragment.lit("""
         ::timestamp,
         "scheduledenddate" = """),
      TypoLocalDateTime.pgType.encode(row.scheduledenddate()),
      typo.runtime.Fragment.lit("""
         ::timestamp,
         "actualstartdate" = """),
      TypoLocalDateTime.pgType.opt().encode(row.actualstartdate()),
      typo.runtime.Fragment.lit("""
         ::timestamp,
         "actualenddate" = """),
      TypoLocalDateTime.pgType.opt().encode(row.actualenddate()),
      typo.runtime.Fragment.lit("""
         ::timestamp,
         "actualresourcehrs" = """),
      PgTypes.numeric.opt().encode(row.actualresourcehrs()),
      typo.runtime.Fragment.lit("""
         ::numeric,
         "plannedcost" = """),
      PgTypes.numeric.encode(row.plannedcost()),
      typo.runtime.Fragment.lit("""
         ::numeric,
         "actualcost" = """),
      PgTypes.numeric.opt().encode(row.actualcost()),
      typo.runtime.Fragment.lit("""
         ::numeric,
         "modifieddate" = """),
      TypoLocalDateTime.pgType.encode(row.modifieddate()),
      typo.runtime.Fragment.lit("""
         ::timestamp
         where "workorderid" = """),
      WorkorderId.pgType.encode(compositeId.workorderid()),
      typo.runtime.Fragment.lit("""
       AND "productid" = 
      """),
      PgTypes.int4.encode(compositeId.productid()),
      typo.runtime.Fragment.lit("""
       AND "operationsequence" = 
      """),
      TypoShort.pgType.encode(compositeId.operationsequence()),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0;
  };

  @Override
  public WorkorderroutingRow upsert(
    WorkorderroutingRow unsaved,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
         insert into "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate")
         values ("""),
      WorkorderId.pgType.encode(unsaved.workorderid()),
      typo.runtime.Fragment.lit("::int4, "),
      PgTypes.int4.encode(unsaved.productid()),
      typo.runtime.Fragment.lit("::int4, "),
      TypoShort.pgType.encode(unsaved.operationsequence()),
      typo.runtime.Fragment.lit("::int2, "),
      LocationId.pgType.encode(unsaved.locationid()),
      typo.runtime.Fragment.lit("::int2, "),
      TypoLocalDateTime.pgType.encode(unsaved.scheduledstartdate()),
      typo.runtime.Fragment.lit("::timestamp, "),
      TypoLocalDateTime.pgType.encode(unsaved.scheduledenddate()),
      typo.runtime.Fragment.lit("::timestamp, "),
      TypoLocalDateTime.pgType.opt().encode(unsaved.actualstartdate()),
      typo.runtime.Fragment.lit("::timestamp, "),
      TypoLocalDateTime.pgType.opt().encode(unsaved.actualenddate()),
      typo.runtime.Fragment.lit("::timestamp, "),
      PgTypes.numeric.opt().encode(unsaved.actualresourcehrs()),
      typo.runtime.Fragment.lit("::numeric, "),
      PgTypes.numeric.encode(unsaved.plannedcost()),
      typo.runtime.Fragment.lit("::numeric, "),
      PgTypes.numeric.opt().encode(unsaved.actualcost()),
      typo.runtime.Fragment.lit("::numeric, "),
      TypoLocalDateTime.pgType.encode(unsaved.modifieddate()),
      typo.runtime.Fragment.lit("""
         ::timestamp)
         on conflict ("workorderid", "productid", "operationsequence")
         do update set
           "locationid" = EXCLUDED."locationid",
         "scheduledstartdate" = EXCLUDED."scheduledstartdate",
         "scheduledenddate" = EXCLUDED."scheduledenddate",
         "actualstartdate" = EXCLUDED."actualstartdate",
         "actualenddate" = EXCLUDED."actualenddate",
         "actualresourcehrs" = EXCLUDED."actualresourcehrs",
         "plannedcost" = EXCLUDED."plannedcost",
         "actualcost" = EXCLUDED."actualcost",
         "modifieddate" = EXCLUDED."modifieddate"
         returning "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text""")
    )
      .updateReturning(WorkorderroutingRow._rowParser.exactlyOne())
      .runUnchecked(c);
  };

  @Override
  public List<WorkorderroutingRow> upsertBatch(
    Iterator<WorkorderroutingRow> unsaved,
    Connection c
  ) {
    return interpolate(typo.runtime.Fragment.lit("""
                insert into "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate")
                values (?::int4, ?::int4, ?::int2, ?::int2, ?::timestamp, ?::timestamp, ?::timestamp, ?::timestamp, ?::numeric, ?::numeric, ?::numeric, ?::timestamp)
                on conflict ("workorderid", "productid", "operationsequence")
                do update set
                  "locationid" = EXCLUDED."locationid",
                "scheduledstartdate" = EXCLUDED."scheduledstartdate",
                "scheduledenddate" = EXCLUDED."scheduledenddate",
                "actualstartdate" = EXCLUDED."actualstartdate",
                "actualenddate" = EXCLUDED."actualenddate",
                "actualresourcehrs" = EXCLUDED."actualresourcehrs",
                "plannedcost" = EXCLUDED."plannedcost",
                "actualcost" = EXCLUDED."actualcost",
                "modifieddate" = EXCLUDED."modifieddate"
                returning "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text"""))
      .updateManyReturning(WorkorderroutingRow._rowParser, unsaved)
      .runUnchecked(c);
  };

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  @Override
  public Integer upsertStreaming(
    Iterator<WorkorderroutingRow> unsaved,
    Integer batchSize,
    Connection c
  ) {
    interpolate(typo.runtime.Fragment.lit("""
    create temporary table workorderrouting_TEMP (like "production"."workorderrouting") on commit drop
    """)).update().runUnchecked(c);
    streamingInsert.insertUnchecked(str("""
    copy workorderrouting_TEMP("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate") from stdin
    """), batchSize, unsaved, c, WorkorderroutingRow.pgText);
    return interpolate(typo.runtime.Fragment.lit("""
       insert into "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate")
       select * from workorderrouting_TEMP
       on conflict ("workorderid", "productid", "operationsequence")
       do update set
         "locationid" = EXCLUDED."locationid",
       "scheduledstartdate" = EXCLUDED."scheduledstartdate",
       "scheduledenddate" = EXCLUDED."scheduledenddate",
       "actualstartdate" = EXCLUDED."actualstartdate",
       "actualenddate" = EXCLUDED."actualenddate",
       "actualresourcehrs" = EXCLUDED."actualresourcehrs",
       "plannedcost" = EXCLUDED."plannedcost",
       "actualcost" = EXCLUDED."actualcost",
       "modifieddate" = EXCLUDED."modifieddate"
       ;
       drop table workorderrouting_TEMP;""")).update().runUnchecked(c);
  };
}