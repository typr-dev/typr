/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.public_.pgtest;

import adventureworks.public_.Mydomain;
import adventureworks.public_.Myenum;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.postgresql.geometric.PGbox;
import org.postgresql.geometric.PGcircle;
import org.postgresql.geometric.PGline;
import org.postgresql.geometric.PGlseg;
import org.postgresql.geometric.PGpath;
import org.postgresql.geometric.PGpoint;
import org.postgresql.geometric.PGpolygon;
import org.postgresql.util.PGInterval;
import typo.data.Inet;
import typo.data.Int2Vector;
import typo.data.Json;
import typo.data.Jsonb;
import typo.data.Money;
import typo.data.Vector;
import typo.data.Xml;
import typo.dsl.FieldsExpr;
import typo.dsl.Path;
import typo.dsl.RelationStructure;
import typo.dsl.SqlExpr.Field;
import typo.dsl.SqlExpr.FieldLike;
import typo.runtime.PgTypes;
import typo.runtime.RowParser;

public interface PgtestFields extends FieldsExpr<PgtestRow> {
  record Impl(List<Path> _path) implements PgtestFields, RelationStructure<PgtestFields, PgtestRow> {
    @Override
    public Field<Boolean, PgtestRow> bool() {
      return new Field<Boolean, PgtestRow>(_path, "bool", PgtestRow::bool, Optional.empty(), Optional.empty(), (row, value) -> row.withBool(value), PgTypes.bool);
    };

    @Override
    public Field<PGbox, PgtestRow> box() {
      return new Field<PGbox, PgtestRow>(_path, "box", PgtestRow::box, Optional.empty(), Optional.of("box"), (row, value) -> row.withBox(value), PgTypes.box);
    };

    @Override
    public Field<String, PgtestRow> bpchar() {
      return new Field<String, PgtestRow>(_path, "bpchar", PgtestRow::bpchar, Optional.empty(), Optional.of("bpchar"), (row, value) -> row.withBpchar(value), PgTypes.bpchar);
    };

    @Override
    public Field<byte[], PgtestRow> bytea() {
      return new Field<byte[], PgtestRow>(_path, "bytea", PgtestRow::bytea, Optional.empty(), Optional.of("bytea"), (row, value) -> row.withBytea(value), PgTypes.bytea);
    };

    @Override
    public Field<String, PgtestRow> char_() {
      return new Field<String, PgtestRow>(_path, "char", PgtestRow::char_, Optional.empty(), Optional.of("bpchar"), (row, value) -> row.withChar(value), PgTypes.bpchar);
    };

    @Override
    public Field<PGcircle, PgtestRow> circle() {
      return new Field<PGcircle, PgtestRow>(_path, "circle", PgtestRow::circle, Optional.empty(), Optional.of("circle"), (row, value) -> row.withCircle(value), PgTypes.circle);
    };

    @Override
    public Field<LocalDate, PgtestRow> date() {
      return new Field<LocalDate, PgtestRow>(_path, "date", PgtestRow::date, Optional.empty(), Optional.of("date"), (row, value) -> row.withDate(value), PgTypes.date);
    };

    @Override
    public Field<Float, PgtestRow> float4() {
      return new Field<Float, PgtestRow>(_path, "float4", PgtestRow::float4, Optional.empty(), Optional.of("float4"), (row, value) -> row.withFloat4(value), PgTypes.float4);
    };

    @Override
    public Field<Double, PgtestRow> float8() {
      return new Field<Double, PgtestRow>(_path, "float8", PgtestRow::float8, Optional.empty(), Optional.of("float8"), (row, value) -> row.withFloat8(value), PgTypes.float8);
    };

    @Override
    public Field<Map<String, String>, PgtestRow> hstore() {
      return new Field<Map<String, String>, PgtestRow>(_path, "hstore", PgtestRow::hstore, Optional.empty(), Optional.of("hstore"), (row, value) -> row.withHstore(value), PgTypes.hstore);
    };

    @Override
    public Field<Inet, PgtestRow> inet() {
      return new Field<Inet, PgtestRow>(_path, "inet", PgtestRow::inet, Optional.empty(), Optional.of("inet"), (row, value) -> row.withInet(value), PgTypes.inet);
    };

    @Override
    public Field<Short, PgtestRow> int2() {
      return new Field<Short, PgtestRow>(_path, "int2", PgtestRow::int2, Optional.empty(), Optional.of("int2"), (row, value) -> row.withInt2(value), PgTypes.int2);
    };

    @Override
    public Field<Int2Vector, PgtestRow> int2vector() {
      return new Field<Int2Vector, PgtestRow>(_path, "int2vector", PgtestRow::int2vector, Optional.empty(), Optional.of("int2vector"), (row, value) -> row.withInt2vector(value), PgTypes.int2vector);
    };

    @Override
    public Field<Integer, PgtestRow> int4() {
      return new Field<Integer, PgtestRow>(_path, "int4", PgtestRow::int4, Optional.empty(), Optional.of("int4"), (row, value) -> row.withInt4(value), PgTypes.int4);
    };

    @Override
    public Field<Long, PgtestRow> int8() {
      return new Field<Long, PgtestRow>(_path, "int8", PgtestRow::int8, Optional.empty(), Optional.of("int8"), (row, value) -> row.withInt8(value), PgTypes.int8);
    };

    @Override
    public Field<PGInterval, PgtestRow> interval() {
      return new Field<PGInterval, PgtestRow>(_path, "interval", PgtestRow::interval, Optional.empty(), Optional.of("interval"), (row, value) -> row.withInterval(value), PgTypes.interval);
    };

    @Override
    public Field<Json, PgtestRow> json() {
      return new Field<Json, PgtestRow>(_path, "json", PgtestRow::json, Optional.empty(), Optional.of("json"), (row, value) -> row.withJson(value), PgTypes.json);
    };

    @Override
    public Field<Jsonb, PgtestRow> jsonb() {
      return new Field<Jsonb, PgtestRow>(_path, "jsonb", PgtestRow::jsonb, Optional.empty(), Optional.of("jsonb"), (row, value) -> row.withJsonb(value), PgTypes.jsonb);
    };

    @Override
    public Field<PGline, PgtestRow> line() {
      return new Field<PGline, PgtestRow>(_path, "line", PgtestRow::line, Optional.empty(), Optional.of("line"), (row, value) -> row.withLine(value), PgTypes.line);
    };

    @Override
    public Field<PGlseg, PgtestRow> lseg() {
      return new Field<PGlseg, PgtestRow>(_path, "lseg", PgtestRow::lseg, Optional.empty(), Optional.of("lseg"), (row, value) -> row.withLseg(value), PgTypes.lseg);
    };

    @Override
    public Field<Money, PgtestRow> money() {
      return new Field<Money, PgtestRow>(_path, "money", PgtestRow::money, Optional.of("numeric"), Optional.of("money"), (row, value) -> row.withMoney(value), PgTypes.money);
    };

    @Override
    public Field<Mydomain, PgtestRow> mydomain() {
      return new Field<Mydomain, PgtestRow>(_path, "mydomain", PgtestRow::mydomain, Optional.empty(), Optional.of("text"), (row, value) -> row.withMydomain(value), Mydomain.pgType);
    };

    @Override
    public Field<Myenum, PgtestRow> myenum() {
      return new Field<Myenum, PgtestRow>(_path, "myenum", PgtestRow::myenum, Optional.empty(), Optional.of("public.myenum"), (row, value) -> row.withMyenum(value), Myenum.pgType);
    };

    @Override
    public Field<String, PgtestRow> name() {
      return new Field<String, PgtestRow>(_path, "name", PgtestRow::name, Optional.empty(), Optional.of("name"), (row, value) -> row.withName(value), PgTypes.name);
    };

    @Override
    public Field<BigDecimal, PgtestRow> numeric() {
      return new Field<BigDecimal, PgtestRow>(_path, "numeric", PgtestRow::numeric, Optional.empty(), Optional.of("numeric"), (row, value) -> row.withNumeric(value), PgTypes.numeric);
    };

    @Override
    public Field<PGpath, PgtestRow> path() {
      return new Field<PGpath, PgtestRow>(_path, "path", PgtestRow::path, Optional.empty(), Optional.of("path"), (row, value) -> row.withPath(value), PgTypes.path);
    };

    @Override
    public Field<PGpoint, PgtestRow> point() {
      return new Field<PGpoint, PgtestRow>(_path, "point", PgtestRow::point, Optional.empty(), Optional.of("point"), (row, value) -> row.withPoint(value), PgTypes.point);
    };

    @Override
    public Field<PGpolygon, PgtestRow> polygon() {
      return new Field<PGpolygon, PgtestRow>(_path, "polygon", PgtestRow::polygon, Optional.empty(), Optional.of("polygon"), (row, value) -> row.withPolygon(value), PgTypes.polygon);
    };

    @Override
    public Field<String, PgtestRow> text() {
      return new Field<String, PgtestRow>(_path, "text", PgtestRow::text, Optional.empty(), Optional.empty(), (row, value) -> row.withText(value), PgTypes.text);
    };

    @Override
    public Field<LocalTime, PgtestRow> time() {
      return new Field<LocalTime, PgtestRow>(_path, "time", PgtestRow::time, Optional.empty(), Optional.of("time"), (row, value) -> row.withTime(value), PgTypes.time);
    };

    @Override
    public Field<LocalDateTime, PgtestRow> timestamp() {
      return new Field<LocalDateTime, PgtestRow>(_path, "timestamp", PgtestRow::timestamp, Optional.empty(), Optional.of("timestamp"), (row, value) -> row.withTimestamp(value), PgTypes.timestamp);
    };

    @Override
    public Field<Instant, PgtestRow> timestampz() {
      return new Field<Instant, PgtestRow>(_path, "timestampz", PgtestRow::timestampz, Optional.empty(), Optional.of("timestamptz"), (row, value) -> row.withTimestampz(value), PgTypes.timestamptz);
    };

    @Override
    public Field<OffsetTime, PgtestRow> timez() {
      return new Field<OffsetTime, PgtestRow>(_path, "timez", PgtestRow::timez, Optional.empty(), Optional.of("timetz"), (row, value) -> row.withTimez(value), PgTypes.timetz);
    };

    @Override
    public Field<UUID, PgtestRow> uuid() {
      return new Field<UUID, PgtestRow>(_path, "uuid", PgtestRow::uuid, Optional.empty(), Optional.of("uuid"), (row, value) -> row.withUuid(value), PgTypes.uuid);
    };

    @Override
    public Field<String, PgtestRow> varchar() {
      return new Field<String, PgtestRow>(_path, "varchar", PgtestRow::varchar, Optional.empty(), Optional.empty(), (row, value) -> row.withVarchar(value), PgTypes.text);
    };

    @Override
    public Field<Vector, PgtestRow> vector() {
      return new Field<Vector, PgtestRow>(_path, "vector", PgtestRow::vector, Optional.empty(), Optional.of("vector"), (row, value) -> row.withVector(value), PgTypes.vector);
    };

    @Override
    public Field<Xml, PgtestRow> xml() {
      return new Field<Xml, PgtestRow>(_path, "xml", PgtestRow::xml, Optional.empty(), Optional.of("xml"), (row, value) -> row.withXml(value), PgTypes.xml);
    };

    @Override
    public Field<PGbox[], PgtestRow> boxes() {
      return new Field<PGbox[], PgtestRow>(_path, "boxes", PgtestRow::boxes, Optional.empty(), Optional.of("box[]"), (row, value) -> row.withBoxes(value), PgTypes.boxArray);
    };

    @Override
    public Field</* bpchar */ String[], PgtestRow> bpchares() {
      return new Field</* bpchar */ String[], PgtestRow>(_path, "bpchares", PgtestRow::bpchares, Optional.empty(), Optional.of("bpchar[]"), (row, value) -> row.withBpchares(value), PgTypes.bpcharArray);
    };

    @Override
    public Field</* bpchar */ String[], PgtestRow> chares() {
      return new Field</* bpchar */ String[], PgtestRow>(_path, "chares", PgtestRow::chares, Optional.empty(), Optional.of("bpchar[]"), (row, value) -> row.withChares(value), PgTypes.bpcharArray);
    };

    @Override
    public Field<PGcircle[], PgtestRow> circlees() {
      return new Field<PGcircle[], PgtestRow>(_path, "circlees", PgtestRow::circlees, Optional.empty(), Optional.of("circle[]"), (row, value) -> row.withCirclees(value), PgTypes.circleArray);
    };

    @Override
    public Field<LocalDate[], PgtestRow> datees() {
      return new Field<LocalDate[], PgtestRow>(_path, "datees", PgtestRow::datees, Optional.empty(), Optional.of("date[]"), (row, value) -> row.withDatees(value), PgTypes.dateArray);
    };

    @Override
    public Field<Float[], PgtestRow> float4es() {
      return new Field<Float[], PgtestRow>(_path, "float4es", PgtestRow::float4es, Optional.empty(), Optional.of("float4[]"), (row, value) -> row.withFloat4es(value), PgTypes.float4Array);
    };

    @Override
    public Field<Double[], PgtestRow> float8es() {
      return new Field<Double[], PgtestRow>(_path, "float8es", PgtestRow::float8es, Optional.empty(), Optional.of("float8[]"), (row, value) -> row.withFloat8es(value), PgTypes.float8Array);
    };

    @Override
    public Field<Inet[], PgtestRow> inetes() {
      return new Field<Inet[], PgtestRow>(_path, "inetes", PgtestRow::inetes, Optional.empty(), Optional.of("inet[]"), (row, value) -> row.withInetes(value), PgTypes.inetArray);
    };

    @Override
    public Field<Short[], PgtestRow> int2es() {
      return new Field<Short[], PgtestRow>(_path, "int2es", PgtestRow::int2es, Optional.empty(), Optional.of("int2[]"), (row, value) -> row.withInt2es(value), PgTypes.int2Array);
    };

    @Override
    public Field<Int2Vector[], PgtestRow> int2vectores() {
      return new Field<Int2Vector[], PgtestRow>(_path, "int2vectores", PgtestRow::int2vectores, Optional.empty(), Optional.of("int2vector[]"), (row, value) -> row.withInt2vectores(value), PgTypes.int2vectorArray);
    };

    @Override
    public Field<Integer[], PgtestRow> int4es() {
      return new Field<Integer[], PgtestRow>(_path, "int4es", PgtestRow::int4es, Optional.empty(), Optional.of("int4[]"), (row, value) -> row.withInt4es(value), PgTypes.int4Array);
    };

    @Override
    public Field<Long[], PgtestRow> int8es() {
      return new Field<Long[], PgtestRow>(_path, "int8es", PgtestRow::int8es, Optional.empty(), Optional.of("int8[]"), (row, value) -> row.withInt8es(value), PgTypes.int8Array);
    };

    @Override
    public Field<PGInterval[], PgtestRow> intervales() {
      return new Field<PGInterval[], PgtestRow>(_path, "intervales", PgtestRow::intervales, Optional.empty(), Optional.of("interval[]"), (row, value) -> row.withIntervales(value), PgTypes.intervalArray);
    };

    @Override
    public Field<Json[], PgtestRow> jsones() {
      return new Field<Json[], PgtestRow>(_path, "jsones", PgtestRow::jsones, Optional.empty(), Optional.of("json[]"), (row, value) -> row.withJsones(value), PgTypes.jsonArray);
    };

    @Override
    public Field<Jsonb[], PgtestRow> jsonbes() {
      return new Field<Jsonb[], PgtestRow>(_path, "jsonbes", PgtestRow::jsonbes, Optional.empty(), Optional.of("jsonb[]"), (row, value) -> row.withJsonbes(value), PgTypes.jsonbArray);
    };

    @Override
    public Field<PGline[], PgtestRow> linees() {
      return new Field<PGline[], PgtestRow>(_path, "linees", PgtestRow::linees, Optional.empty(), Optional.of("line[]"), (row, value) -> row.withLinees(value), PgTypes.lineArray);
    };

    @Override
    public Field<PGlseg[], PgtestRow> lseges() {
      return new Field<PGlseg[], PgtestRow>(_path, "lseges", PgtestRow::lseges, Optional.empty(), Optional.of("lseg[]"), (row, value) -> row.withLseges(value), PgTypes.lsegArray);
    };

    @Override
    public Field<Money[], PgtestRow> moneyes() {
      return new Field<Money[], PgtestRow>(_path, "moneyes", PgtestRow::moneyes, Optional.of("numeric[]"), Optional.of("money[]"), (row, value) -> row.withMoneyes(value), PgTypes.moneyArray);
    };

    @Override
    public Field<Mydomain[], PgtestRow> mydomaines() {
      return new Field<Mydomain[], PgtestRow>(_path, "mydomaines", PgtestRow::mydomaines, Optional.of("text[]"), Optional.of("mydomain[]"), (row, value) -> row.withMydomaines(value), Mydomain.pgTypeArray);
    };

    @Override
    public Field<Myenum[], PgtestRow> myenumes() {
      return new Field<Myenum[], PgtestRow>(_path, "myenumes", PgtestRow::myenumes, Optional.empty(), Optional.of("myenum[]"), (row, value) -> row.withMyenumes(value), Myenum.pgTypeArray);
    };

    @Override
    public Field<String[], PgtestRow> namees() {
      return new Field<String[], PgtestRow>(_path, "namees", PgtestRow::namees, Optional.empty(), Optional.of("name[]"), (row, value) -> row.withNamees(value), PgTypes.nameArray);
    };

    @Override
    public Field<BigDecimal[], PgtestRow> numerices() {
      return new Field<BigDecimal[], PgtestRow>(_path, "numerices", PgtestRow::numerices, Optional.empty(), Optional.of("numeric[]"), (row, value) -> row.withNumerices(value), PgTypes.numericArray);
    };

    @Override
    public Field<PGpath[], PgtestRow> pathes() {
      return new Field<PGpath[], PgtestRow>(_path, "pathes", PgtestRow::pathes, Optional.empty(), Optional.of("path[]"), (row, value) -> row.withPathes(value), PgTypes.pathArray);
    };

    @Override
    public Field<PGpoint[], PgtestRow> pointes() {
      return new Field<PGpoint[], PgtestRow>(_path, "pointes", PgtestRow::pointes, Optional.empty(), Optional.of("point[]"), (row, value) -> row.withPointes(value), PgTypes.pointArray);
    };

    @Override
    public Field<PGpolygon[], PgtestRow> polygones() {
      return new Field<PGpolygon[], PgtestRow>(_path, "polygones", PgtestRow::polygones, Optional.empty(), Optional.of("polygon[]"), (row, value) -> row.withPolygones(value), PgTypes.polygonArray);
    };

    @Override
    public Field<String[], PgtestRow> textes() {
      return new Field<String[], PgtestRow>(_path, "textes", PgtestRow::textes, Optional.empty(), Optional.of("text[]"), (row, value) -> row.withTextes(value), PgTypes.textArray);
    };

    @Override
    public Field<LocalTime[], PgtestRow> timees() {
      return new Field<LocalTime[], PgtestRow>(_path, "timees", PgtestRow::timees, Optional.empty(), Optional.of("time[]"), (row, value) -> row.withTimees(value), PgTypes.timeArray);
    };

    @Override
    public Field<LocalDateTime[], PgtestRow> timestampes() {
      return new Field<LocalDateTime[], PgtestRow>(_path, "timestampes", PgtestRow::timestampes, Optional.empty(), Optional.of("timestamp[]"), (row, value) -> row.withTimestampes(value), PgTypes.timestampArray);
    };

    @Override
    public Field<Instant[], PgtestRow> timestampzes() {
      return new Field<Instant[], PgtestRow>(_path, "timestampzes", PgtestRow::timestampzes, Optional.empty(), Optional.of("timestamptz[]"), (row, value) -> row.withTimestampzes(value), PgTypes.timestamptzArray);
    };

    @Override
    public Field<OffsetTime[], PgtestRow> timezes() {
      return new Field<OffsetTime[], PgtestRow>(_path, "timezes", PgtestRow::timezes, Optional.empty(), Optional.of("timetz[]"), (row, value) -> row.withTimezes(value), PgTypes.timetzArray);
    };

    @Override
    public Field<UUID[], PgtestRow> uuides() {
      return new Field<UUID[], PgtestRow>(_path, "uuides", PgtestRow::uuides, Optional.empty(), Optional.of("uuid[]"), (row, value) -> row.withUuides(value), PgTypes.uuidArray);
    };

    @Override
    public Field<String[], PgtestRow> varchares() {
      return new Field<String[], PgtestRow>(_path, "varchares", PgtestRow::varchares, Optional.empty(), Optional.of("varchar[]"), (row, value) -> row.withVarchares(value), PgTypes.textArray);
    };

    @Override
    public Field<Xml[], PgtestRow> xmles() {
      return new Field<Xml[], PgtestRow>(_path, "xmles", PgtestRow::xmles, Optional.empty(), Optional.of("xml[]"), (row, value) -> row.withXmles(value), PgTypes.xmlArray);
    };

    @Override
    public List<FieldLike<?, PgtestRow>> columns() {
      return java.util.List.of(this.bool(), this.box(), this.bpchar(), this.bytea(), this.char_(), this.circle(), this.date(), this.float4(), this.float8(), this.hstore(), this.inet(), this.int2(), this.int2vector(), this.int4(), this.int8(), this.interval(), this.json(), this.jsonb(), this.line(), this.lseg(), this.money(), this.mydomain(), this.myenum(), this.name(), this.numeric(), this.path(), this.point(), this.polygon(), this.text(), this.time(), this.timestamp(), this.timestampz(), this.timez(), this.uuid(), this.varchar(), this.vector(), this.xml(), this.boxes(), this.bpchares(), this.chares(), this.circlees(), this.datees(), this.float4es(), this.float8es(), this.inetes(), this.int2es(), this.int2vectores(), this.int4es(), this.int8es(), this.intervales(), this.jsones(), this.jsonbes(), this.linees(), this.lseges(), this.moneyes(), this.mydomaines(), this.myenumes(), this.namees(), this.numerices(), this.pathes(), this.pointes(), this.polygones(), this.textes(), this.timees(), this.timestampes(), this.timestampzes(), this.timezes(), this.uuides(), this.varchares(), this.xmles());
    };

    @Override
    public RelationStructure<PgtestFields, PgtestRow> withPaths(List<Path> _path) {
      return new Impl(_path);
    };
  };

  static Impl structure() {
    return new Impl(java.util.Collections.emptyList());
  };

  Field<Boolean, PgtestRow> bool();

  Field<PGbox, PgtestRow> box();

  Field<String, PgtestRow> bpchar();

  Field<byte[], PgtestRow> bytea();

  Field<String, PgtestRow> char_();

  Field<PGcircle, PgtestRow> circle();

  Field<LocalDate, PgtestRow> date();

  Field<Float, PgtestRow> float4();

  Field<Double, PgtestRow> float8();

  Field<Map<String, String>, PgtestRow> hstore();

  Field<Inet, PgtestRow> inet();

  Field<Short, PgtestRow> int2();

  Field<Int2Vector, PgtestRow> int2vector();

  Field<Integer, PgtestRow> int4();

  Field<Long, PgtestRow> int8();

  Field<PGInterval, PgtestRow> interval();

  Field<Json, PgtestRow> json();

  Field<Jsonb, PgtestRow> jsonb();

  Field<PGline, PgtestRow> line();

  Field<PGlseg, PgtestRow> lseg();

  Field<Money, PgtestRow> money();

  Field<Mydomain, PgtestRow> mydomain();

  Field<Myenum, PgtestRow> myenum();

  Field<String, PgtestRow> name();

  Field<BigDecimal, PgtestRow> numeric();

  Field<PGpath, PgtestRow> path();

  Field<PGpoint, PgtestRow> point();

  Field<PGpolygon, PgtestRow> polygon();

  Field<String, PgtestRow> text();

  Field<LocalTime, PgtestRow> time();

  Field<LocalDateTime, PgtestRow> timestamp();

  Field<Instant, PgtestRow> timestampz();

  Field<OffsetTime, PgtestRow> timez();

  Field<UUID, PgtestRow> uuid();

  Field<String, PgtestRow> varchar();

  Field<Vector, PgtestRow> vector();

  Field<Xml, PgtestRow> xml();

  Field<PGbox[], PgtestRow> boxes();

  Field</* bpchar */ String[], PgtestRow> bpchares();

  Field</* bpchar */ String[], PgtestRow> chares();

  Field<PGcircle[], PgtestRow> circlees();

  Field<LocalDate[], PgtestRow> datees();

  Field<Float[], PgtestRow> float4es();

  Field<Double[], PgtestRow> float8es();

  Field<Inet[], PgtestRow> inetes();

  Field<Short[], PgtestRow> int2es();

  Field<Int2Vector[], PgtestRow> int2vectores();

  Field<Integer[], PgtestRow> int4es();

  Field<Long[], PgtestRow> int8es();

  Field<PGInterval[], PgtestRow> intervales();

  Field<Json[], PgtestRow> jsones();

  Field<Jsonb[], PgtestRow> jsonbes();

  Field<PGline[], PgtestRow> linees();

  Field<PGlseg[], PgtestRow> lseges();

  Field<Money[], PgtestRow> moneyes();

  Field<Mydomain[], PgtestRow> mydomaines();

  Field<Myenum[], PgtestRow> myenumes();

  Field<String[], PgtestRow> namees();

  Field<BigDecimal[], PgtestRow> numerices();

  Field<PGpath[], PgtestRow> pathes();

  Field<PGpoint[], PgtestRow> pointes();

  Field<PGpolygon[], PgtestRow> polygones();

  Field<String[], PgtestRow> textes();

  Field<LocalTime[], PgtestRow> timees();

  Field<LocalDateTime[], PgtestRow> timestampes();

  Field<Instant[], PgtestRow> timestampzes();

  Field<OffsetTime[], PgtestRow> timezes();

  Field<UUID[], PgtestRow> uuides();

  Field<String[], PgtestRow> varchares();

  Field<Xml[], PgtestRow> xmles();

  @Override
  List<FieldLike<?, PgtestRow>> columns();

  @Override
  default RowParser<PgtestRow> rowParser() {
    return PgtestRow._rowParser;
  };
}