/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.public_.users;

import adventureworks.customtypes.TypoInstant;
import adventureworks.customtypes.TypoUnknownCitext;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import typo.dsl.DeleteBuilder;
import typo.dsl.Dialect;
import typo.dsl.SelectBuilder;
import typo.dsl.UpdateBuilder;
import typo.runtime.Fragment;
import typo.runtime.Fragment.Literal;
import typo.runtime.PgTypes;
import typo.runtime.streamingInsert;
import static typo.runtime.Fragment.interpolate;
import static typo.runtime.internal.stringInterpolator.str;

public class UsersRepoImpl implements UsersRepo {
  @Override
  public DeleteBuilder<UsersFields, UsersRow> delete() {
    return DeleteBuilder.of("\"public\".\"users\"", UsersFields.structure(), Dialect.POSTGRESQL);
  };

  @Override
  public Boolean deleteById(
    UsersId userId,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
      delete from "public"."users" where "user_id" = 
      """),
      UsersId.pgType.encode(userId),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0;
  };

  @Override
  public Integer deleteByIds(
    UsersId[] userIds,
    Connection c
  ) {
    return interpolate(
               typo.runtime.Fragment.lit("""
                  delete
                  from "public"."users"
                  where "user_id" = ANY("""),
               UsersId.pgTypeArray.encode(userIds),
               typo.runtime.Fragment.lit(")")
             )
      .update()
      .runUnchecked(c);
  };

  @Override
  public UsersRow insert(
    UsersRow unsaved,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
         insert into "public"."users"("user_id", "name", "last_name", "email", "password", "created_at", "verified_on")
         values ("""),
      UsersId.pgType.encode(unsaved.userId()),
      typo.runtime.Fragment.lit("::uuid, "),
      PgTypes.text.encode(unsaved.name()),
      typo.runtime.Fragment.lit(", "),
      PgTypes.text.opt().encode(unsaved.lastName()),
      typo.runtime.Fragment.lit(", "),
      TypoUnknownCitext.pgType.encode(unsaved.email()),
      typo.runtime.Fragment.lit("::citext, "),
      PgTypes.text.encode(unsaved.password()),
      typo.runtime.Fragment.lit(", "),
      TypoInstant.pgType.encode(unsaved.createdAt()),
      typo.runtime.Fragment.lit("::timestamptz, "),
      TypoInstant.pgType.opt().encode(unsaved.verifiedOn()),
      typo.runtime.Fragment.lit("""
         ::timestamptz)
         returning "user_id", "name", "last_name", "email"::text, "password", "created_at"::text, "verified_on"::text
      """)
    )
      .updateReturning(UsersRow._rowParser.exactlyOne()).runUnchecked(c);
  };

  @Override
  public UsersRow insert(
    UsersRowUnsaved unsaved,
    Connection c
  ) {
    ArrayList<Literal> columns = new ArrayList<Literal>();;
    ArrayList<Fragment> values = new ArrayList<Fragment>();;
    columns.add(Fragment.lit("\"user_id\""));
    values.add(interpolate(
      UsersId.pgType.encode(unsaved.userId()),
      typo.runtime.Fragment.lit("::uuid")
    ));
    columns.add(Fragment.lit("\"name\""));
    values.add(interpolate(
      PgTypes.text.encode(unsaved.name()),
      typo.runtime.Fragment.lit("""
      """)
    ));
    columns.add(Fragment.lit("\"last_name\""));
    values.add(interpolate(
      PgTypes.text.opt().encode(unsaved.lastName()),
      typo.runtime.Fragment.lit("""
      """)
    ));
    columns.add(Fragment.lit("\"email\""));
    values.add(interpolate(
      TypoUnknownCitext.pgType.encode(unsaved.email()),
      typo.runtime.Fragment.lit("::citext")
    ));
    columns.add(Fragment.lit("\"password\""));
    values.add(interpolate(
      PgTypes.text.encode(unsaved.password()),
      typo.runtime.Fragment.lit("""
      """)
    ));
    columns.add(Fragment.lit("\"verified_on\""));
    values.add(interpolate(
      TypoInstant.pgType.opt().encode(unsaved.verifiedOn()),
      typo.runtime.Fragment.lit("::timestamptz")
    ));
    unsaved.createdAt().visit(
      () -> {
  
      },
      value -> {
        columns.add(Fragment.lit("\"created_at\""));
        values.add(interpolate(
        TypoInstant.pgType.encode(value),
        typo.runtime.Fragment.lit("::timestamptz")
      ));
      }
    );;
    Fragment q = interpolate(
      typo.runtime.Fragment.lit("""
      insert into "public"."users"(
      """),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
         )
         values ("""),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
         )
         returning "user_id", "name", "last_name", "email"::text, "password", "created_at"::text, "verified_on"::text
      """)
    );;
    return q.updateReturning(UsersRow._rowParser.exactlyOne()).runUnchecked(c);
  };

  @Override
  public Long insertStreaming(
    Iterator<UsersRow> unsaved,
    Integer batchSize,
    Connection c
  ) {
    return streamingInsert.insertUnchecked(str("""
    COPY "public"."users"("user_id", "name", "last_name", "email", "password", "created_at", "verified_on") FROM STDIN
    """), batchSize, unsaved, c, UsersRow.pgText);
  };

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  @Override
  public Long insertUnsavedStreaming(
    Iterator<UsersRowUnsaved> unsaved,
    Integer batchSize,
    Connection c
  ) {
    return streamingInsert.insertUnchecked(str("""
    COPY "public"."users"("user_id", "name", "last_name", "email", "password", "verified_on", "created_at") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')
    """), batchSize, unsaved, c, UsersRowUnsaved.pgText);
  };

  @Override
  public SelectBuilder<UsersFields, UsersRow> select() {
    return SelectBuilder.of("\"public\".\"users\"", UsersFields.structure(), UsersRow._rowParser, Dialect.POSTGRESQL);
  };

  @Override
  public List<UsersRow> selectAll(Connection c) {
    return interpolate(typo.runtime.Fragment.lit("""
       select "user_id", "name", "last_name", "email"::text, "password", "created_at"::text, "verified_on"::text
       from "public"."users"
    """)).query(UsersRow._rowParser.all()).runUnchecked(c);
  };

  @Override
  public Optional<UsersRow> selectById(
    UsersId userId,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
         select "user_id", "name", "last_name", "email"::text, "password", "created_at"::text, "verified_on"::text
         from "public"."users"
         where "user_id" = """),
      UsersId.pgType.encode(userId),
      typo.runtime.Fragment.lit("")
    ).query(UsersRow._rowParser.first()).runUnchecked(c);
  };

  @Override
  public List<UsersRow> selectByIds(
    UsersId[] userIds,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
         select "user_id", "name", "last_name", "email"::text, "password", "created_at"::text, "verified_on"::text
         from "public"."users"
         where "user_id" = ANY("""),
      UsersId.pgTypeArray.encode(userIds),
      typo.runtime.Fragment.lit(")")
    ).query(UsersRow._rowParser.all()).runUnchecked(c);
  };

  @Override
  public Map<UsersId, UsersRow> selectByIdsTracked(
    UsersId[] userIds,
    Connection c
  ) {
    HashMap<UsersId, UsersRow> ret = new HashMap<UsersId, UsersRow>();
    selectByIds(userIds, c).forEach(row -> ret.put(row.userId(), row));
    return ret;
  };

  @Override
  public Optional<UsersRow> selectByUniqueEmail(
    TypoUnknownCitext email,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
         select "user_id", "name", "last_name", "email"::text, "password", "created_at"::text, "verified_on"::text
         from "public"."users"
         where "email" = """),
      TypoUnknownCitext.pgType.encode(email),
      typo.runtime.Fragment.lit("""


      """)
    ).query(UsersRow._rowParser.first()).runUnchecked(c);
  };

  @Override
  public UpdateBuilder<UsersFields, UsersRow> update() {
    return UpdateBuilder.of("\"public\".\"users\"", UsersFields.structure(), UsersRow._rowParser.all(), Dialect.POSTGRESQL);
  };

  @Override
  public Boolean update(
    UsersRow row,
    Connection c
  ) {
    UsersId userId = row.userId();;
    return interpolate(
      typo.runtime.Fragment.lit("""
         update "public"."users"
         set "name" = """),
      PgTypes.text.encode(row.name()),
      typo.runtime.Fragment.lit("""
         ,
         "last_name" = """),
      PgTypes.text.opt().encode(row.lastName()),
      typo.runtime.Fragment.lit("""
         ,
         "email" = """),
      TypoUnknownCitext.pgType.encode(row.email()),
      typo.runtime.Fragment.lit("""
         ::citext,
         "password" = """),
      PgTypes.text.encode(row.password()),
      typo.runtime.Fragment.lit("""
         ,
         "created_at" = """),
      TypoInstant.pgType.encode(row.createdAt()),
      typo.runtime.Fragment.lit("""
         ::timestamptz,
         "verified_on" = """),
      TypoInstant.pgType.opt().encode(row.verifiedOn()),
      typo.runtime.Fragment.lit("""
         ::timestamptz
         where "user_id" = """),
      UsersId.pgType.encode(userId),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0;
  };

  @Override
  public UsersRow upsert(
    UsersRow unsaved,
    Connection c
  ) {
    return interpolate(
      typo.runtime.Fragment.lit("""
         insert into "public"."users"("user_id", "name", "last_name", "email", "password", "created_at", "verified_on")
         values ("""),
      UsersId.pgType.encode(unsaved.userId()),
      typo.runtime.Fragment.lit("::uuid, "),
      PgTypes.text.encode(unsaved.name()),
      typo.runtime.Fragment.lit(", "),
      PgTypes.text.opt().encode(unsaved.lastName()),
      typo.runtime.Fragment.lit(", "),
      TypoUnknownCitext.pgType.encode(unsaved.email()),
      typo.runtime.Fragment.lit("::citext, "),
      PgTypes.text.encode(unsaved.password()),
      typo.runtime.Fragment.lit(", "),
      TypoInstant.pgType.encode(unsaved.createdAt()),
      typo.runtime.Fragment.lit("::timestamptz, "),
      TypoInstant.pgType.opt().encode(unsaved.verifiedOn()),
      typo.runtime.Fragment.lit("""
         ::timestamptz)
         on conflict ("user_id")
         do update set
           "name" = EXCLUDED."name",
         "last_name" = EXCLUDED."last_name",
         "email" = EXCLUDED."email",
         "password" = EXCLUDED."password",
         "created_at" = EXCLUDED."created_at",
         "verified_on" = EXCLUDED."verified_on"
         returning "user_id", "name", "last_name", "email"::text, "password", "created_at"::text, "verified_on"::text""")
    )
      .updateReturning(UsersRow._rowParser.exactlyOne())
      .runUnchecked(c);
  };

  @Override
  public List<UsersRow> upsertBatch(
    Iterator<UsersRow> unsaved,
    Connection c
  ) {
    return interpolate(typo.runtime.Fragment.lit("""
                insert into "public"."users"("user_id", "name", "last_name", "email", "password", "created_at", "verified_on")
                values (?::uuid, ?, ?, ?::citext, ?, ?::timestamptz, ?::timestamptz)
                on conflict ("user_id")
                do update set
                  "name" = EXCLUDED."name",
                "last_name" = EXCLUDED."last_name",
                "email" = EXCLUDED."email",
                "password" = EXCLUDED."password",
                "created_at" = EXCLUDED."created_at",
                "verified_on" = EXCLUDED."verified_on"
                returning "user_id", "name", "last_name", "email"::text, "password", "created_at"::text, "verified_on"::text"""))
      .updateManyReturning(UsersRow._rowParser, unsaved)
      .runUnchecked(c);
  };

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  @Override
  public Integer upsertStreaming(
    Iterator<UsersRow> unsaved,
    Integer batchSize,
    Connection c
  ) {
    interpolate(typo.runtime.Fragment.lit("""
    create temporary table users_TEMP (like "public"."users") on commit drop
    """)).update().runUnchecked(c);
    streamingInsert.insertUnchecked(str("""
    copy users_TEMP("user_id", "name", "last_name", "email", "password", "created_at", "verified_on") from stdin
    """), batchSize, unsaved, c, UsersRow.pgText);
    return interpolate(typo.runtime.Fragment.lit("""
       insert into "public"."users"("user_id", "name", "last_name", "email", "password", "created_at", "verified_on")
       select * from users_TEMP
       on conflict ("user_id")
       do update set
         "name" = EXCLUDED."name",
       "last_name" = EXCLUDED."last_name",
       "email" = EXCLUDED."email",
       "password" = EXCLUDED."password",
       "created_at" = EXCLUDED."created_at",
       "verified_on" = EXCLUDED."verified_on"
       ;
       drop table users_TEMP;""")).update().runUnchecked(c);
  };
}