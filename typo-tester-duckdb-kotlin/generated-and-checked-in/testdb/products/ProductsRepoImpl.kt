/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.products

import java.sql.Connection
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.kotlindsl.nullable
import typo.runtime.DuckDbTypes

class ProductsRepoImpl() : ProductsRepo {
  override fun delete(): DeleteBuilder<ProductsFields, ProductsRow> = DeleteBuilder.of("\"products\"", ProductsFields.structure, Dialect.DUCKDB)

  override fun deleteById(
    productId: ProductsId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"products\" where \"product_id\" = "), Fragment.encode(ProductsId.duckDbType, productId), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    productIds: Array<ProductsId>,
    c: Connection
  ): Int = Fragment.interpolate(Fragment.lit("delete\nfrom \"products\"\nwhere \"product_id\" = ANY("), Fragment.encode(ProductsId.pgTypeArray, productIds), Fragment.lit(")"))
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: ProductsRow,
    c: Connection
  ): ProductsRow = Fragment.interpolate(Fragment.lit("insert into \"products\"(\"product_id\", \"sku\", \"name\", \"price\", \"metadata\")\nvalues ("), Fragment.encode(ProductsId.duckDbType, unsaved.productId), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.sku), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.name), Fragment.lit(", "), Fragment.encode(DuckDbTypes.numeric, unsaved.price), Fragment.lit(", "), Fragment.encode(DuckDbTypes.json.nullable(), unsaved.metadata), Fragment.lit(")\nRETURNING \"product_id\", \"sku\", \"name\", \"price\", \"metadata\"\n"))
    .updateReturning(ProductsRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun select(): SelectBuilder<ProductsFields, ProductsRow> = SelectBuilder.of("\"products\"", ProductsFields.structure, ProductsRow._rowParser, Dialect.DUCKDB)

  override fun selectAll(c: Connection): List<ProductsRow> = Fragment.interpolate(Fragment.lit("select \"product_id\", \"sku\", \"name\", \"price\", \"metadata\"\nfrom \"products\"\n")).query(ProductsRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    productId: ProductsId,
    c: Connection
  ): ProductsRow? = Fragment.interpolate(Fragment.lit("select \"product_id\", \"sku\", \"name\", \"price\", \"metadata\"\nfrom \"products\"\nwhere \"product_id\" = "), Fragment.encode(ProductsId.duckDbType, productId), Fragment.lit("")).query(ProductsRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    productIds: Array<ProductsId>,
    c: Connection
  ): List<ProductsRow> = Fragment.interpolate(Fragment.lit("select \"product_id\", \"sku\", \"name\", \"price\", \"metadata\"\nfrom \"products\"\nwhere \"product_id\" = ANY("), Fragment.encode(ProductsId.pgTypeArray, productIds), Fragment.lit(")")).query(ProductsRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    productIds: Array<ProductsId>,
    c: Connection
  ): Map<ProductsId, ProductsRow> {
    val ret: MutableMap<ProductsId, ProductsRow> = mutableMapOf<ProductsId, ProductsRow>()
    selectByIds(productIds, c).forEach({ row -> ret.put(row.productId, row) })
    return ret.toMap()
  }

  override fun selectByUniqueSku(
    sku: String,
    c: Connection
  ): ProductsRow? = Fragment.interpolate(Fragment.lit("select \"product_id\", \"sku\", \"name\", \"price\", \"metadata\"\nfrom \"products\"\nwhere \"sku\" = "), Fragment.encode(DuckDbTypes.varchar, sku), Fragment.lit("\n")).query(ProductsRow._rowParser.first()).runUnchecked(c)

  override fun update(): UpdateBuilder<ProductsFields, ProductsRow> = UpdateBuilder.of("\"products\"", ProductsFields.structure, ProductsRow._rowParser, Dialect.DUCKDB)

  override fun update(
    row: ProductsRow,
    c: Connection
  ): Boolean {
    val productId: ProductsId = row.productId
    return Fragment.interpolate(Fragment.lit("update \"products\"\nset \"sku\" = "), Fragment.encode(DuckDbTypes.varchar, row.sku), Fragment.lit(",\n\"name\" = "), Fragment.encode(DuckDbTypes.varchar, row.name), Fragment.lit(",\n\"price\" = "), Fragment.encode(DuckDbTypes.numeric, row.price), Fragment.lit(",\n\"metadata\" = "), Fragment.encode(DuckDbTypes.json.nullable(), row.metadata), Fragment.lit("\nwhere \"product_id\" = "), Fragment.encode(ProductsId.duckDbType, productId), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: ProductsRow,
    c: Connection
  ): ProductsRow = Fragment.interpolate(Fragment.lit("INSERT INTO \"products\"(\"product_id\", \"sku\", \"name\", \"price\", \"metadata\")\nVALUES ("), Fragment.encode(ProductsId.duckDbType, unsaved.productId), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.sku), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.name), Fragment.lit(", "), Fragment.encode(DuckDbTypes.numeric, unsaved.price), Fragment.lit(", "), Fragment.encode(DuckDbTypes.json.nullable(), unsaved.metadata), Fragment.lit(")\nON CONFLICT (\"product_id\")\nDO UPDATE SET\n  \"sku\" = EXCLUDED.\"sku\",\n\"name\" = EXCLUDED.\"name\",\n\"price\" = EXCLUDED.\"price\",\n\"metadata\" = EXCLUDED.\"metadata\"\nRETURNING \"product_id\", \"sku\", \"name\", \"price\", \"metadata\""))
    .updateReturning(ProductsRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<ProductsRow>,
    c: Connection
  ): List<ProductsRow> = Fragment.interpolate(Fragment.lit("INSERT INTO \"products\"(\"product_id\", \"sku\", \"name\", \"price\", \"metadata\")\nVALUES (?, ?, ?, ?, ?)\nON CONFLICT (\"product_id\")\nDO UPDATE SET\n  \"sku\" = EXCLUDED.\"sku\",\n\"name\" = EXCLUDED.\"name\",\n\"price\" = EXCLUDED.\"price\",\n\"metadata\" = EXCLUDED.\"metadata\"\nRETURNING \"product_id\", \"sku\", \"name\", \"price\", \"metadata\""))
    .updateReturningEach(ProductsRow._rowParser, unsaved)
  .runUnchecked(c)
}