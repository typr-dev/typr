/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.departments

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.kotlindsl.nullable
import typo.runtime.DuckDbTypes

class DepartmentsRepoImpl() : DepartmentsRepo {
  override fun delete(): DeleteBuilder<DepartmentsFields, DepartmentsRow> = DeleteBuilder.of("\"departments\"", DepartmentsFields.structure, Dialect.DUCKDB)

  override fun deleteById(
    compositeId: DepartmentsId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"departments\" where \"dept_code\" = "), Fragment.encode(DuckDbTypes.varchar, compositeId.deptCode), Fragment.lit(" AND \"dept_region\" = "), Fragment.encode(DuckDbTypes.varchar, compositeId.deptRegion), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    compositeIds: Array<DepartmentsId>,
    c: Connection
  ): Int {
    val orClauses: ArrayList<Fragment> = ArrayList()
    for (id in compositeIds) { orClauses.add(Fragment.interpolate(Fragment.lit("("), Fragment.lit("\"dept_code\" = "), Fragment.encode(DuckDbTypes.varchar, id.deptCode), Fragment.lit(" AND "), Fragment.lit("\"dept_region\" = "), Fragment.encode(DuckDbTypes.varchar, id.deptRegion), Fragment.lit(")"))) }
    return Fragment.interpolate(Fragment.lit("delete\nfrom \"departments\"\nwhere "), Fragment.or(orClauses), Fragment.lit("\n")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: DepartmentsRow,
    c: Connection
  ): DepartmentsRow = Fragment.interpolate(Fragment.lit("insert into \"departments\"(\"dept_code\", \"dept_region\", \"dept_name\", \"budget\")\nvalues ("), Fragment.encode(DuckDbTypes.varchar, unsaved.deptCode), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.deptRegion), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.deptName), Fragment.lit(", "), Fragment.encode(DuckDbTypes.numeric.nullable(), unsaved.budget), Fragment.lit(")\nRETURNING \"dept_code\", \"dept_region\", \"dept_name\", \"budget\"\n"))
    .updateReturning(DepartmentsRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun select(): SelectBuilder<DepartmentsFields, DepartmentsRow> = SelectBuilder.of("\"departments\"", DepartmentsFields.structure, DepartmentsRow._rowParser, Dialect.DUCKDB)

  override fun selectAll(c: Connection): List<DepartmentsRow> = Fragment.interpolate(Fragment.lit("select \"dept_code\", \"dept_region\", \"dept_name\", \"budget\"\nfrom \"departments\"\n")).query(DepartmentsRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    compositeId: DepartmentsId,
    c: Connection
  ): DepartmentsRow? = Fragment.interpolate(Fragment.lit("select \"dept_code\", \"dept_region\", \"dept_name\", \"budget\"\nfrom \"departments\"\nwhere \"dept_code\" = "), Fragment.encode(DuckDbTypes.varchar, compositeId.deptCode), Fragment.lit(" AND \"dept_region\" = "), Fragment.encode(DuckDbTypes.varchar, compositeId.deptRegion), Fragment.lit("")).query(DepartmentsRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    compositeIds: Array<DepartmentsId>,
    c: Connection
  ): List<DepartmentsRow> {
    val orClauses: ArrayList<Fragment> = ArrayList()
    for (id in compositeIds) { orClauses.add(Fragment.interpolate(Fragment.lit("("), Fragment.lit("\"dept_code\" = "), Fragment.encode(DuckDbTypes.varchar, id.deptCode), Fragment.lit(" AND "), Fragment.lit("\"dept_region\" = "), Fragment.encode(DuckDbTypes.varchar, id.deptRegion), Fragment.lit(")"))) }
    return Fragment.interpolate(Fragment.lit("select \"dept_code\", \"dept_region\", \"dept_name\", \"budget\"\nfrom \"departments\"\nwhere "), Fragment.or(orClauses), Fragment.lit("\n")).query(DepartmentsRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    compositeIds: Array<DepartmentsId>,
    c: Connection
  ): Map<DepartmentsId, DepartmentsRow> {
    val ret: MutableMap<DepartmentsId, DepartmentsRow> = mutableMapOf<DepartmentsId, DepartmentsRow>()
    selectByIds(compositeIds, c).forEach({ row -> ret.put(row.compositeId(), row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<DepartmentsFields, DepartmentsRow> = UpdateBuilder.of("\"departments\"", DepartmentsFields.structure, DepartmentsRow._rowParser, Dialect.DUCKDB)

  override fun update(
    row: DepartmentsRow,
    c: Connection
  ): Boolean {
    val compositeId: DepartmentsId = row.compositeId()
    return Fragment.interpolate(Fragment.lit("update \"departments\"\nset \"dept_name\" = "), Fragment.encode(DuckDbTypes.varchar, row.deptName), Fragment.lit(",\n\"budget\" = "), Fragment.encode(DuckDbTypes.numeric.nullable(), row.budget), Fragment.lit("\nwhere \"dept_code\" = "), Fragment.encode(DuckDbTypes.varchar, compositeId.deptCode), Fragment.lit(" AND \"dept_region\" = "), Fragment.encode(DuckDbTypes.varchar, compositeId.deptRegion), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: DepartmentsRow,
    c: Connection
  ): DepartmentsRow = Fragment.interpolate(Fragment.lit("INSERT INTO \"departments\"(\"dept_code\", \"dept_region\", \"dept_name\", \"budget\")\nVALUES ("), Fragment.encode(DuckDbTypes.varchar, unsaved.deptCode), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.deptRegion), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.deptName), Fragment.lit(", "), Fragment.encode(DuckDbTypes.numeric.nullable(), unsaved.budget), Fragment.lit(")\nON CONFLICT (\"dept_code\", \"dept_region\")\nDO UPDATE SET\n  \"dept_name\" = EXCLUDED.\"dept_name\",\n\"budget\" = EXCLUDED.\"budget\"\nRETURNING \"dept_code\", \"dept_region\", \"dept_name\", \"budget\""))
    .updateReturning(DepartmentsRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<DepartmentsRow>,
    c: Connection
  ): List<DepartmentsRow> = Fragment.interpolate(Fragment.lit("INSERT INTO \"departments\"(\"dept_code\", \"dept_region\", \"dept_name\", \"budget\")\nVALUES (?, ?, ?, ?)\nON CONFLICT (\"dept_code\", \"dept_region\")\nDO UPDATE SET\n  \"dept_name\" = EXCLUDED.\"dept_name\",\n\"budget\" = EXCLUDED.\"budget\"\nRETURNING \"dept_code\", \"dept_region\", \"dept_name\", \"budget\""))
    .updateReturningEach(DepartmentsRow._rowParser, unsaved)
  .runUnchecked(c)
}