/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.all_scalar_types

import java.sql.Connection
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import testdb.Mood
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.KotlinDbTypes
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.kotlindsl.nullable
import typo.runtime.DuckDbTypes

class AllScalarTypesRepoImpl() : AllScalarTypesRepo {
  override fun delete(): DeleteBuilder<AllScalarTypesFields, AllScalarTypesRow> = DeleteBuilder.of("\"all_scalar_types\"", AllScalarTypesFields.structure, Dialect.DUCKDB)

  override fun deleteById(
    id: AllScalarTypesId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"all_scalar_types\" where \"id\" = "), Fragment.encode(AllScalarTypesId.duckDbType, id), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    ids: Array<AllScalarTypesId>,
    c: Connection
  ): Int = Fragment.interpolate(Fragment.lit("delete\nfrom \"all_scalar_types\"\nwhere \"id\" = ANY("), Fragment.encode(AllScalarTypesId.pgTypeArray, ids), Fragment.lit(")"))
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: AllScalarTypesRow,
    c: Connection
  ): AllScalarTypesRow = Fragment.interpolate(Fragment.lit("insert into \"all_scalar_types\"(\"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\")\nvalues ("), Fragment.encode(AllScalarTypesId.duckDbType, unsaved.id), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.tinyint.nullable(), unsaved.colTinyint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.smallint.nullable(), unsaved.colSmallint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer.nullable(), unsaved.colInteger), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.bigint.nullable(), unsaved.colBigint), Fragment.lit(", "), Fragment.encode(DuckDbTypes.hugeint.nullable(), unsaved.colHugeint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.smallint.nullable(), unsaved.colUtinyint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer.nullable(), unsaved.colUsmallint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.bigint.nullable(), unsaved.colUinteger), Fragment.lit(", "), Fragment.encode(DuckDbTypes.ubigint.nullable(), unsaved.colUbigint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.float_.nullable(), unsaved.colFloat), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.double_.nullable(), unsaved.colDouble), Fragment.lit(", "), Fragment.encode(DuckDbTypes.numeric.nullable(), unsaved.colDecimal), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.boolean_.nullable(), unsaved.colBoolean), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar.nullable(), unsaved.colVarchar), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar.nullable(), unsaved.colText), Fragment.lit(", "), Fragment.encode(DuckDbTypes.blob.nullable(), unsaved.colBlob), Fragment.lit(", "), Fragment.encode(DuckDbTypes.date.nullable(), unsaved.colDate), Fragment.lit(", "), Fragment.encode(DuckDbTypes.time.nullable(), unsaved.colTime), Fragment.lit(", "), Fragment.encode(DuckDbTypes.timestamp.nullable(), unsaved.colTimestamp), Fragment.lit(", "), Fragment.encode(DuckDbTypes.timestamptz.nullable(), unsaved.colTimestamptz), Fragment.lit(", "), Fragment.encode(DuckDbTypes.interval.nullable(), unsaved.colInterval), Fragment.lit(", "), Fragment.encode(DuckDbTypes.uuid.nullable(), unsaved.colUuid), Fragment.lit(", "), Fragment.encode(DuckDbTypes.json.nullable(), unsaved.colJson), Fragment.lit(", "), Fragment.encode(Mood.duckDbType.nullable(), unsaved.colMood), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.colNotNull), Fragment.lit(")\nRETURNING \"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\"\n"))
    .updateReturning(AllScalarTypesRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun select(): SelectBuilder<AllScalarTypesFields, AllScalarTypesRow> = SelectBuilder.of("\"all_scalar_types\"", AllScalarTypesFields.structure, AllScalarTypesRow._rowParser, Dialect.DUCKDB)

  override fun selectAll(c: Connection): List<AllScalarTypesRow> = Fragment.interpolate(Fragment.lit("select \"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\"\nfrom \"all_scalar_types\"\n")).query(AllScalarTypesRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    id: AllScalarTypesId,
    c: Connection
  ): AllScalarTypesRow? = Fragment.interpolate(Fragment.lit("select \"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\"\nfrom \"all_scalar_types\"\nwhere \"id\" = "), Fragment.encode(AllScalarTypesId.duckDbType, id), Fragment.lit("")).query(AllScalarTypesRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    ids: Array<AllScalarTypesId>,
    c: Connection
  ): List<AllScalarTypesRow> = Fragment.interpolate(Fragment.lit("select \"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\"\nfrom \"all_scalar_types\"\nwhere \"id\" = ANY("), Fragment.encode(AllScalarTypesId.pgTypeArray, ids), Fragment.lit(")")).query(AllScalarTypesRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    ids: Array<AllScalarTypesId>,
    c: Connection
  ): Map<AllScalarTypesId, AllScalarTypesRow> {
    val ret: MutableMap<AllScalarTypesId, AllScalarTypesRow> = mutableMapOf<AllScalarTypesId, AllScalarTypesRow>()
    selectByIds(ids, c).forEach({ row -> ret.put(row.id, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<AllScalarTypesFields, AllScalarTypesRow> = UpdateBuilder.of("\"all_scalar_types\"", AllScalarTypesFields.structure, AllScalarTypesRow._rowParser, Dialect.DUCKDB)

  override fun update(
    row: AllScalarTypesRow,
    c: Connection
  ): Boolean {
    val id: AllScalarTypesId = row.id
    return Fragment.interpolate(Fragment.lit("update \"all_scalar_types\"\nset \"col_tinyint\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.tinyint.nullable(), row.colTinyint), Fragment.lit(",\n\"col_smallint\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.smallint.nullable(), row.colSmallint), Fragment.lit(",\n\"col_integer\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer.nullable(), row.colInteger), Fragment.lit(",\n\"col_bigint\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.bigint.nullable(), row.colBigint), Fragment.lit(",\n\"col_hugeint\" = "), Fragment.encode(DuckDbTypes.hugeint.nullable(), row.colHugeint), Fragment.lit(",\n\"col_utinyint\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.smallint.nullable(), row.colUtinyint), Fragment.lit(",\n\"col_usmallint\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer.nullable(), row.colUsmallint), Fragment.lit(",\n\"col_uinteger\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.bigint.nullable(), row.colUinteger), Fragment.lit(",\n\"col_ubigint\" = "), Fragment.encode(DuckDbTypes.ubigint.nullable(), row.colUbigint), Fragment.lit(",\n\"col_float\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.float_.nullable(), row.colFloat), Fragment.lit(",\n\"col_double\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.double_.nullable(), row.colDouble), Fragment.lit(",\n\"col_decimal\" = "), Fragment.encode(DuckDbTypes.numeric.nullable(), row.colDecimal), Fragment.lit(",\n\"col_boolean\" = "), Fragment.encode(KotlinDbTypes.DuckDbTypes.boolean_.nullable(), row.colBoolean), Fragment.lit(",\n\"col_varchar\" = "), Fragment.encode(DuckDbTypes.varchar.nullable(), row.colVarchar), Fragment.lit(",\n\"col_text\" = "), Fragment.encode(DuckDbTypes.varchar.nullable(), row.colText), Fragment.lit(",\n\"col_blob\" = "), Fragment.encode(DuckDbTypes.blob.nullable(), row.colBlob), Fragment.lit(",\n\"col_date\" = "), Fragment.encode(DuckDbTypes.date.nullable(), row.colDate), Fragment.lit(",\n\"col_time\" = "), Fragment.encode(DuckDbTypes.time.nullable(), row.colTime), Fragment.lit(",\n\"col_timestamp\" = "), Fragment.encode(DuckDbTypes.timestamp.nullable(), row.colTimestamp), Fragment.lit(",\n\"col_timestamptz\" = "), Fragment.encode(DuckDbTypes.timestamptz.nullable(), row.colTimestamptz), Fragment.lit(",\n\"col_interval\" = "), Fragment.encode(DuckDbTypes.interval.nullable(), row.colInterval), Fragment.lit(",\n\"col_uuid\" = "), Fragment.encode(DuckDbTypes.uuid.nullable(), row.colUuid), Fragment.lit(",\n\"col_json\" = "), Fragment.encode(DuckDbTypes.json.nullable(), row.colJson), Fragment.lit(",\n\"col_mood\" = "), Fragment.encode(Mood.duckDbType.nullable(), row.colMood), Fragment.lit(",\n\"col_not_null\" = "), Fragment.encode(DuckDbTypes.varchar, row.colNotNull), Fragment.lit("\nwhere \"id\" = "), Fragment.encode(AllScalarTypesId.duckDbType, id), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: AllScalarTypesRow,
    c: Connection
  ): AllScalarTypesRow = Fragment.interpolate(Fragment.lit("INSERT INTO \"all_scalar_types\"(\"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\")\nVALUES ("), Fragment.encode(AllScalarTypesId.duckDbType, unsaved.id), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.tinyint.nullable(), unsaved.colTinyint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.smallint.nullable(), unsaved.colSmallint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer.nullable(), unsaved.colInteger), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.bigint.nullable(), unsaved.colBigint), Fragment.lit(", "), Fragment.encode(DuckDbTypes.hugeint.nullable(), unsaved.colHugeint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.smallint.nullable(), unsaved.colUtinyint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.integer.nullable(), unsaved.colUsmallint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.bigint.nullable(), unsaved.colUinteger), Fragment.lit(", "), Fragment.encode(DuckDbTypes.ubigint.nullable(), unsaved.colUbigint), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.float_.nullable(), unsaved.colFloat), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.double_.nullable(), unsaved.colDouble), Fragment.lit(", "), Fragment.encode(DuckDbTypes.numeric.nullable(), unsaved.colDecimal), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.DuckDbTypes.boolean_.nullable(), unsaved.colBoolean), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar.nullable(), unsaved.colVarchar), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar.nullable(), unsaved.colText), Fragment.lit(", "), Fragment.encode(DuckDbTypes.blob.nullable(), unsaved.colBlob), Fragment.lit(", "), Fragment.encode(DuckDbTypes.date.nullable(), unsaved.colDate), Fragment.lit(", "), Fragment.encode(DuckDbTypes.time.nullable(), unsaved.colTime), Fragment.lit(", "), Fragment.encode(DuckDbTypes.timestamp.nullable(), unsaved.colTimestamp), Fragment.lit(", "), Fragment.encode(DuckDbTypes.timestamptz.nullable(), unsaved.colTimestamptz), Fragment.lit(", "), Fragment.encode(DuckDbTypes.interval.nullable(), unsaved.colInterval), Fragment.lit(", "), Fragment.encode(DuckDbTypes.uuid.nullable(), unsaved.colUuid), Fragment.lit(", "), Fragment.encode(DuckDbTypes.json.nullable(), unsaved.colJson), Fragment.lit(", "), Fragment.encode(Mood.duckDbType.nullable(), unsaved.colMood), Fragment.lit(", "), Fragment.encode(DuckDbTypes.varchar, unsaved.colNotNull), Fragment.lit(")\nON CONFLICT (\"id\")\nDO UPDATE SET\n  \"col_tinyint\" = EXCLUDED.\"col_tinyint\",\n\"col_smallint\" = EXCLUDED.\"col_smallint\",\n\"col_integer\" = EXCLUDED.\"col_integer\",\n\"col_bigint\" = EXCLUDED.\"col_bigint\",\n\"col_hugeint\" = EXCLUDED.\"col_hugeint\",\n\"col_utinyint\" = EXCLUDED.\"col_utinyint\",\n\"col_usmallint\" = EXCLUDED.\"col_usmallint\",\n\"col_uinteger\" = EXCLUDED.\"col_uinteger\",\n\"col_ubigint\" = EXCLUDED.\"col_ubigint\",\n\"col_float\" = EXCLUDED.\"col_float\",\n\"col_double\" = EXCLUDED.\"col_double\",\n\"col_decimal\" = EXCLUDED.\"col_decimal\",\n\"col_boolean\" = EXCLUDED.\"col_boolean\",\n\"col_varchar\" = EXCLUDED.\"col_varchar\",\n\"col_text\" = EXCLUDED.\"col_text\",\n\"col_blob\" = EXCLUDED.\"col_blob\",\n\"col_date\" = EXCLUDED.\"col_date\",\n\"col_time\" = EXCLUDED.\"col_time\",\n\"col_timestamp\" = EXCLUDED.\"col_timestamp\",\n\"col_timestamptz\" = EXCLUDED.\"col_timestamptz\",\n\"col_interval\" = EXCLUDED.\"col_interval\",\n\"col_uuid\" = EXCLUDED.\"col_uuid\",\n\"col_json\" = EXCLUDED.\"col_json\",\n\"col_mood\" = EXCLUDED.\"col_mood\",\n\"col_not_null\" = EXCLUDED.\"col_not_null\"\nRETURNING \"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\""))
    .updateReturning(AllScalarTypesRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<AllScalarTypesRow>,
    c: Connection
  ): List<AllScalarTypesRow> = Fragment.interpolate(Fragment.lit("INSERT INTO \"all_scalar_types\"(\"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\")\nVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\nON CONFLICT (\"id\")\nDO UPDATE SET\n  \"col_tinyint\" = EXCLUDED.\"col_tinyint\",\n\"col_smallint\" = EXCLUDED.\"col_smallint\",\n\"col_integer\" = EXCLUDED.\"col_integer\",\n\"col_bigint\" = EXCLUDED.\"col_bigint\",\n\"col_hugeint\" = EXCLUDED.\"col_hugeint\",\n\"col_utinyint\" = EXCLUDED.\"col_utinyint\",\n\"col_usmallint\" = EXCLUDED.\"col_usmallint\",\n\"col_uinteger\" = EXCLUDED.\"col_uinteger\",\n\"col_ubigint\" = EXCLUDED.\"col_ubigint\",\n\"col_float\" = EXCLUDED.\"col_float\",\n\"col_double\" = EXCLUDED.\"col_double\",\n\"col_decimal\" = EXCLUDED.\"col_decimal\",\n\"col_boolean\" = EXCLUDED.\"col_boolean\",\n\"col_varchar\" = EXCLUDED.\"col_varchar\",\n\"col_text\" = EXCLUDED.\"col_text\",\n\"col_blob\" = EXCLUDED.\"col_blob\",\n\"col_date\" = EXCLUDED.\"col_date\",\n\"col_time\" = EXCLUDED.\"col_time\",\n\"col_timestamp\" = EXCLUDED.\"col_timestamp\",\n\"col_timestamptz\" = EXCLUDED.\"col_timestamptz\",\n\"col_interval\" = EXCLUDED.\"col_interval\",\n\"col_uuid\" = EXCLUDED.\"col_uuid\",\n\"col_json\" = EXCLUDED.\"col_json\",\n\"col_mood\" = EXCLUDED.\"col_mood\",\n\"col_not_null\" = EXCLUDED.\"col_not_null\"\nRETURNING \"id\", \"col_tinyint\", \"col_smallint\", \"col_integer\", \"col_bigint\", \"col_hugeint\", \"col_utinyint\", \"col_usmallint\", \"col_uinteger\", \"col_ubigint\", \"col_float\", \"col_double\", \"col_decimal\", \"col_boolean\", \"col_varchar\", \"col_text\", \"col_blob\", \"col_date\", \"col_time\", \"col_timestamp\", \"col_timestamptz\", \"col_interval\", \"col_uuid\", \"col_json\", \"col_mood\", \"col_not_null\""))
    .updateReturningEach(AllScalarTypesRow._rowParser, unsaved)
  .runUnchecked(c)
}