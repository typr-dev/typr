/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package oracledb.contacts;

import static typo.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import oracledb.EmailTableT;
import oracledb.TagVarrayT;
import typo.dsl.DeleteBuilder;
import typo.dsl.Dialect;
import typo.dsl.SelectBuilder;
import typo.dsl.UpdateBuilder;
import typo.runtime.Fragment;
import typo.runtime.OracleTypes;

public class ContactsRepoImpl implements ContactsRepo {
  @Override
  public DeleteBuilder<ContactsFields, ContactsRow> delete() {
    return DeleteBuilder.of("\"CONTACTS\"", ContactsFields.structure(), Dialect.ORACLE);
  }
  ;

  @Override
  public Boolean deleteById(ContactsId contactId, Connection c) {
    return interpolate(
                Fragment.lit("delete from \"CONTACTS\" where \"CONTACT_ID\" = "),
                Fragment.encode(ContactsId.oracleType, contactId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(ContactsId[] contactIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : contactIds) {
      fragments.add(Fragment.encode(ContactsId.oracleType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from \"CONTACTS\" where \"CONTACT_ID\" in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public ContactsId insert(ContactsRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into \"CONTACTS\"(\"CONTACT_ID\", \"NAME\", \"EMAILS\", \"TAGS\")\n"
                    + "values ("),
            Fragment.encode(ContactsId.oracleType, unsaved.contactId()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(EmailTableT.oracleType.opt(), unsaved.emails()),
            Fragment.lit(", "),
            Fragment.encode(TagVarrayT.oracleType.opt(), unsaved.tags()),
            Fragment.lit(")\n"))
        .updateReturningGeneratedKeys(
            new String[] {"CONTACT_ID"}, ContactsId._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public ContactsId insert(ContactsRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("\"NAME\""));
    values.add(
        interpolate(Fragment.encode(OracleTypes.varchar2, unsaved.name()), Fragment.lit("")));
    columns.add(Fragment.lit("\"EMAILS\""));
    values.add(
        interpolate(
            Fragment.encode(EmailTableT.oracleType.opt(), unsaved.emails()), Fragment.lit("")));
    columns.add(Fragment.lit("\"TAGS\""));
    values.add(
        interpolate(
            Fragment.encode(TagVarrayT.oracleType.opt(), unsaved.tags()), Fragment.lit("")));
    unsaved
        .contactId()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("\"CONTACT_ID\""));
              values.add(
                  interpolate(Fragment.encode(ContactsId.oracleType, value), Fragment.lit("")));
            });
    ;
    Fragment q =
        interpolate(
            Fragment.lit("insert into \"CONTACTS\"("),
            Fragment.comma(columns),
            Fragment.lit(")\nvalues ("),
            Fragment.comma(values),
            Fragment.lit(")\n"));
    ;
    return q.updateReturningGeneratedKeys(
            new String[] {"CONTACT_ID"}, ContactsId._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<ContactsFields, ContactsRow> select() {
    return SelectBuilder.of(
        "\"CONTACTS\"", ContactsFields.structure(), ContactsRow._rowParser, Dialect.ORACLE);
  }
  ;

  @Override
  public List<ContactsRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit(
                "select \"CONTACT_ID\", \"NAME\", \"EMAILS\", \"TAGS\"\nfrom \"CONTACTS\"\n"))
        .query(ContactsRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<ContactsRow> selectById(ContactsId contactId, Connection c) {
    return interpolate(
            Fragment.lit(
                "select \"CONTACT_ID\", \"NAME\", \"EMAILS\", \"TAGS\"\n"
                    + "from \"CONTACTS\"\n"
                    + "where \"CONTACT_ID\" = "),
            Fragment.encode(ContactsId.oracleType, contactId),
            Fragment.lit(""))
        .query(ContactsRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<ContactsRow> selectByIds(ContactsId[] contactIds, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : contactIds) {
      fragments.add(Fragment.encode(ContactsId.oracleType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select \"CONTACT_ID\", \"NAME\", \"EMAILS\", \"TAGS\" from \"CONTACTS\" where"
                    + " \"CONTACT_ID\" in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(ContactsRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<ContactsId, ContactsRow> selectByIdsTracked(ContactsId[] contactIds, Connection c) {
    HashMap<ContactsId, ContactsRow> ret = new HashMap<ContactsId, ContactsRow>();
    selectByIds(contactIds, c).forEach(row -> ret.put(row.contactId(), row));
    return ret;
  }
  ;

  @Override
  public UpdateBuilder<ContactsFields, ContactsRow> update() {
    return UpdateBuilder.of(
        "\"CONTACTS\"", ContactsFields.structure(), ContactsRow._rowParser, Dialect.ORACLE);
  }
  ;

  @Override
  public Boolean update(ContactsRow row, Connection c) {
    ContactsId contactId = row.contactId();
    ;
    return interpolate(
                Fragment.lit("update \"CONTACTS\"\nset \"NAME\" = "),
                Fragment.encode(OracleTypes.varchar2, row.name()),
                Fragment.lit(",\n\"EMAILS\" = "),
                Fragment.encode(EmailTableT.oracleType.opt(), row.emails()),
                Fragment.lit(",\n\"TAGS\" = "),
                Fragment.encode(TagVarrayT.oracleType.opt(), row.tags()),
                Fragment.lit("\nwhere \"CONTACT_ID\" = "),
                Fragment.encode(ContactsId.oracleType, contactId),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public ContactsRow upsert(ContactsRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit("MERGE INTO \"CONTACTS\" t\nUSING (SELECT "),
            Fragment.encode(ContactsId.oracleType, unsaved.contactId()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(EmailTableT.oracleType.opt(), unsaved.emails()),
            Fragment.lit(", "),
            Fragment.encode(TagVarrayT.oracleType.opt(), unsaved.tags()),
            Fragment.lit(
                " FROM DUAL) s\n"
                    + "ON (\"CONTACT_ID\")\n"
                    + "WHEN MATCHED THEN UPDATE SET t.\"NAME\" = s.\"NAME\",\n"
                    + "t.\"EMAILS\" = s.\"EMAILS\",\n"
                    + "t.\"TAGS\" = s.\"TAGS\"\n"
                    + "WHEN NOT MATCHED THEN INSERT (\"CONTACT_ID\", \"NAME\", \"EMAILS\","
                    + " \"TAGS\") VALUES ("),
            Fragment.encode(ContactsId.oracleType, unsaved.contactId()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2, unsaved.name()),
            Fragment.lit(", "),
            Fragment.encode(EmailTableT.oracleType.opt(), unsaved.emails()),
            Fragment.lit(", "),
            Fragment.encode(TagVarrayT.oracleType.opt(), unsaved.tags()),
            Fragment.lit(")"))
        .updateReturning(ContactsRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<ContactsRow> upsertBatch(Iterator<ContactsRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "MERGE INTO \"CONTACTS\" t\n"
                    + "USING (SELECT ?, ?, ?, ? FROM DUAL) s\n"
                    + "ON (\"CONTACT_ID\")\n"
                    + "WHEN MATCHED THEN UPDATE SET t.\"NAME\" = s.\"NAME\",\n"
                    + "t.\"EMAILS\" = s.\"EMAILS\",\n"
                    + "t.\"TAGS\" = s.\"TAGS\"\n"
                    + "WHEN NOT MATCHED THEN INSERT (\"CONTACT_ID\", \"NAME\", \"EMAILS\","
                    + " \"TAGS\") VALUES (?, ?, ?, ?)"))
        .updateReturningEach(ContactsRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
