/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package oracledb.all_scalar_types;

import static typo.runtime.Fragment.interpolate;

import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import typo.dsl.DeleteBuilder;
import typo.dsl.Dialect;
import typo.dsl.SelectBuilder;
import typo.dsl.UpdateBuilder;
import typo.runtime.Fragment;
import typo.runtime.OracleTypes;

public class AllScalarTypesRepoImpl implements AllScalarTypesRepo {
  @Override
  public DeleteBuilder<AllScalarTypesFields, AllScalarTypesRow> delete() {
    return DeleteBuilder.of(
        "\"ALL_SCALAR_TYPES\"", AllScalarTypesFields.structure(), Dialect.ORACLE);
  }
  ;

  @Override
  public Boolean deleteById(AllScalarTypesId id, Connection c) {
    return interpolate(
                Fragment.lit("delete from \"ALL_SCALAR_TYPES\" where \"ID\" = "),
                Fragment.encode(AllScalarTypesId.oracleType, id),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public Integer deleteByIds(AllScalarTypesId[] ids, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : ids) {
      fragments.add(Fragment.encode(AllScalarTypesId.oracleType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit("delete from \"ALL_SCALAR_TYPES\" where \"ID\" in ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .update()
        .runUnchecked(c);
  }
  ;

  @Override
  public AllScalarTypesRow insert(AllScalarTypesRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "insert into \"ALL_SCALAR_TYPES\"(\"ID\", \"COL_VARCHAR2\", \"COL_NUMBER\","
                    + " \"COL_DATE\", \"COL_TIMESTAMP\", \"COL_CLOB\", \"COL_NOT_NULL\")\n"
                    + "values ("),
            Fragment.encode(AllScalarTypesId.oracleType, unsaved.id()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2.opt(), unsaved.colVarchar2()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.number.opt(), unsaved.colNumber()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.date.opt(), unsaved.colDate()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.timestamp.opt(), unsaved.colTimestamp()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.clob.opt(), unsaved.colClob()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2, unsaved.colNotNull()),
            Fragment.lit(")\n"))
        .updateReturningGeneratedKeys(
            new String[] {
              "ID",
              "COL_VARCHAR2",
              "COL_NUMBER",
              "COL_DATE",
              "COL_TIMESTAMP",
              "COL_CLOB",
              "COL_NOT_NULL"
            },
            AllScalarTypesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public AllScalarTypesRow insert(AllScalarTypesRowUnsaved unsaved, Connection c) {
    ArrayList<Fragment> columns = new ArrayList<>();
    ;
    ArrayList<Fragment> values = new ArrayList<>();
    ;
    columns.add(Fragment.lit("\"COL_VARCHAR2\""));
    values.add(
        interpolate(
            Fragment.encode(OracleTypes.varchar2.opt(), unsaved.colVarchar2()), Fragment.lit("")));
    columns.add(Fragment.lit("\"COL_NUMBER\""));
    values.add(
        interpolate(
            Fragment.encode(OracleTypes.number.opt(), unsaved.colNumber()), Fragment.lit("")));
    columns.add(Fragment.lit("\"COL_DATE\""));
    values.add(
        interpolate(Fragment.encode(OracleTypes.date.opt(), unsaved.colDate()), Fragment.lit("")));
    columns.add(Fragment.lit("\"COL_TIMESTAMP\""));
    values.add(
        interpolate(
            Fragment.encode(OracleTypes.timestamp.opt(), unsaved.colTimestamp()),
            Fragment.lit("")));
    columns.add(Fragment.lit("\"COL_CLOB\""));
    values.add(
        interpolate(Fragment.encode(OracleTypes.clob.opt(), unsaved.colClob()), Fragment.lit("")));
    columns.add(Fragment.lit("\"COL_NOT_NULL\""));
    values.add(
        interpolate(Fragment.encode(OracleTypes.varchar2, unsaved.colNotNull()), Fragment.lit("")));
    unsaved
        .id()
        .visit(
            () -> {},
            value -> {
              columns.add(Fragment.lit("\"ID\""));
              values.add(
                  interpolate(
                      Fragment.encode(AllScalarTypesId.oracleType, value), Fragment.lit("")));
            });
    ;
    Fragment q =
        interpolate(
            Fragment.lit("insert into \"ALL_SCALAR_TYPES\"("),
            Fragment.comma(columns),
            Fragment.lit(")\nvalues ("),
            Fragment.comma(values),
            Fragment.lit(")\n"));
    ;
    return q.updateReturningGeneratedKeys(
            new String[] {
              "ID",
              "COL_VARCHAR2",
              "COL_NUMBER",
              "COL_DATE",
              "COL_TIMESTAMP",
              "COL_CLOB",
              "COL_NOT_NULL"
            },
            AllScalarTypesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public SelectBuilder<AllScalarTypesFields, AllScalarTypesRow> select() {
    return SelectBuilder.of(
        "\"ALL_SCALAR_TYPES\"",
        AllScalarTypesFields.structure(),
        AllScalarTypesRow._rowParser,
        Dialect.ORACLE);
  }
  ;

  @Override
  public List<AllScalarTypesRow> selectAll(Connection c) {
    return interpolate(
            Fragment.lit(
                "select \"ID\", \"COL_VARCHAR2\", \"COL_NUMBER\", \"COL_DATE\", \"COL_TIMESTAMP\","
                    + " \"COL_CLOB\", \"COL_NOT_NULL\"\n"
                    + "from \"ALL_SCALAR_TYPES\"\n"))
        .query(AllScalarTypesRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Optional<AllScalarTypesRow> selectById(AllScalarTypesId id, Connection c) {
    return interpolate(
            Fragment.lit(
                "select \"ID\", \"COL_VARCHAR2\", \"COL_NUMBER\", \"COL_DATE\", \"COL_TIMESTAMP\","
                    + " \"COL_CLOB\", \"COL_NOT_NULL\"\n"
                    + "from \"ALL_SCALAR_TYPES\"\n"
                    + "where \"ID\" = "),
            Fragment.encode(AllScalarTypesId.oracleType, id),
            Fragment.lit(""))
        .query(AllScalarTypesRow._rowParser.first())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<AllScalarTypesRow> selectByIds(AllScalarTypesId[] ids, Connection c) {
    ArrayList<Fragment> fragments = new ArrayList<>();
    for (var id : ids) {
      fragments.add(Fragment.encode(AllScalarTypesId.oracleType, id));
    }
    ;
    return Fragment.interpolate(
            Fragment.lit(
                "select \"ID\", \"COL_VARCHAR2\", \"COL_NUMBER\", \"COL_DATE\", \"COL_TIMESTAMP\","
                    + " \"COL_CLOB\", \"COL_NOT_NULL\" from \"ALL_SCALAR_TYPES\" where \"ID\" in"
                    + " ("),
            Fragment.comma(fragments),
            Fragment.lit(")"))
        .query(AllScalarTypesRow._rowParser.all())
        .runUnchecked(c);
  }
  ;

  @Override
  public Map<AllScalarTypesId, AllScalarTypesRow> selectByIdsTracked(
      AllScalarTypesId[] ids, Connection c) {
    HashMap<AllScalarTypesId, AllScalarTypesRow> ret =
        new HashMap<AllScalarTypesId, AllScalarTypesRow>();
    selectByIds(ids, c).forEach(row -> ret.put(row.id(), row));
    return ret;
  }
  ;

  @Override
  public UpdateBuilder<AllScalarTypesFields, AllScalarTypesRow> update() {
    return UpdateBuilder.of(
        "\"ALL_SCALAR_TYPES\"",
        AllScalarTypesFields.structure(),
        AllScalarTypesRow._rowParser,
        Dialect.ORACLE);
  }
  ;

  @Override
  public Boolean update(AllScalarTypesRow row, Connection c) {
    AllScalarTypesId id = row.id();
    ;
    return interpolate(
                Fragment.lit("update \"ALL_SCALAR_TYPES\"\nset \"COL_VARCHAR2\" = "),
                Fragment.encode(OracleTypes.varchar2.opt(), row.colVarchar2()),
                Fragment.lit(",\n\"COL_NUMBER\" = "),
                Fragment.encode(OracleTypes.number.opt(), row.colNumber()),
                Fragment.lit(",\n\"COL_DATE\" = "),
                Fragment.encode(OracleTypes.date.opt(), row.colDate()),
                Fragment.lit(",\n\"COL_TIMESTAMP\" = "),
                Fragment.encode(OracleTypes.timestamp.opt(), row.colTimestamp()),
                Fragment.lit(",\n\"COL_CLOB\" = "),
                Fragment.encode(OracleTypes.clob.opt(), row.colClob()),
                Fragment.lit(",\n\"COL_NOT_NULL\" = "),
                Fragment.encode(OracleTypes.varchar2, row.colNotNull()),
                Fragment.lit("\nwhere \"ID\" = "),
                Fragment.encode(AllScalarTypesId.oracleType, id),
                Fragment.lit(""))
            .update()
            .runUnchecked(c)
        > 0;
  }
  ;

  @Override
  public AllScalarTypesRow upsert(AllScalarTypesRow unsaved, Connection c) {
    return interpolate(
            Fragment.lit("MERGE INTO \"ALL_SCALAR_TYPES\" t\nUSING (SELECT "),
            Fragment.encode(AllScalarTypesId.oracleType, unsaved.id()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2.opt(), unsaved.colVarchar2()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.number.opt(), unsaved.colNumber()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.date.opt(), unsaved.colDate()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.timestamp.opt(), unsaved.colTimestamp()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.clob.opt(), unsaved.colClob()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2, unsaved.colNotNull()),
            Fragment.lit(
                " FROM DUAL) s\n"
                    + "ON (\"ID\")\n"
                    + "WHEN MATCHED THEN UPDATE SET t.\"COL_VARCHAR2\" = s.\"COL_VARCHAR2\",\n"
                    + "t.\"COL_NUMBER\" = s.\"COL_NUMBER\",\n"
                    + "t.\"COL_DATE\" = s.\"COL_DATE\",\n"
                    + "t.\"COL_TIMESTAMP\" = s.\"COL_TIMESTAMP\",\n"
                    + "t.\"COL_CLOB\" = s.\"COL_CLOB\",\n"
                    + "t.\"COL_NOT_NULL\" = s.\"COL_NOT_NULL\"\n"
                    + "WHEN NOT MATCHED THEN INSERT (\"ID\", \"COL_VARCHAR2\", \"COL_NUMBER\","
                    + " \"COL_DATE\", \"COL_TIMESTAMP\", \"COL_CLOB\", \"COL_NOT_NULL\") VALUES ("),
            Fragment.encode(AllScalarTypesId.oracleType, unsaved.id()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2.opt(), unsaved.colVarchar2()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.number.opt(), unsaved.colNumber()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.date.opt(), unsaved.colDate()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.timestamp.opt(), unsaved.colTimestamp()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.clob.opt(), unsaved.colClob()),
            Fragment.lit(", "),
            Fragment.encode(OracleTypes.varchar2, unsaved.colNotNull()),
            Fragment.lit(")"))
        .updateReturning(AllScalarTypesRow._rowParser.exactlyOne())
        .runUnchecked(c);
  }
  ;

  @Override
  public List<AllScalarTypesRow> upsertBatch(Iterator<AllScalarTypesRow> unsaved, Connection c) {
    return interpolate(
            Fragment.lit(
                "MERGE INTO \"ALL_SCALAR_TYPES\" t\n"
                    + "USING (SELECT ?, ?, ?, ?, ?, ?, ? FROM DUAL) s\n"
                    + "ON (\"ID\")\n"
                    + "WHEN MATCHED THEN UPDATE SET t.\"COL_VARCHAR2\" = s.\"COL_VARCHAR2\",\n"
                    + "t.\"COL_NUMBER\" = s.\"COL_NUMBER\",\n"
                    + "t.\"COL_DATE\" = s.\"COL_DATE\",\n"
                    + "t.\"COL_TIMESTAMP\" = s.\"COL_TIMESTAMP\",\n"
                    + "t.\"COL_CLOB\" = s.\"COL_CLOB\",\n"
                    + "t.\"COL_NOT_NULL\" = s.\"COL_NOT_NULL\"\n"
                    + "WHEN NOT MATCHED THEN INSERT (\"ID\", \"COL_VARCHAR2\", \"COL_NUMBER\","
                    + " \"COL_DATE\", \"COL_TIMESTAMP\", \"COL_CLOB\", \"COL_NOT_NULL\") VALUES (?,"
                    + " ?, ?, ?, ?, ?, ?)"))
        .updateReturningEach(AllScalarTypesRow._rowParser, unsaved)
        .runUnchecked(c);
  }
  ;
}
