/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.purchasing.productvendor

import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.sql.Connection
import java.util.ArrayList
import java.util.HashMap
import java.util.Optional
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.PgTypes
import typo.runtime.streamingInsert
import typo.runtime.Fragment.interpolate

class ProductvendorRepoImpl extends ProductvendorRepo {
  override def delete: DeleteBuilder[ProductvendorFields, ProductvendorRow] = DeleteBuilder.of(""""purchasing"."productvendor"""", ProductvendorFields.structure, Dialect.POSTGRESQL)

  override def deleteById(compositeId: ProductvendorId)(using c: Connection): java.lang.Boolean = interpolate(Fragment.lit("""delete from "purchasing"."productvendor" where "productid" = """), Fragment.encode(ProductId.pgType, compositeId.productid), Fragment.lit(""" AND "businessentityid" = """), Fragment.encode(BusinessentityId.pgType, compositeId.businessentityid), Fragment.lit("")).update().runUnchecked(c) > 0

  override def deleteByIds(compositeIds: Array[ProductvendorId])(using c: Connection): Integer = {
    val productid: Array[ProductId] = compositeIds.map(_.productid)
    val businessentityid: Array[BusinessentityId] = compositeIds.map(_.businessentityid)
    return interpolate(Fragment.lit("""delete
    from "purchasing"."productvendor"
    where ("productid", "businessentityid")
    in (select * from unnest("""), Fragment.encode(ProductId.pgTypeArray, productid), Fragment.lit(", "), Fragment.encode(BusinessentityId.pgTypeArray, businessentityid), Fragment.lit("""))
    """)).update().runUnchecked(c)
  }

  override def insert(unsaved: ProductvendorRow)(using c: Connection): ProductvendorRow = {
  interpolate(Fragment.lit("""insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
    values ("""), Fragment.encode(ProductId.pgType, unsaved.productid), Fragment.lit("::int4, "), Fragment.encode(BusinessentityId.pgType, unsaved.businessentityid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.int4, unsaved.averageleadtime), Fragment.lit("::int4, "), Fragment.encode(PgTypes.numeric, unsaved.standardprice), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.numeric.opt(), unsaved.lastreceiptcost), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.timestamp.opt(), unsaved.lastreceiptdate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.int4, unsaved.minorderqty), Fragment.lit("::int4, "), Fragment.encode(PgTypes.int4, unsaved.maxorderqty), Fragment.lit("::int4, "), Fragment.encode(PgTypes.int4.opt(), unsaved.onorderqty), Fragment.lit("::int4, "), Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("""::timestamp)
    RETURNING "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"
    """))
    .updateReturning(ProductvendorRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insert(unsaved: ProductvendorRowUnsaved)(using c: Connection): ProductvendorRow = {
    val columns: ArrayList[Fragment] = new ArrayList()
    val values: ArrayList[Fragment] = new ArrayList()
    columns.add(Fragment.lit(""""productid"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(ProductId.pgType, unsaved.productid), Fragment.lit("::int4"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""businessentityid"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(BusinessentityId.pgType, unsaved.businessentityid), Fragment.lit("::int4"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""averageleadtime"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.int4, unsaved.averageleadtime), Fragment.lit("::int4"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""standardprice"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.numeric, unsaved.standardprice), Fragment.lit("::numeric"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""lastreceiptcost"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.numeric.opt(), unsaved.lastreceiptcost), Fragment.lit("::numeric"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""lastreceiptdate"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.timestamp.opt(), unsaved.lastreceiptdate), Fragment.lit("::timestamp"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""minorderqty"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.int4, unsaved.minorderqty), Fragment.lit("::int4"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""maxorderqty"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.int4, unsaved.maxorderqty), Fragment.lit("::int4"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""onorderqty"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(PgTypes.int4.opt(), unsaved.onorderqty), Fragment.lit("::int4"))): @scala.annotation.nowarn
    columns.add(Fragment.lit(""""unitmeasurecode"""")): @scala.annotation.nowarn
    values.add(interpolate(Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar"))): @scala.annotation.nowarn
    unsaved.modifieddate.visit(
      {  },
      value => { columns.add(Fragment.lit(""""modifieddate"""")): @scala.annotation.nowarn; values.add(interpolate(Fragment.encode(PgTypes.timestamp, value), Fragment.lit("::timestamp"))): @scala.annotation.nowarn }
    );
    val q: Fragment = {
      interpolate(Fragment.lit("""insert into "purchasing"."productvendor"("""), Fragment.comma(columns), Fragment.lit(""")
      values ("""), Fragment.comma(values), Fragment.lit(""")
      RETURNING "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"
      """))
    }
    return q.updateReturning(ProductvendorRow.`_rowParser`.exactlyOne()).runUnchecked(c)
  }

  override def insertStreaming(
    unsaved: java.util.Iterator[ProductvendorRow],
    batchSize: Integer = 10000
  )(using c: Connection): java.lang.Long = streamingInsert.insertUnchecked(s"""COPY "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") FROM STDIN""", batchSize, unsaved, c, ProductvendorRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override def insertUnsavedStreaming(
    unsaved: java.util.Iterator[ProductvendorRowUnsaved],
    batchSize: Integer = 10000
  )(using c: Connection): java.lang.Long = streamingInsert.insertUnchecked(s"""COPY "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')""", batchSize, unsaved, c, ProductvendorRowUnsaved.pgText)

  override def select: SelectBuilder[ProductvendorFields, ProductvendorRow] = SelectBuilder.of(""""purchasing"."productvendor"""", ProductvendorFields.structure, ProductvendorRow.`_rowParser`, Dialect.POSTGRESQL)

  override def selectAll(using c: Connection): java.util.List[ProductvendorRow] = {
    interpolate(Fragment.lit("""select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"
    from "purchasing"."productvendor"
    """)).query(ProductvendorRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectById(compositeId: ProductvendorId)(using c: Connection): Optional[ProductvendorRow] = {
    interpolate(Fragment.lit("""select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"
    from "purchasing"."productvendor"
    where "productid" = """), Fragment.encode(ProductId.pgType, compositeId.productid), Fragment.lit(""" AND "businessentityid" = """), Fragment.encode(BusinessentityId.pgType, compositeId.businessentityid), Fragment.lit("")).query(ProductvendorRow.`_rowParser`.first()).runUnchecked(c)
  }

  override def selectByIds(compositeIds: Array[ProductvendorId])(using c: Connection): java.util.List[ProductvendorRow] = {
    val productid: Array[ProductId] = compositeIds.map(_.productid)
    val businessentityid: Array[BusinessentityId] = compositeIds.map(_.businessentityid)
    return interpolate(Fragment.lit("""select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"
    from "purchasing"."productvendor"
    where ("productid", "businessentityid")
    in (select * from unnest("""), Fragment.encode(ProductId.pgTypeArray, productid), Fragment.lit(", "), Fragment.encode(BusinessentityId.pgTypeArray, businessentityid), Fragment.lit("""))
    """)).query(ProductvendorRow.`_rowParser`.all()).runUnchecked(c)
  }

  override def selectByIdsTracked(compositeIds: Array[ProductvendorId])(using c: Connection): java.util.Map[ProductvendorId, ProductvendorRow] = {
    val ret: HashMap[ProductvendorId, ProductvendorRow] = new HashMap[ProductvendorId, ProductvendorRow]()
    selectByIds(compositeIds)(using c).forEach(row => ret.put(row.compositeId, row): @scala.annotation.nowarn)
    return ret
  }

  override def update: UpdateBuilder[ProductvendorFields, ProductvendorRow] = UpdateBuilder.of(""""purchasing"."productvendor"""", ProductvendorFields.structure, ProductvendorRow.`_rowParser`, Dialect.POSTGRESQL)

  override def update(row: ProductvendorRow)(using c: Connection): java.lang.Boolean = {
    val compositeId: ProductvendorId = row.compositeId
    return interpolate(Fragment.lit("""update "purchasing"."productvendor"
    set "averageleadtime" = """), Fragment.encode(PgTypes.int4, row.averageleadtime), Fragment.lit("""::int4,
    "standardprice" = """), Fragment.encode(PgTypes.numeric, row.standardprice), Fragment.lit("""::numeric,
    "lastreceiptcost" = """), Fragment.encode(PgTypes.numeric.opt(), row.lastreceiptcost), Fragment.lit("""::numeric,
    "lastreceiptdate" = """), Fragment.encode(PgTypes.timestamp.opt(), row.lastreceiptdate), Fragment.lit("""::timestamp,
    "minorderqty" = """), Fragment.encode(PgTypes.int4, row.minorderqty), Fragment.lit("""::int4,
    "maxorderqty" = """), Fragment.encode(PgTypes.int4, row.maxorderqty), Fragment.lit("""::int4,
    "onorderqty" = """), Fragment.encode(PgTypes.int4.opt(), row.onorderqty), Fragment.lit("""::int4,
    "unitmeasurecode" = """), Fragment.encode(UnitmeasureId.pgType, row.unitmeasurecode), Fragment.lit("""::bpchar,
    "modifieddate" = """), Fragment.encode(PgTypes.timestamp, row.modifieddate), Fragment.lit("""::timestamp
    where "productid" = """), Fragment.encode(ProductId.pgType, compositeId.productid), Fragment.lit(""" AND "businessentityid" = """), Fragment.encode(BusinessentityId.pgType, compositeId.businessentityid), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override def upsert(unsaved: ProductvendorRow)(using c: Connection): ProductvendorRow = {
  interpolate(Fragment.lit("""insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
    values ("""), Fragment.encode(ProductId.pgType, unsaved.productid), Fragment.lit("::int4, "), Fragment.encode(BusinessentityId.pgType, unsaved.businessentityid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.int4, unsaved.averageleadtime), Fragment.lit("::int4, "), Fragment.encode(PgTypes.numeric, unsaved.standardprice), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.numeric.opt(), unsaved.lastreceiptcost), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.timestamp.opt(), unsaved.lastreceiptdate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.int4, unsaved.minorderqty), Fragment.lit("::int4, "), Fragment.encode(PgTypes.int4, unsaved.maxorderqty), Fragment.lit("::int4, "), Fragment.encode(PgTypes.int4.opt(), unsaved.onorderqty), Fragment.lit("::int4, "), Fragment.encode(UnitmeasureId.pgType, unsaved.unitmeasurecode), Fragment.lit("::bpchar, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("""::timestamp)
    on conflict ("productid", "businessentityid")
    do update set
      "averageleadtime" = EXCLUDED."averageleadtime",
    "standardprice" = EXCLUDED."standardprice",
    "lastreceiptcost" = EXCLUDED."lastreceiptcost",
    "lastreceiptdate" = EXCLUDED."lastreceiptdate",
    "minorderqty" = EXCLUDED."minorderqty",
    "maxorderqty" = EXCLUDED."maxorderqty",
    "onorderqty" = EXCLUDED."onorderqty",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "modifieddate" = EXCLUDED."modifieddate"
    returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate""""))
    .updateReturning(ProductvendorRow.`_rowParser`.exactlyOne())
    .runUnchecked(c)
  }

  override def upsertBatch(unsaved: java.util.Iterator[ProductvendorRow])(using c: Connection): java.util.List[ProductvendorRow] = {
    interpolate(Fragment.lit("""insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
    values (?::int4, ?::int4, ?::int4, ?::numeric, ?::numeric, ?::timestamp, ?::int4, ?::int4, ?::int4, ?::bpchar, ?::timestamp)
    on conflict ("productid", "businessentityid")
    do update set
      "averageleadtime" = EXCLUDED."averageleadtime",
    "standardprice" = EXCLUDED."standardprice",
    "lastreceiptcost" = EXCLUDED."lastreceiptcost",
    "lastreceiptdate" = EXCLUDED."lastreceiptdate",
    "minorderqty" = EXCLUDED."minorderqty",
    "maxorderqty" = EXCLUDED."maxorderqty",
    "onorderqty" = EXCLUDED."onorderqty",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "modifieddate" = EXCLUDED."modifieddate"
    returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate""""))
      .updateManyReturning(ProductvendorRow.`_rowParser`, unsaved)
    .runUnchecked(c)
  }

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override def upsertStreaming(
    unsaved: java.util.Iterator[ProductvendorRow],
    batchSize: Integer = 10000
  )(using c: Connection): Integer = {
    interpolate(Fragment.lit("""create temporary table productvendor_TEMP (like "purchasing"."productvendor") on commit drop""")).update().runUnchecked(c): @scala.annotation.nowarn
    streamingInsert.insertUnchecked(s"""copy productvendor_TEMP("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") from stdin""", batchSize, unsaved, c, ProductvendorRow.pgText): @scala.annotation.nowarn
    return interpolate(Fragment.lit("""insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
    select * from productvendor_TEMP
    on conflict ("productid", "businessentityid")
    do update set
      "averageleadtime" = EXCLUDED."averageleadtime",
    "standardprice" = EXCLUDED."standardprice",
    "lastreceiptcost" = EXCLUDED."lastreceiptcost",
    "lastreceiptdate" = EXCLUDED."lastreceiptdate",
    "minorderqty" = EXCLUDED."minorderqty",
    "maxorderqty" = EXCLUDED."maxorderqty",
    "onorderqty" = EXCLUDED."onorderqty",
    "unitmeasurecode" = EXCLUDED."unitmeasurecode",
    "modifieddate" = EXCLUDED."modifieddate"
    ;
    drop table productvendor_TEMP;""")).update().runUnchecked(c)
  }
}