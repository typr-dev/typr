/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.product

import adventureworks.customtypes.Defaulted
import adventureworks.production.productmodel.ProductmodelId
import adventureworks.production.productsubcategory.ProductsubcategoryId
import adventureworks.production.unitmeasure.UnitmeasureId
import adventureworks.public.Flag
import adventureworks.public.Name
import java.lang.Object
import java.time.LocalDateTime
import java.util.Optional
import java.util.UUID
import typo.runtime.PgText
import typo.runtime.PgTypes
import typo.runtime.RowParser

/** Table: production.product
 * Products sold or used in the manfacturing of sold products.
 * Primary key: productid
 */
case class ProductRow(
  /** Primary key for Product records.
   * Default: nextval('production.product_productid_seq'::regclass)
   */
  productid: ProductId,
  /** Name of the product. */
  name: Name,
  /** Unique product identification number. */
  productnumber: String,
  /** 0 = Product is purchased, 1 = Product is manufactured in-house.
   * Default: true
   */
  makeflag: Flag,
  /** 0 = Product is not a salable item. 1 = Product is salable.
   * Default: true
   */
  finishedgoodsflag: Flag,
  /** Product color. */
  color: Optional[/* max 15 chars */ String],
  /** Minimum inventory quantity.
   * Constraint CK_Product_SafetyStockLevel affecting columns safetystocklevel: ((safetystocklevel > 0))
   */
  safetystocklevel: java.lang.Short,
  /** Inventory level that triggers a purchase order or work order.
   * Constraint CK_Product_ReorderPoint affecting columns reorderpoint: ((reorderpoint > 0))
   */
  reorderpoint: java.lang.Short,
  /** Standard cost of the product.
   * Constraint CK_Product_StandardCost affecting columns standardcost: ((standardcost >= 0.00))
   */
  standardcost: java.math.BigDecimal,
  /** Selling price.
   * Constraint CK_Product_ListPrice affecting columns listprice: ((listprice >= 0.00))
   */
  listprice: java.math.BigDecimal,
  /** Product size. */
  size: Optional[/* max 5 chars */ String],
  /** Unit of measure for Size column.
   * Points to [[adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]]
   */
  sizeunitmeasurecode: Optional[UnitmeasureId],
  /** Unit of measure for Weight column.
   * Points to [[adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]]
   */
  weightunitmeasurecode: Optional[UnitmeasureId],
  /** Product weight.
   * Constraint CK_Product_Weight affecting columns weight: ((weight > 0.00))
   */
  weight: Optional[java.math.BigDecimal],
  /** Number of days required to manufacture the product.
   * Constraint CK_Product_DaysToManufacture affecting columns daystomanufacture: ((daystomanufacture >= 0))
   */
  daystomanufacture: Integer,
  /** R = Road, M = Mountain, T = Touring, S = Standard
   * Constraint CK_Product_ProductLine affecting columns productline: (((upper((productline)::text) = ANY (ARRAY['S'::text, 'T'::text, 'M'::text, 'R'::text])) OR (productline IS NULL)))
   */
  productline: Optional[/* bpchar, max 2 chars */ String],
  /** H = High, M = Medium, L = Low
   * Constraint CK_Product_Class affecting columns class: (((upper((class)::text) = ANY (ARRAY['L'::text, 'M'::text, 'H'::text])) OR (class IS NULL)))
   */
  `class`: Optional[/* bpchar, max 2 chars */ String],
  /** W = Womens, M = Mens, U = Universal
   * Constraint CK_Product_Style affecting columns style: (((upper((style)::text) = ANY (ARRAY['W'::text, 'M'::text, 'U'::text])) OR (style IS NULL)))
   */
  style: Optional[/* bpchar, max 2 chars */ String],
  /** Product is a member of this product subcategory. Foreign key to ProductSubCategory.ProductSubCategoryID.
   * Points to [[adventureworks.production.productsubcategory.ProductsubcategoryRow.productsubcategoryid]]
   */
  productsubcategoryid: Optional[ProductsubcategoryId],
  /** Product is a member of this product model. Foreign key to ProductModel.ProductModelID.
   * Points to [[adventureworks.production.productmodel.ProductmodelRow.productmodelid]]
   */
  productmodelid: Optional[ProductmodelId],
  /** Date the product was available for sale.
   * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate: (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
   */
  sellstartdate: LocalDateTime,
  /** Date the product was no longer available for sale.
   * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate: (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
   */
  sellenddate: Optional[LocalDateTime],
  /** Date the product was discontinued. */
  discontinueddate: Optional[LocalDateTime],
  /** Default: uuid_generate_v1() */
  rowguid: UUID,
  /** Default: now() */
  modifieddate: LocalDateTime
) {
  def id: ProductId = productid

  def toUnsavedRow(
    productid: Defaulted[ProductId],
    makeflag: Defaulted[Flag] = Defaulted.Provided(this.makeflag),
    finishedgoodsflag: Defaulted[Flag] = Defaulted.Provided(this.finishedgoodsflag),
    rowguid: Defaulted[UUID] = Defaulted.Provided(this.rowguid),
    modifieddate: Defaulted[LocalDateTime] = Defaulted.Provided(this.modifieddate)
  ): ProductRowUnsaved = {
    new ProductRowUnsaved(
      name,
      productnumber,
      color,
      safetystocklevel,
      reorderpoint,
      standardcost,
      listprice,
      size,
      sizeunitmeasurecode,
      weightunitmeasurecode,
      weight,
      daystomanufacture,
      productline,
      `class`,
      style,
      productsubcategoryid,
      productmodelid,
      sellstartdate,
      sellenddate,
      discontinueddate,
      productid,
      makeflag,
      finishedgoodsflag,
      rowguid,
      modifieddate
    )
  }
}

object ProductRow {
  val `_rowParser`: RowParser[ProductRow] = {
    new RowParser(java.util.List.of(ProductId.pgType, Name.pgType, PgTypes.text, Flag.pgType, Flag.pgType, PgTypes.text.opt(), PgTypes.int2, PgTypes.int2, PgTypes.numeric, PgTypes.numeric, PgTypes.text.opt(), UnitmeasureId.pgType.opt(), UnitmeasureId.pgType.opt(), PgTypes.numeric.opt(), PgTypes.int4, PgTypes.bpchar.opt(), PgTypes.bpchar.opt(), PgTypes.bpchar.opt(), ProductsubcategoryId.pgType.opt(), ProductmodelId.pgType.opt(), PgTypes.timestamp, PgTypes.timestamp.opt(), PgTypes.timestamp.opt(), PgTypes.uuid, PgTypes.timestamp), (arr: Array[Object]) => new ProductRow(
      arr(0).asInstanceOf[ProductId],
      arr(1).asInstanceOf[Name],
      arr(2).asInstanceOf[String],
      arr(3).asInstanceOf[Flag],
      arr(4).asInstanceOf[Flag],
      arr(5).asInstanceOf[Optional[/* max 15 chars */ String]],
      arr(6).asInstanceOf[java.lang.Short],
      arr(7).asInstanceOf[java.lang.Short],
      arr(8).asInstanceOf[java.math.BigDecimal],
      arr(9).asInstanceOf[java.math.BigDecimal],
      arr(10).asInstanceOf[Optional[/* max 5 chars */ String]],
      arr(11).asInstanceOf[Optional[UnitmeasureId]],
      arr(12).asInstanceOf[Optional[UnitmeasureId]],
      arr(13).asInstanceOf[Optional[java.math.BigDecimal]],
      arr(14).asInstanceOf[Integer],
      arr(15).asInstanceOf[Optional[/* bpchar, max 2 chars */ String]],
      arr(16).asInstanceOf[Optional[/* bpchar, max 2 chars */ String]],
      arr(17).asInstanceOf[Optional[/* bpchar, max 2 chars */ String]],
      arr(18).asInstanceOf[Optional[ProductsubcategoryId]],
      arr(19).asInstanceOf[Optional[ProductmodelId]],
      arr(20).asInstanceOf[LocalDateTime],
      arr(21).asInstanceOf[Optional[LocalDateTime]],
      arr(22).asInstanceOf[Optional[LocalDateTime]],
      arr(23).asInstanceOf[UUID],
      arr(24).asInstanceOf[LocalDateTime]
    ), row => Array[Any](row.productid, row.name, row.productnumber, row.makeflag, row.finishedgoodsflag, row.color, row.safetystocklevel, row.reorderpoint, row.standardcost, row.listprice, row.size, row.sizeunitmeasurecode, row.weightunitmeasurecode, row.weight, row.daystomanufacture, row.productline, row.`class`, row.style, row.productsubcategoryid, row.productmodelid, row.sellstartdate, row.sellenddate, row.discontinueddate, row.rowguid, row.modifieddate))
  }

  given pgText: PgText[ProductRow] = PgText.from(`_rowParser`)
}