/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.document

import adventureworks.customtypes.Defaulted
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.public.Flag
import java.time.LocalDateTime
import java.util.Optional
import java.util.UUID
import typo.runtime.PgText
import typo.runtime.PgTypes
import typo.runtime.RowParser
import typo.runtime.RowParsers

/** Table: production.document
 * Product maintenance documents.
 * Primary key: documentnode
 */
case class DocumentRow(
  /** Title of the document. */
  title: String,
  /** Employee who controls the document.  Foreign key to Employee.BusinessEntityID
   * Points to [[adventureworks.humanresources.employee.EmployeeRow.businessentityid]]
   */
  owner: BusinessentityId,
  /** 0 = This is a folder, 1 = This is a document.
   * Default: false
   */
  folderflag: Flag,
  /** File name of the document */
  filename: String,
  /** File extension indicating the document type. For example, .doc or .txt. */
  fileextension: Optional[/* max 8 chars */ String],
  /** Revision number of the document. */
  revision: String,
  /** Engineering change approval number.
   * Default: 0
   */
  changenumber: Integer,
  /** 1 = Pending approval, 2 = Approved, 3 = Obsolete
   * Constraint CK_Document_Status affecting columns status: (((status >= 1) AND (status <= 3)))
   */
  status: java.lang.Short,
  /** Document abstract. */
  documentsummary: Optional[String],
  /** Complete document. */
  document: Optional[Array[scala.Byte]],
  /** ROWGUIDCOL number uniquely identifying the record. Required for FileStream.
   * Default: uuid_generate_v1()
   */
  rowguid: UUID,
  /** Default: now() */
  modifieddate: LocalDateTime,
  /** Primary key for Document records.
   * Default: '/'::character varying
   */
  documentnode: DocumentId
) {
  def id: DocumentId = documentnode

  def toUnsavedRow(
    documentnode: Defaulted[DocumentId],
    folderflag: Defaulted[Flag] = Defaulted.Provided(this.folderflag),
    changenumber: Defaulted[Integer] = Defaulted.Provided(this.changenumber),
    rowguid: Defaulted[UUID] = Defaulted.Provided(this.rowguid),
    modifieddate: Defaulted[LocalDateTime] = Defaulted.Provided(this.modifieddate)
  ): DocumentRowUnsaved = {
    new DocumentRowUnsaved(
      title,
      owner,
      filename,
      fileextension,
      revision,
      status,
      documentsummary,
      document,
      folderflag,
      changenumber,
      rowguid,
      modifieddate,
      documentnode
    )
  }
}

object DocumentRow {
  val `_rowParser`: RowParser[DocumentRow] = {
    RowParsers.of(PgTypes.text, BusinessentityId.pgType, Flag.pgType, PgTypes.text, PgTypes.text.opt(), PgTypes.bpchar, PgTypes.int4, PgTypes.int2, PgTypes.text.opt(), PgTypes.bytea.opt(), PgTypes.uuid, PgTypes.timestamp, DocumentId.pgType, (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) => new DocumentRow(
      t0,
      t1,
      t2,
      t3,
      t4,
      t5,
      t6,
      t7,
      t8,
      t9,
      t10,
      t11,
      t12
    ), row => Array[Any](row.title, row.owner, row.folderflag, row.filename, row.fileextension, row.revision, row.changenumber, row.status, row.documentsummary, row.document, row.rowguid, row.modifieddate, row.documentnode))
  }

  given pgText: PgText[DocumentRow] = PgText.from(`_rowParser`)
}