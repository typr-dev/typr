/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.humanresources.employeedepartmenthistory

import adventureworks.customtypes.Defaulted
import adventureworks.humanresources.department.DepartmentId
import adventureworks.humanresources.shift.ShiftId
import adventureworks.person.businessentity.BusinessentityId
import java.time.LocalDate
import java.time.LocalDateTime
import java.util.Optional
import typo.runtime.PgText
import typo.runtime.PgTypes
import typo.runtime.RowParser
import typo.runtime.RowParsers

/** Table: humanresources.employeedepartmenthistory
 * Employee department transfers.
 * Composite primary key: businessentityid, startdate, departmentid, shiftid
 */
case class EmployeedepartmenthistoryRow(
  /** Employee identification number. Foreign key to Employee.BusinessEntityID.
   * Points to [[adventureworks.humanresources.employee.EmployeeRow.businessentityid]]
   */
  businessentityid: BusinessentityId,
  /** Department in which the employee worked including currently. Foreign key to Department.DepartmentID.
   * Points to [[adventureworks.humanresources.department.DepartmentRow.departmentid]]
   */
  departmentid: DepartmentId,
  /** Identifies which 8-hour shift the employee works. Foreign key to Shift.Shift.ID.
   * Points to [[adventureworks.humanresources.shift.ShiftRow.shiftid]]
   */
  shiftid: ShiftId,
  /** Date the employee started work in the department.
   * Constraint CK_EmployeeDepartmentHistory_EndDate affecting columns enddate, startdate: (((enddate >= startdate) OR (enddate IS NULL)))
   */
  startdate: LocalDate,
  /** Date the employee left the department. NULL = Current department.
   * Constraint CK_EmployeeDepartmentHistory_EndDate affecting columns enddate, startdate: (((enddate >= startdate) OR (enddate IS NULL)))
   */
  enddate: Optional[LocalDate],
  /** Default: now() */
  modifieddate: LocalDateTime
) {
  def compositeId: EmployeedepartmenthistoryId = {
    new EmployeedepartmenthistoryId(
      businessentityid,
      startdate,
      departmentid,
      shiftid
    )
  }

  def id: EmployeedepartmenthistoryId = this.compositeId

  def toUnsavedRow(modifieddate: Defaulted[LocalDateTime] = Defaulted.Provided(this.modifieddate)): EmployeedepartmenthistoryRowUnsaved = {
    new EmployeedepartmenthistoryRowUnsaved(
      businessentityid,
      departmentid,
      shiftid,
      startdate,
      enddate,
      modifieddate
    )
  }
}

object EmployeedepartmenthistoryRow {
  val `_rowParser`: RowParser[EmployeedepartmenthistoryRow] = {
    RowParsers.of(BusinessentityId.pgType, DepartmentId.pgType, ShiftId.pgType, PgTypes.date, PgTypes.date.opt(), PgTypes.timestamp, (t0, t1, t2, t3, t4, t5) => new EmployeedepartmenthistoryRow(
      t0,
      t1,
      t2,
      t3,
      t4,
      t5
    ), row => Array[Any](row.businessentityid, row.departmentid, row.shiftid, row.startdate, row.enddate, row.modifieddate))
  }

  def apply(
    compositeId: EmployeedepartmenthistoryId,
    enddate: Optional[LocalDate],
    modifieddate: LocalDateTime
  ): EmployeedepartmenthistoryRow = {
    new EmployeedepartmenthistoryRow(
      compositeId.businessentityid,
      compositeId.departmentid,
      compositeId.shiftid,
      compositeId.startdate,
      enddate,
      modifieddate
    )
  }

  given pgText: PgText[EmployeedepartmenthistoryRow] = PgText.from(`_rowParser`)
}