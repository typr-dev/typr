/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.billofmaterials

import adventureworks.customtypes.Defaulted
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.time.LocalDateTime
import typo.runtime.PgText
import typo.runtime.PgTypes
import typo.scaladsl.PgTypeOps
import typo.scaladsl.RowParser
import typo.scaladsl.RowParsers
import typo.scaladsl.ScalaDbTypes

/** Table: production.billofmaterials
 * Items required to make bicycles and bicycle subassemblies. It identifies the heirarchical relationship between a parent product and its components.
 * Primary key: billofmaterialsid
 */
case class BillofmaterialsRow(
  /** Primary key for BillOfMaterials records.
   * Default: nextval('production.billofmaterials_billofmaterialsid_seq'::regclass)
   */
  billofmaterialsid: Int,
  /** Parent product identification number. Foreign key to Product.ProductID.
   * Points to [[adventureworks.production.product.ProductRow.productid]]
   * Constraint CK_BillOfMaterials_BOMLevel affecting columns bomlevel, perassemblyqty, productassemblyid: ((((productassemblyid IS NULL) AND (bomlevel = 0) AND (perassemblyqty = 1.00)) OR ((productassemblyid IS NOT NULL) AND (bomlevel >= 1))))
   * Constraint CK_BillOfMaterials_ProductAssemblyID affecting columns componentid, productassemblyid: ((productassemblyid <> componentid))
   */
  productassemblyid: Option[ProductId],
  /** Component identification number. Foreign key to Product.ProductID.
   * Points to [[adventureworks.production.product.ProductRow.productid]]
   * Constraint CK_BillOfMaterials_ProductAssemblyID affecting columns componentid, productassemblyid: ((productassemblyid <> componentid))
   */
  componentid: ProductId,
  /** Date the component started being used in the assembly item.
   * Default: now()
   * Constraint CK_BillOfMaterials_EndDate affecting columns enddate, startdate: (((enddate > startdate) OR (enddate IS NULL)))
   */
  startdate: LocalDateTime,
  /** Date the component stopped being used in the assembly item.
   * Constraint CK_BillOfMaterials_EndDate affecting columns enddate, startdate: (((enddate > startdate) OR (enddate IS NULL)))
   */
  enddate: Option[LocalDateTime],
  /** Standard code identifying the unit of measure for the quantity.
   * Points to [[adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]]
   */
  unitmeasurecode: UnitmeasureId,
  /** Indicates the depth the component is from its parent (AssemblyID).
   * Constraint CK_BillOfMaterials_BOMLevel affecting columns bomlevel, perassemblyqty, productassemblyid: ((((productassemblyid IS NULL) AND (bomlevel = 0) AND (perassemblyqty = 1.00)) OR ((productassemblyid IS NOT NULL) AND (bomlevel >= 1))))
   */
  bomlevel: Short,
  /** Quantity of the component needed to create the assembly.
   * Default: 1.00
   * Constraint CK_BillOfMaterials_BOMLevel affecting columns bomlevel, perassemblyqty, productassemblyid: ((((productassemblyid IS NULL) AND (bomlevel = 0) AND (perassemblyqty = 1.00)) OR ((productassemblyid IS NOT NULL) AND (bomlevel >= 1))))
   * Constraint CK_BillOfMaterials_PerAssemblyQty affecting columns perassemblyqty: ((perassemblyqty >= 1.00))
   */
  perassemblyqty: BigDecimal,
  /** Default: now() */
  modifieddate: LocalDateTime
) {
  def id: Int = billofmaterialsid

  def toUnsavedRow(
    billofmaterialsid: Defaulted[Int],
    startdate: Defaulted[LocalDateTime] = Defaulted.Provided(this.startdate),
    perassemblyqty: Defaulted[BigDecimal] = Defaulted.Provided(this.perassemblyqty),
    modifieddate: Defaulted[LocalDateTime] = Defaulted.Provided(this.modifieddate)
  ): BillofmaterialsRowUnsaved = {
    new BillofmaterialsRowUnsaved(
      productassemblyid,
      componentid,
      enddate,
      unitmeasurecode,
      bomlevel,
      billofmaterialsid,
      startdate,
      perassemblyqty,
      modifieddate
    )
  }
}

object BillofmaterialsRow {
  val `_rowParser`: RowParser[BillofmaterialsRow] = RowParsers.of(ScalaDbTypes.PgTypes.int4, ProductId.pgType.nullable, ProductId.pgType, PgTypes.timestamp, PgTypes.timestamp.nullable, UnitmeasureId.pgType, ScalaDbTypes.PgTypes.int2, ScalaDbTypes.PgTypes.numeric, PgTypes.timestamp)(BillofmaterialsRow.apply)(row => Array[Any](row.billofmaterialsid, row.productassemblyid, row.componentid, row.startdate, row.enddate, row.unitmeasurecode, row.bomlevel, row.perassemblyqty, row.modifieddate))

  given pgText: PgText[BillofmaterialsRow] = PgText.from(`_rowParser`.underlying)
}