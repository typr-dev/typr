/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.mariatest_identity

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.runtime.MariaTypes

class MariatestIdentityRepoImpl() : MariatestIdentityRepo {
  override fun delete(): DeleteBuilder<MariatestIdentityFields, MariatestIdentityRow> = DeleteBuilder.of("`mariatest_identity`", MariatestIdentityFields.structure, Dialect.MARIADB)

  override fun deleteById(
    id: MariatestIdentityId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from `mariatest_identity` where `id` = "), Fragment.encode(MariatestIdentityId.pgType, id), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    ids: Array<MariatestIdentityId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in ids) { fragments.add(Fragment.encode(MariatestIdentityId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("delete from `mariatest_identity` where `id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: MariatestIdentityRow,
    c: Connection
  ): MariatestIdentityRow = Fragment.interpolate(Fragment.lit("insert into `mariatest_identity`(`name`)\nvalues ("), Fragment.encode(MariaTypes.varchar, unsaved.name), Fragment.lit(")\nRETURNING `id`, `name`\n"))
    .updateReturning(MariatestIdentityRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: MariatestIdentityRowUnsaved,
    c: Connection
  ): MariatestIdentityRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("`name`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.name), Fragment.lit("")))
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into `mariatest_identity`("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING `id`, `name`\n"))
    return q.updateReturning(MariatestIdentityRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<MariatestIdentityFields, MariatestIdentityRow> = SelectBuilder.of("`mariatest_identity`", MariatestIdentityFields.structure, MariatestIdentityRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<MariatestIdentityRow> = Fragment.interpolate(Fragment.lit("select `id`, `name`\nfrom `mariatest_identity`\n")).query(MariatestIdentityRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    id: MariatestIdentityId,
    c: Connection
  ): MariatestIdentityRow? = Fragment.interpolate(Fragment.lit("select `id`, `name`\nfrom `mariatest_identity`\nwhere `id` = "), Fragment.encode(MariatestIdentityId.pgType, id), Fragment.lit("")).query(MariatestIdentityRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    ids: Array<MariatestIdentityId>,
    c: Connection
  ): List<MariatestIdentityRow> {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in ids) { fragments.add(Fragment.encode(MariatestIdentityId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("select `id`, `name` from `mariatest_identity` where `id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).query(MariatestIdentityRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    ids: Array<MariatestIdentityId>,
    c: Connection
  ): Map<MariatestIdentityId, MariatestIdentityRow> {
    val ret: MutableMap<MariatestIdentityId, MariatestIdentityRow> = mutableMapOf<MariatestIdentityId, MariatestIdentityRow>()
    selectByIds(ids, c).forEach({ row -> ret.put(row.id, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<MariatestIdentityFields, MariatestIdentityRow> = UpdateBuilder.of("`mariatest_identity`", MariatestIdentityFields.structure, MariatestIdentityRow._rowParser, Dialect.MARIADB)

  override fun update(
    row: MariatestIdentityRow,
    c: Connection
  ): Boolean {
    val id: MariatestIdentityId = row.id
    return Fragment.interpolate(Fragment.lit("update `mariatest_identity`\nset `name` = "), Fragment.encode(MariaTypes.varchar, row.name), Fragment.lit("\nwhere `id` = "), Fragment.encode(MariatestIdentityId.pgType, id), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: MariatestIdentityRow,
    c: Connection
  ): MariatestIdentityRow = Fragment.interpolate(Fragment.lit("INSERT INTO `mariatest_identity`(`name`)\nVALUES ("), Fragment.encode(MariaTypes.varchar, unsaved.name), Fragment.lit(")\nON DUPLICATE KEY UPDATE `name` = VALUES(`name`)\nRETURNING `id`, `name`"))
    .updateReturning(MariatestIdentityRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<MariatestIdentityRow>,
    c: Connection
  ): List<MariatestIdentityRow> = Fragment.interpolate(Fragment.lit("INSERT INTO `mariatest_identity`(`id`, `name`)\nVALUES (?, ?)\nON DUPLICATE KEY UPDATE `name` = VALUES(`name`)\nRETURNING `id`, `name`"))
    .updateReturningEach(MariatestIdentityRow._rowParser, unsaved)
  .runUnchecked(c)
}