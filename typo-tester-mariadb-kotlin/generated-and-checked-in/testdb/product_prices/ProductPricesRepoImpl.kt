/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.product_prices

import java.sql.Connection
import java.util.ArrayList
import java.util.Optional
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableIterator
import kotlin.collections.MutableMap
import testdb.price_tiers.PriceTiersId
import testdb.products.ProductsId
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.MariaTypes
import typo.runtime.Fragment.interpolate

class ProductPricesRepoImpl() : ProductPricesRepo {
  override fun delete(): DeleteBuilder<ProductPricesFields, ProductPricesRow> = DeleteBuilder.of("`product_prices`", ProductPricesFields.structure, Dialect.MARIADB)

  override fun deleteById(
    priceId: ProductPricesId,
    c: Connection
  ): Boolean = interpolate(
    typo.runtime.Fragment.lit("delete from `product_prices` where `price_id` = "),
    ProductPricesId.pgType.encode(priceId),
    typo.runtime.Fragment.lit("")
  ).update().runUnchecked(c) > 0

  override fun deleteByIds(
    priceIds: Array<ProductPricesId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList<Fragment>()
    for (id in priceIds) { fragments.add(ProductPricesId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("delete from `product_prices` where `price_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: ProductPricesRow,
    c: Connection
  ): ProductPricesRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into `product_prices`(`product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`)
      values (""".trimMargin()),
    ProductsId.pgType.encode(unsaved.productId),
    typo.runtime.Fragment.lit(", "),
    PriceTiersId.pgType.opt().encode(unsaved.tierId),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.numeric.encode(unsaved.price),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.encode(unsaved.currencyCode),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.date.encode(unsaved.validFrom),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.date.opt().encode(unsaved.validTo),
    typo.runtime.Fragment.lit("""
      )
      returning `price_id`, `product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`
    """.trimMargin())
  )
    .updateReturning(ProductPricesRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: ProductPricesRowUnsaved,
    c: Connection
  ): ProductPricesRow {
    val columns: ArrayList<Literal> = ArrayList<Literal>()
    val values: ArrayList<Fragment> = ArrayList<Fragment>()
    columns.add(Fragment.lit("`product_id`"))
    values.add(interpolate(
      ProductsId.pgType.encode(unsaved.productId),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("`price`"))
    values.add(interpolate(
      MariaTypes.numeric.encode(unsaved.price),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("`valid_from`"))
    values.add(interpolate(
      MariaTypes.date.encode(unsaved.validFrom),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    unsaved.tierId.visit(
      {  },
      { value -> columns.add(Fragment.lit("`tier_id`"))
      values.add(interpolate(
        PriceTiersId.pgType.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.currencyCode.visit(
      {  },
      { value -> columns.add(Fragment.lit("`currency_code`"))
      values.add(interpolate(
        MariaTypes.text.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.validTo.visit(
      {  },
      { value -> columns.add(Fragment.lit("`valid_to`"))
      values.add(interpolate(
        MariaTypes.date.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    val q: Fragment = interpolate(
      typo.runtime.Fragment.lit("insert into `product_prices`("),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
        )
        values (""".trimMargin()),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
        )
        returning `price_id`, `product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`
      """.trimMargin())
    )
    return q.updateReturning(ProductPricesRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<ProductPricesFields, ProductPricesRow> = SelectBuilder.of("`product_prices`", ProductPricesFields.structure, ProductPricesRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<ProductPricesRow> = interpolate(typo.runtime.Fragment.lit("""
    select `price_id`, `product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`
    from `product_prices`
  """.trimMargin())).query(ProductPricesRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    priceId: ProductPricesId,
    c: Connection
  ): Optional<ProductPricesRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select `price_id`, `product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`
      from `product_prices`
      where `price_id` = """.trimMargin()),
    ProductPricesId.pgType.encode(priceId),
    typo.runtime.Fragment.lit("")
  ).query(ProductPricesRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    priceIds: Array<ProductPricesId>,
    c: Connection
  ): List<ProductPricesRow> {
    val fragments: ArrayList<Fragment> = ArrayList<Fragment>()
    for (id in priceIds) { fragments.add(ProductPricesId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("select `price_id`, `product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to` from `product_prices` where `price_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).query(ProductPricesRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    priceIds: Array<ProductPricesId>,
    c: Connection
  ): Map<ProductPricesId, ProductPricesRow> {
    val ret: MutableMap<ProductPricesId, ProductPricesRow> = mutableMapOf<ProductPricesId, ProductPricesRow>()
    selectByIds(priceIds, c).forEach({ row -> ret.put(row.priceId, row) })
    return ret
  }

  override fun update(): UpdateBuilder<ProductPricesFields, ProductPricesRow> = UpdateBuilder.of("`product_prices`", ProductPricesFields.structure, ProductPricesRow._rowParser.all(), Dialect.MARIADB)

  override fun update(
    row: ProductPricesRow,
    c: Connection
  ): Boolean {
    val priceId: ProductPricesId = row.priceId
    return interpolate(
      typo.runtime.Fragment.lit("""
        update `product_prices`
        set `product_id` = """.trimMargin()),
      ProductsId.pgType.encode(row.productId),
      typo.runtime.Fragment.lit("""
        ,
        `tier_id` = """.trimMargin()),
      PriceTiersId.pgType.opt().encode(row.tierId),
      typo.runtime.Fragment.lit("""
        ,
        `price` = """.trimMargin()),
      MariaTypes.numeric.encode(row.price),
      typo.runtime.Fragment.lit("""
        ,
        `currency_code` = """.trimMargin()),
      MariaTypes.text.encode(row.currencyCode),
      typo.runtime.Fragment.lit("""
        ,
        `valid_from` = """.trimMargin()),
      MariaTypes.date.encode(row.validFrom),
      typo.runtime.Fragment.lit("""
        ,
        `valid_to` = """.trimMargin()),
      MariaTypes.date.opt().encode(row.validTo),
      typo.runtime.Fragment.lit("""
  
        where `price_id` = """.trimMargin()),
      ProductPricesId.pgType.encode(priceId),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: ProductPricesRow,
    c: Connection
  ): ProductPricesRow = interpolate(
    typo.runtime.Fragment.lit("""
      INSERT INTO `product_prices`(`product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`)
      VALUES (""".trimMargin()),
    ProductsId.pgType.encode(unsaved.productId),
    typo.runtime.Fragment.lit(", "),
    PriceTiersId.pgType.opt().encode(unsaved.tierId),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.numeric.encode(unsaved.price),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.encode(unsaved.currencyCode),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.date.encode(unsaved.validFrom),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.date.opt().encode(unsaved.validTo),
    typo.runtime.Fragment.lit("""
      )
      ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),
      `tier_id` = VALUES(`tier_id`),
      `price` = VALUES(`price`),
      `currency_code` = VALUES(`currency_code`),
      `valid_from` = VALUES(`valid_from`),
      `valid_to` = VALUES(`valid_to`)
      RETURNING `price_id`, `product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`""".trimMargin())
  )
    .updateReturning(ProductPricesRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: MutableIterator<ProductPricesRow>,
    c: Connection
  ): List<ProductPricesRow> = interpolate(typo.runtime.Fragment.lit("""
                                INSERT INTO `product_prices`(`price_id`, `product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`)
                                VALUES (?, ?, ?, ?, ?, ?, ?)
                                ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),
                                `tier_id` = VALUES(`tier_id`),
                                `price` = VALUES(`price`),
                                `currency_code` = VALUES(`currency_code`),
                                `valid_from` = VALUES(`valid_from`),
                                `valid_to` = VALUES(`valid_to`)
                                RETURNING `price_id`, `product_id`, `tier_id`, `price`, `currency_code`, `valid_from`, `valid_to`""".trimMargin()))
    .updateReturningEach(ProductPricesRow._rowParser, unsaved)
    .runUnchecked(c)
}