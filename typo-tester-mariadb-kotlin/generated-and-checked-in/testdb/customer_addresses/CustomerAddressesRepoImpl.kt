/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.customer_addresses

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import testdb.customers.CustomersId
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.KotlinDbTypes
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.kotlindsl.nullable
import typo.runtime.MariaTypes

class CustomerAddressesRepoImpl() : CustomerAddressesRepo {
  override fun delete(): DeleteBuilder<CustomerAddressesFields, CustomerAddressesRow> = DeleteBuilder.of("`customer_addresses`", CustomerAddressesFields.structure, Dialect.MARIADB)

  override fun deleteById(
    addressId: CustomerAddressesId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from `customer_addresses` where `address_id` = "), Fragment.encode(CustomerAddressesId.pgType, addressId), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    addressIds: Array<CustomerAddressesId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in addressIds) { fragments.add(Fragment.encode(CustomerAddressesId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("delete from `customer_addresses` where `address_id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: CustomerAddressesRow,
    c: Connection
  ): CustomerAddressesRow = Fragment.interpolate(Fragment.lit("insert into `customer_addresses`(`customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`)\nvalues ("), Fragment.encode(CustomersId.pgType, unsaved.customerId), Fragment.lit(", "), Fragment.encode(MariaTypes.text, unsaved.addressType), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.bool, unsaved.isDefault), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.recipientName), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.streetLine1), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.streetLine2), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.city), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.stateProvince), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.postalCode), Fragment.lit(", "), Fragment.encode(MariaTypes.char_, unsaved.countryCode), Fragment.lit(", "), Fragment.encode(MariaTypes.point.nullable(), unsaved.location), Fragment.lit(", "), Fragment.encode(MariaTypes.tinytext.nullable(), unsaved.deliveryNotes), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime, unsaved.createdAt), Fragment.lit(")\nRETURNING `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`\n"))
    .updateReturning(CustomerAddressesRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: CustomerAddressesRowUnsaved,
    c: Connection
  ): CustomerAddressesRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("`customer_id`"))
    values.add(Fragment.interpolate(Fragment.encode(CustomersId.pgType, unsaved.customerId), Fragment.lit("")))
    columns.add(Fragment.lit("`address_type`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.text, unsaved.addressType), Fragment.lit("")))
    columns.add(Fragment.lit("`recipient_name`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.recipientName), Fragment.lit("")))
    columns.add(Fragment.lit("`street_line1`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.streetLine1), Fragment.lit("")))
    columns.add(Fragment.lit("`city`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.city), Fragment.lit("")))
    columns.add(Fragment.lit("`postal_code`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar, unsaved.postalCode), Fragment.lit("")))
    columns.add(Fragment.lit("`country_code`"))
    values.add(Fragment.interpolate(Fragment.encode(MariaTypes.char_, unsaved.countryCode), Fragment.lit("")))
    unsaved.isDefault.visit(
      {  },
      { value -> columns.add(Fragment.lit("`is_default`"))
      values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.MariaTypes.bool, value), Fragment.lit(""))) }
    );
    unsaved.streetLine2.visit(
      {  },
      { value -> columns.add(Fragment.lit("`street_line2`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.stateProvince.visit(
      {  },
      { value -> columns.add(Fragment.lit("`state_province`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.varchar.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.location.visit(
      {  },
      { value -> columns.add(Fragment.lit("`location`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.point.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.deliveryNotes.visit(
      {  },
      { value -> columns.add(Fragment.lit("`delivery_notes`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.tinytext.nullable(), value), Fragment.lit(""))) }
    );
    unsaved.createdAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`created_at`"))
      values.add(Fragment.interpolate(Fragment.encode(MariaTypes.datetime, value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into `customer_addresses`("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`\n"))
    return q.updateReturning(CustomerAddressesRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<CustomerAddressesFields, CustomerAddressesRow> = SelectBuilder.of("`customer_addresses`", CustomerAddressesFields.structure, CustomerAddressesRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<CustomerAddressesRow> = Fragment.interpolate(Fragment.lit("select `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`\nfrom `customer_addresses`\n")).query(CustomerAddressesRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    addressId: CustomerAddressesId,
    c: Connection
  ): CustomerAddressesRow? = Fragment.interpolate(Fragment.lit("select `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`\nfrom `customer_addresses`\nwhere `address_id` = "), Fragment.encode(CustomerAddressesId.pgType, addressId), Fragment.lit("")).query(CustomerAddressesRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    addressIds: Array<CustomerAddressesId>,
    c: Connection
  ): List<CustomerAddressesRow> {
    val fragments: ArrayList<Fragment> = ArrayList()
    for (id in addressIds) { fragments.add(Fragment.encode(CustomerAddressesId.pgType, id)) }
    return Fragment.interpolate(Fragment.lit("select `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at` from `customer_addresses` where `address_id` in ("), Fragment.comma(fragments.toMutableList()), Fragment.lit(")")).query(CustomerAddressesRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    addressIds: Array<CustomerAddressesId>,
    c: Connection
  ): Map<CustomerAddressesId, CustomerAddressesRow> {
    val ret: MutableMap<CustomerAddressesId, CustomerAddressesRow> = mutableMapOf<CustomerAddressesId, CustomerAddressesRow>()
    selectByIds(addressIds, c).forEach({ row -> ret.put(row.addressId, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<CustomerAddressesFields, CustomerAddressesRow> = UpdateBuilder.of("`customer_addresses`", CustomerAddressesFields.structure, CustomerAddressesRow._rowParser, Dialect.MARIADB)

  override fun update(
    row: CustomerAddressesRow,
    c: Connection
  ): Boolean {
    val addressId: CustomerAddressesId = row.addressId
    return Fragment.interpolate(Fragment.lit("update `customer_addresses`\nset `customer_id` = "), Fragment.encode(CustomersId.pgType, row.customerId), Fragment.lit(",\n`address_type` = "), Fragment.encode(MariaTypes.text, row.addressType), Fragment.lit(",\n`is_default` = "), Fragment.encode(KotlinDbTypes.MariaTypes.bool, row.isDefault), Fragment.lit(",\n`recipient_name` = "), Fragment.encode(MariaTypes.varchar, row.recipientName), Fragment.lit(",\n`street_line1` = "), Fragment.encode(MariaTypes.varchar, row.streetLine1), Fragment.lit(",\n`street_line2` = "), Fragment.encode(MariaTypes.varchar.nullable(), row.streetLine2), Fragment.lit(",\n`city` = "), Fragment.encode(MariaTypes.varchar, row.city), Fragment.lit(",\n`state_province` = "), Fragment.encode(MariaTypes.varchar.nullable(), row.stateProvince), Fragment.lit(",\n`postal_code` = "), Fragment.encode(MariaTypes.varchar, row.postalCode), Fragment.lit(",\n`country_code` = "), Fragment.encode(MariaTypes.char_, row.countryCode), Fragment.lit(",\n`location` = "), Fragment.encode(MariaTypes.point.nullable(), row.location), Fragment.lit(",\n`delivery_notes` = "), Fragment.encode(MariaTypes.tinytext.nullable(), row.deliveryNotes), Fragment.lit(",\n`created_at` = "), Fragment.encode(MariaTypes.datetime, row.createdAt), Fragment.lit("\nwhere `address_id` = "), Fragment.encode(CustomerAddressesId.pgType, addressId), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: CustomerAddressesRow,
    c: Connection
  ): CustomerAddressesRow = Fragment.interpolate(Fragment.lit("INSERT INTO `customer_addresses`(`customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`)\nVALUES ("), Fragment.encode(CustomersId.pgType, unsaved.customerId), Fragment.lit(", "), Fragment.encode(MariaTypes.text, unsaved.addressType), Fragment.lit(", "), Fragment.encode(KotlinDbTypes.MariaTypes.bool, unsaved.isDefault), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.recipientName), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.streetLine1), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.streetLine2), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.city), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar.nullable(), unsaved.stateProvince), Fragment.lit(", "), Fragment.encode(MariaTypes.varchar, unsaved.postalCode), Fragment.lit(", "), Fragment.encode(MariaTypes.char_, unsaved.countryCode), Fragment.lit(", "), Fragment.encode(MariaTypes.point.nullable(), unsaved.location), Fragment.lit(", "), Fragment.encode(MariaTypes.tinytext.nullable(), unsaved.deliveryNotes), Fragment.lit(", "), Fragment.encode(MariaTypes.datetime, unsaved.createdAt), Fragment.lit(")\nON DUPLICATE KEY UPDATE `customer_id` = VALUES(`customer_id`),\n`address_type` = VALUES(`address_type`),\n`is_default` = VALUES(`is_default`),\n`recipient_name` = VALUES(`recipient_name`),\n`street_line1` = VALUES(`street_line1`),\n`street_line2` = VALUES(`street_line2`),\n`city` = VALUES(`city`),\n`state_province` = VALUES(`state_province`),\n`postal_code` = VALUES(`postal_code`),\n`country_code` = VALUES(`country_code`),\n`location` = VALUES(`location`),\n`delivery_notes` = VALUES(`delivery_notes`),\n`created_at` = VALUES(`created_at`)\nRETURNING `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`"))
    .updateReturning(CustomerAddressesRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<CustomerAddressesRow>,
    c: Connection
  ): List<CustomerAddressesRow> = Fragment.interpolate(Fragment.lit("INSERT INTO `customer_addresses`(`address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`)\nVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\nON DUPLICATE KEY UPDATE `customer_id` = VALUES(`customer_id`),\n`address_type` = VALUES(`address_type`),\n`is_default` = VALUES(`is_default`),\n`recipient_name` = VALUES(`recipient_name`),\n`street_line1` = VALUES(`street_line1`),\n`street_line2` = VALUES(`street_line2`),\n`city` = VALUES(`city`),\n`state_province` = VALUES(`state_province`),\n`postal_code` = VALUES(`postal_code`),\n`country_code` = VALUES(`country_code`),\n`location` = VALUES(`location`),\n`delivery_notes` = VALUES(`delivery_notes`),\n`created_at` = VALUES(`created_at`)\nRETURNING `address_id`, `customer_id`, `address_type`, `is_default`, `recipient_name`, `street_line1`, `street_line2`, `city`, `state_province`, `postal_code`, `country_code`, `location`, `delivery_notes`, `created_at`"))
    .updateReturningEach(CustomerAddressesRow._rowParser, unsaved)
  .runUnchecked(c)
}