/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.inventory

import com.fasterxml.jackson.annotation.JsonProperty
import java.time.LocalDateTime
import java.util.Optional
import testdb.customtypes.Defaulted
import testdb.customtypes.Defaulted.UseDefault
import testdb.products.ProductsId
import testdb.warehouses.WarehousesId
import typo.runtime.MariaText
import typo.runtime.MariaTypes

/** This class corresponds to a row in table `inventory` which has not been persisted yet */
data class InventoryRowUnsaved(
  /** 
    * Points to [testdb.products.ProductsRow.productId]
    */
  @JsonProperty("product_id") val productId: ProductsId,
  /** 
    * Points to [testdb.warehouses.WarehousesRow.warehouseId]
    */
  @JsonProperty("warehouse_id") val warehouseId: WarehousesId,
  /** Default: 0

    */
  @JsonProperty("quantity_on_hand") val quantityOnHand: Defaulted<Int> = UseDefault(),
  /** Default: 0

    */
  @JsonProperty("quantity_reserved") val quantityReserved: Defaulted<Int> = UseDefault(),
  /** Default: 0

    */
  @JsonProperty("quantity_on_order") val quantityOnOrder: Defaulted<Int> = UseDefault(),
  /** Default: 0

    */
  @JsonProperty("reorder_point") val reorderPoint: Defaulted<Int> = UseDefault(),
  /** Default: 0

    */
  @JsonProperty("reorder_quantity") val reorderQuantity: Defaulted<Int> = UseDefault(),
  /** Default: NULL

    */
  @JsonProperty("bin_location") val binLocation: Defaulted<Optional<String>> = UseDefault(),
  /** Default: NULL

    */
  @JsonProperty("last_counted_at") val lastCountedAt: Defaulted<Optional<LocalDateTime>> = UseDefault(),
  /** Default: current_timestamp(6)

    */
  @JsonProperty("updated_at") val updatedAt: Defaulted<LocalDateTime> = UseDefault()
) {
  fun toRow(
    quantityOnHandDefault: () -> Int,
    quantityReservedDefault: () -> Int,
    quantityOnOrderDefault: () -> Int,
    reorderPointDefault: () -> Int,
    reorderQuantityDefault: () -> Int,
    binLocationDefault: () -> Optional<String>,
    lastCountedAtDefault: () -> Optional<LocalDateTime>,
    updatedAtDefault: () -> LocalDateTime,
    inventoryIdDefault: () -> InventoryId
  ): InventoryRow = InventoryRow(inventoryId = inventoryIdDefault(), productId = productId, warehouseId = warehouseId, quantityOnHand = quantityOnHand.getOrElse(quantityOnHandDefault), quantityReserved = quantityReserved.getOrElse(quantityReservedDefault), quantityOnOrder = quantityOnOrder.getOrElse(quantityOnOrderDefault), reorderPoint = reorderPoint.getOrElse(reorderPointDefault), reorderQuantity = reorderQuantity.getOrElse(reorderQuantityDefault), binLocation = binLocation.getOrElse(binLocationDefault), lastCountedAt = lastCountedAt.getOrElse(lastCountedAtDefault), updatedAt = updatedAt.getOrElse(updatedAtDefault))

  companion object {
    val mariaText: MariaText<InventoryRowUnsaved> =
      MariaText.instance({ row, sb -> ProductsId.pgType.mariaText().unsafeEncode(row.productId, sb)
      sb.append(MariaText.DELIMETER)
      WarehousesId.pgType.mariaText().unsafeEncode(row.warehouseId, sb)
      sb.append(MariaText.DELIMETER)
      Defaulted.mariaText(MariaTypes.int_.mariaText()).unsafeEncode(row.quantityOnHand, sb)
      sb.append(MariaText.DELIMETER)
      Defaulted.mariaText(MariaTypes.int_.mariaText()).unsafeEncode(row.quantityReserved, sb)
      sb.append(MariaText.DELIMETER)
      Defaulted.mariaText(MariaTypes.int_.mariaText()).unsafeEncode(row.quantityOnOrder, sb)
      sb.append(MariaText.DELIMETER)
      Defaulted.mariaText(MariaTypes.int_.mariaText()).unsafeEncode(row.reorderPoint, sb)
      sb.append(MariaText.DELIMETER)
      Defaulted.mariaText(MariaTypes.int_.mariaText()).unsafeEncode(row.reorderQuantity, sb)
      sb.append(MariaText.DELIMETER)
      Defaulted.mariaText(MariaTypes.varchar.opt().mariaText()).unsafeEncode(row.binLocation, sb)
      sb.append(MariaText.DELIMETER)
      Defaulted.mariaText(MariaTypes.datetime.opt().mariaText()).unsafeEncode(row.lastCountedAt, sb)
      sb.append(MariaText.DELIMETER)
      Defaulted.mariaText(MariaTypes.datetime.mariaText()).unsafeEncode(row.updatedAt, sb) })
  }
}