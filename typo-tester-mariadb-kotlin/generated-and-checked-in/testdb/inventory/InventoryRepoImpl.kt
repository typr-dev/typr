/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.inventory

import java.sql.Connection
import java.util.ArrayList
import java.util.Optional
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableIterator
import kotlin.collections.MutableMap
import testdb.products.ProductsId
import testdb.warehouses.WarehousesId
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.MariaTypes
import typo.runtime.Fragment.interpolate

class InventoryRepoImpl() : InventoryRepo {
  override fun delete(): DeleteBuilder<InventoryFields, InventoryRow> = DeleteBuilder.of("`inventory`", InventoryFields.structure, Dialect.MARIADB)

  override fun deleteById(
    inventoryId: InventoryId,
    c: Connection
  ): Boolean = interpolate(
    typo.runtime.Fragment.lit("delete from `inventory` where `inventory_id` = "),
    InventoryId.pgType.encode(inventoryId),
    typo.runtime.Fragment.lit("")
  ).update().runUnchecked(c) > 0

  override fun deleteByIds(
    inventoryIds: Array<InventoryId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList<Fragment>()
    for (id in inventoryIds) { fragments.add(InventoryId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("delete from `inventory` where `inventory_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: InventoryRow,
    c: Connection
  ): InventoryRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into `inventory`(`product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`)
      values (""".trimMargin()),
    ProductsId.pgType.encode(unsaved.productId),
    typo.runtime.Fragment.lit(", "),
    WarehousesId.pgType.encode(unsaved.warehouseId),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.quantityOnHand),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.quantityReserved),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.quantityOnOrder),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.reorderPoint),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.reorderQuantity),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.opt().encode(unsaved.binLocation),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.datetime.opt().encode(unsaved.lastCountedAt),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.datetime.encode(unsaved.updatedAt),
    typo.runtime.Fragment.lit("""
      )
      returning `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
    """.trimMargin())
  )
    .updateReturning(InventoryRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: InventoryRowUnsaved,
    c: Connection
  ): InventoryRow {
    val columns: ArrayList<Literal> = ArrayList<Literal>()
    val values: ArrayList<Fragment> = ArrayList<Fragment>()
    columns.add(Fragment.lit("`product_id`"))
    values.add(interpolate(
      ProductsId.pgType.encode(unsaved.productId),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("`warehouse_id`"))
    values.add(interpolate(
      WarehousesId.pgType.encode(unsaved.warehouseId),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    unsaved.quantityOnHand.visit(
      {  },
      { value -> columns.add(Fragment.lit("`quantity_on_hand`"))
      values.add(interpolate(
        MariaTypes.int_.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.quantityReserved.visit(
      {  },
      { value -> columns.add(Fragment.lit("`quantity_reserved`"))
      values.add(interpolate(
        MariaTypes.int_.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.quantityOnOrder.visit(
      {  },
      { value -> columns.add(Fragment.lit("`quantity_on_order`"))
      values.add(interpolate(
        MariaTypes.int_.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.reorderPoint.visit(
      {  },
      { value -> columns.add(Fragment.lit("`reorder_point`"))
      values.add(interpolate(
        MariaTypes.int_.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.reorderQuantity.visit(
      {  },
      { value -> columns.add(Fragment.lit("`reorder_quantity`"))
      values.add(interpolate(
        MariaTypes.int_.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.binLocation.visit(
      {  },
      { value -> columns.add(Fragment.lit("`bin_location`"))
      values.add(interpolate(
        MariaTypes.text.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.lastCountedAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`last_counted_at`"))
      values.add(interpolate(
        MariaTypes.datetime.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.updatedAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`updated_at`"))
      values.add(interpolate(
        MariaTypes.datetime.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    val q: Fragment = interpolate(
      typo.runtime.Fragment.lit("insert into `inventory`("),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
        )
        values (""".trimMargin()),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
        )
        returning `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
      """.trimMargin())
    )
    return q.updateReturning(InventoryRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<InventoryFields, InventoryRow> = SelectBuilder.of("`inventory`", InventoryFields.structure, InventoryRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<InventoryRow> = interpolate(typo.runtime.Fragment.lit("""
    select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
    from `inventory`
  """.trimMargin())).query(InventoryRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    inventoryId: InventoryId,
    c: Connection
  ): Optional<InventoryRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
      from `inventory`
      where `inventory_id` = """.trimMargin()),
    InventoryId.pgType.encode(inventoryId),
    typo.runtime.Fragment.lit("")
  ).query(InventoryRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    inventoryIds: Array<InventoryId>,
    c: Connection
  ): List<InventoryRow> {
    val fragments: ArrayList<Fragment> = ArrayList<Fragment>()
    for (id in inventoryIds) { fragments.add(InventoryId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at` from `inventory` where `inventory_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).query(InventoryRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    inventoryIds: Array<InventoryId>,
    c: Connection
  ): Map<InventoryId, InventoryRow> {
    val ret: MutableMap<InventoryId, InventoryRow> = mutableMapOf<InventoryId, InventoryRow>()
    selectByIds(inventoryIds, c).forEach({ row -> ret.put(row.inventoryId, row) })
    return ret
  }

  override fun selectByUniqueProductIdAndWarehouseId(
    productId: ProductsId,
    warehouseId: WarehousesId,
    c: Connection
  ): Optional<InventoryRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`
      from `inventory`
      where `product_id` = """.trimMargin()),
    ProductsId.pgType.encode(productId),
    typo.runtime.Fragment.lit(" AND `warehouse_id` = "),
    WarehousesId.pgType.encode(warehouseId),
    typo.runtime.Fragment.lit("""


    """.trimMargin())
  ).query(InventoryRow._rowParser.first()).runUnchecked(c)

  override fun update(): UpdateBuilder<InventoryFields, InventoryRow> = UpdateBuilder.of("`inventory`", InventoryFields.structure, InventoryRow._rowParser.all(), Dialect.MARIADB)

  override fun update(
    row: InventoryRow,
    c: Connection
  ): Boolean {
    val inventoryId: InventoryId = row.inventoryId
    return interpolate(
      typo.runtime.Fragment.lit("""
        update `inventory`
        set `product_id` = """.trimMargin()),
      ProductsId.pgType.encode(row.productId),
      typo.runtime.Fragment.lit("""
        ,
        `warehouse_id` = """.trimMargin()),
      WarehousesId.pgType.encode(row.warehouseId),
      typo.runtime.Fragment.lit("""
        ,
        `quantity_on_hand` = """.trimMargin()),
      MariaTypes.int_.encode(row.quantityOnHand),
      typo.runtime.Fragment.lit("""
        ,
        `quantity_reserved` = """.trimMargin()),
      MariaTypes.int_.encode(row.quantityReserved),
      typo.runtime.Fragment.lit("""
        ,
        `quantity_on_order` = """.trimMargin()),
      MariaTypes.int_.encode(row.quantityOnOrder),
      typo.runtime.Fragment.lit("""
        ,
        `reorder_point` = """.trimMargin()),
      MariaTypes.int_.encode(row.reorderPoint),
      typo.runtime.Fragment.lit("""
        ,
        `reorder_quantity` = """.trimMargin()),
      MariaTypes.int_.encode(row.reorderQuantity),
      typo.runtime.Fragment.lit("""
        ,
        `bin_location` = """.trimMargin()),
      MariaTypes.text.opt().encode(row.binLocation),
      typo.runtime.Fragment.lit("""
        ,
        `last_counted_at` = """.trimMargin()),
      MariaTypes.datetime.opt().encode(row.lastCountedAt),
      typo.runtime.Fragment.lit("""
        ,
        `updated_at` = """.trimMargin()),
      MariaTypes.datetime.encode(row.updatedAt),
      typo.runtime.Fragment.lit("""
  
        where `inventory_id` = """.trimMargin()),
      InventoryId.pgType.encode(inventoryId),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: InventoryRow,
    c: Connection
  ): InventoryRow = interpolate(
    typo.runtime.Fragment.lit("""
      INSERT INTO `inventory`(`product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`)
      VALUES (""".trimMargin()),
    ProductsId.pgType.encode(unsaved.productId),
    typo.runtime.Fragment.lit(", "),
    WarehousesId.pgType.encode(unsaved.warehouseId),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.quantityOnHand),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.quantityReserved),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.quantityOnOrder),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.reorderPoint),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.int_.encode(unsaved.reorderQuantity),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.opt().encode(unsaved.binLocation),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.datetime.opt().encode(unsaved.lastCountedAt),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.datetime.encode(unsaved.updatedAt),
    typo.runtime.Fragment.lit("""
      )
      ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),
      `warehouse_id` = VALUES(`warehouse_id`),
      `quantity_on_hand` = VALUES(`quantity_on_hand`),
      `quantity_reserved` = VALUES(`quantity_reserved`),
      `quantity_on_order` = VALUES(`quantity_on_order`),
      `reorder_point` = VALUES(`reorder_point`),
      `reorder_quantity` = VALUES(`reorder_quantity`),
      `bin_location` = VALUES(`bin_location`),
      `last_counted_at` = VALUES(`last_counted_at`),
      `updated_at` = VALUES(`updated_at`)
      RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`""".trimMargin())
  )
    .updateReturning(InventoryRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: MutableIterator<InventoryRow>,
    c: Connection
  ): List<InventoryRow> = interpolate(typo.runtime.Fragment.lit("""
                            INSERT INTO `inventory`(`inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`)
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                            ON DUPLICATE KEY UPDATE `product_id` = VALUES(`product_id`),
                            `warehouse_id` = VALUES(`warehouse_id`),
                            `quantity_on_hand` = VALUES(`quantity_on_hand`),
                            `quantity_reserved` = VALUES(`quantity_reserved`),
                            `quantity_on_order` = VALUES(`quantity_on_order`),
                            `reorder_point` = VALUES(`reorder_point`),
                            `reorder_quantity` = VALUES(`reorder_quantity`),
                            `bin_location` = VALUES(`bin_location`),
                            `last_counted_at` = VALUES(`last_counted_at`),
                            `updated_at` = VALUES(`updated_at`)
                            RETURNING `inventory_id`, `product_id`, `warehouse_id`, `quantity_on_hand`, `quantity_reserved`, `quantity_on_order`, `reorder_point`, `reorder_quantity`, `bin_location`, `last_counted_at`, `updated_at`""".trimMargin()))
    .updateReturningEach(InventoryRow._rowParser, unsaved)
    .runUnchecked(c)
}