/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.payments

import java.sql.Connection
import java.util.ArrayList
import java.util.Optional
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableIterator
import kotlin.collections.MutableMap
import testdb.orders.OrdersId
import testdb.payment_methods.PaymentMethodsId
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.MariaTypes
import typo.runtime.Fragment.interpolate

class PaymentsRepoImpl() : PaymentsRepo {
  override fun delete(): DeleteBuilder<PaymentsFields, PaymentsRow> = DeleteBuilder.of("`payments`", PaymentsFields.structure, Dialect.MARIADB)

  override fun deleteById(
    paymentId: PaymentsId,
    c: Connection
  ): Boolean = interpolate(
    typo.runtime.Fragment.lit("delete from `payments` where `payment_id` = "),
    PaymentsId.pgType.encode(paymentId),
    typo.runtime.Fragment.lit("")
  ).update().runUnchecked(c) > 0

  override fun deleteByIds(
    paymentIds: Array<PaymentsId>,
    c: Connection
  ): Int {
    val fragments: ArrayList<Fragment> = ArrayList<Fragment>()
    for (id in paymentIds) { fragments.add(PaymentsId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("delete from `payments` where `payment_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: PaymentsRow,
    c: Connection
  ): PaymentsRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into `payments`(`order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`)
      values (""".trimMargin()),
    OrdersId.pgType.encode(unsaved.orderId),
    typo.runtime.Fragment.lit(", "),
    PaymentMethodsId.pgType.encode(unsaved.methodId),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.opt().encode(unsaved.transactionId),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.numeric.encode(unsaved.amount),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.encode(unsaved.currencyCode),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.encode(unsaved.status),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.opt().encode(unsaved.processorResponse),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.opt().encode(unsaved.errorMessage),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.inet6.opt().encode(unsaved.ipAddress),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.datetime.encode(unsaved.createdAt),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.datetime.opt().encode(unsaved.processedAt),
    typo.runtime.Fragment.lit("""
      )
      returning `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`
    """.trimMargin())
  )
    .updateReturning(PaymentsRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: PaymentsRowUnsaved,
    c: Connection
  ): PaymentsRow {
    val columns: ArrayList<Literal> = ArrayList<Literal>()
    val values: ArrayList<Fragment> = ArrayList<Fragment>()
    columns.add(Fragment.lit("`order_id`"))
    values.add(interpolate(
      OrdersId.pgType.encode(unsaved.orderId),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("`method_id`"))
    values.add(interpolate(
      PaymentMethodsId.pgType.encode(unsaved.methodId),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("`amount`"))
    values.add(interpolate(
      MariaTypes.numeric.encode(unsaved.amount),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    unsaved.transactionId.visit(
      {  },
      { value -> columns.add(Fragment.lit("`transaction_id`"))
      values.add(interpolate(
        MariaTypes.text.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.currencyCode.visit(
      {  },
      { value -> columns.add(Fragment.lit("`currency_code`"))
      values.add(interpolate(
        MariaTypes.text.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.status.visit(
      {  },
      { value -> columns.add(Fragment.lit("`status`"))
      values.add(interpolate(
        MariaTypes.text.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.processorResponse.visit(
      {  },
      { value -> columns.add(Fragment.lit("`processor_response`"))
      values.add(interpolate(
        MariaTypes.text.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.errorMessage.visit(
      {  },
      { value -> columns.add(Fragment.lit("`error_message`"))
      values.add(interpolate(
        MariaTypes.text.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.ipAddress.visit(
      {  },
      { value -> columns.add(Fragment.lit("`ip_address`"))
      values.add(interpolate(
        MariaTypes.inet6.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.createdAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`created_at`"))
      values.add(interpolate(
        MariaTypes.datetime.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    unsaved.processedAt.visit(
      {  },
      { value -> columns.add(Fragment.lit("`processed_at`"))
      values.add(interpolate(
        MariaTypes.datetime.opt().encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    val q: Fragment = interpolate(
      typo.runtime.Fragment.lit("insert into `payments`("),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
        )
        values (""".trimMargin()),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
        )
        returning `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`
      """.trimMargin())
    )
    return q.updateReturning(PaymentsRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun select(): SelectBuilder<PaymentsFields, PaymentsRow> = SelectBuilder.of("`payments`", PaymentsFields.structure, PaymentsRow._rowParser, Dialect.MARIADB)

  override fun selectAll(c: Connection): List<PaymentsRow> = interpolate(typo.runtime.Fragment.lit("""
    select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`
    from `payments`
  """.trimMargin())).query(PaymentsRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    paymentId: PaymentsId,
    c: Connection
  ): Optional<PaymentsRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`
      from `payments`
      where `payment_id` = """.trimMargin()),
    PaymentsId.pgType.encode(paymentId),
    typo.runtime.Fragment.lit("")
  ).query(PaymentsRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    paymentIds: Array<PaymentsId>,
    c: Connection
  ): List<PaymentsRow> {
    val fragments: ArrayList<Fragment> = ArrayList<Fragment>()
    for (id in paymentIds) { fragments.add(PaymentsId.pgType.encode(id)) }
    return Fragment.interpolate(Fragment.lit("select `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at` from `payments` where `payment_id` in ("), Fragment.comma(fragments), Fragment.lit(")")).query(PaymentsRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    paymentIds: Array<PaymentsId>,
    c: Connection
  ): Map<PaymentsId, PaymentsRow> {
    val ret: MutableMap<PaymentsId, PaymentsRow> = mutableMapOf<PaymentsId, PaymentsRow>()
    selectByIds(paymentIds, c).forEach({ row -> ret.put(row.paymentId, row) })
    return ret
  }

  override fun update(): UpdateBuilder<PaymentsFields, PaymentsRow> = UpdateBuilder.of("`payments`", PaymentsFields.structure, PaymentsRow._rowParser.all(), Dialect.MARIADB)

  override fun update(
    row: PaymentsRow,
    c: Connection
  ): Boolean {
    val paymentId: PaymentsId = row.paymentId
    return interpolate(
      typo.runtime.Fragment.lit("""
        update `payments`
        set `order_id` = """.trimMargin()),
      OrdersId.pgType.encode(row.orderId),
      typo.runtime.Fragment.lit("""
        ,
        `method_id` = """.trimMargin()),
      PaymentMethodsId.pgType.encode(row.methodId),
      typo.runtime.Fragment.lit("""
        ,
        `transaction_id` = """.trimMargin()),
      MariaTypes.text.opt().encode(row.transactionId),
      typo.runtime.Fragment.lit("""
        ,
        `amount` = """.trimMargin()),
      MariaTypes.numeric.encode(row.amount),
      typo.runtime.Fragment.lit("""
        ,
        `currency_code` = """.trimMargin()),
      MariaTypes.text.encode(row.currencyCode),
      typo.runtime.Fragment.lit("""
        ,
        `status` = """.trimMargin()),
      MariaTypes.text.encode(row.status),
      typo.runtime.Fragment.lit("""
        ,
        `processor_response` = """.trimMargin()),
      MariaTypes.text.opt().encode(row.processorResponse),
      typo.runtime.Fragment.lit("""
        ,
        `error_message` = """.trimMargin()),
      MariaTypes.text.opt().encode(row.errorMessage),
      typo.runtime.Fragment.lit("""
        ,
        `ip_address` = """.trimMargin()),
      MariaTypes.inet6.opt().encode(row.ipAddress),
      typo.runtime.Fragment.lit("""
        ,
        `created_at` = """.trimMargin()),
      MariaTypes.datetime.encode(row.createdAt),
      typo.runtime.Fragment.lit("""
        ,
        `processed_at` = """.trimMargin()),
      MariaTypes.datetime.opt().encode(row.processedAt),
      typo.runtime.Fragment.lit("""
  
        where `payment_id` = """.trimMargin()),
      PaymentsId.pgType.encode(paymentId),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: PaymentsRow,
    c: Connection
  ): PaymentsRow = interpolate(
    typo.runtime.Fragment.lit("""
      INSERT INTO `payments`(`order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`)
      VALUES (""".trimMargin()),
    OrdersId.pgType.encode(unsaved.orderId),
    typo.runtime.Fragment.lit(", "),
    PaymentMethodsId.pgType.encode(unsaved.methodId),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.opt().encode(unsaved.transactionId),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.numeric.encode(unsaved.amount),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.encode(unsaved.currencyCode),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.encode(unsaved.status),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.opt().encode(unsaved.processorResponse),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.text.opt().encode(unsaved.errorMessage),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.inet6.opt().encode(unsaved.ipAddress),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.datetime.encode(unsaved.createdAt),
    typo.runtime.Fragment.lit(", "),
    MariaTypes.datetime.opt().encode(unsaved.processedAt),
    typo.runtime.Fragment.lit("""
      )
      ON DUPLICATE KEY UPDATE `order_id` = VALUES(`order_id`),
      `method_id` = VALUES(`method_id`),
      `transaction_id` = VALUES(`transaction_id`),
      `amount` = VALUES(`amount`),
      `currency_code` = VALUES(`currency_code`),
      `status` = VALUES(`status`),
      `processor_response` = VALUES(`processor_response`),
      `error_message` = VALUES(`error_message`),
      `ip_address` = VALUES(`ip_address`),
      `created_at` = VALUES(`created_at`),
      `processed_at` = VALUES(`processed_at`)
      RETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`""".trimMargin())
  )
    .updateReturning(PaymentsRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: MutableIterator<PaymentsRow>,
    c: Connection
  ): List<PaymentsRow> = interpolate(typo.runtime.Fragment.lit("""
                           INSERT INTO `payments`(`payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`)
                           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                           ON DUPLICATE KEY UPDATE `order_id` = VALUES(`order_id`),
                           `method_id` = VALUES(`method_id`),
                           `transaction_id` = VALUES(`transaction_id`),
                           `amount` = VALUES(`amount`),
                           `currency_code` = VALUES(`currency_code`),
                           `status` = VALUES(`status`),
                           `processor_response` = VALUES(`processor_response`),
                           `error_message` = VALUES(`error_message`),
                           `ip_address` = VALUES(`ip_address`),
                           `created_at` = VALUES(`created_at`),
                           `processed_at` = VALUES(`processed_at`)
                           RETURNING `payment_id`, `order_id`, `method_id`, `transaction_id`, `amount`, `currency_code`, `status`, `processor_response`, `error_message`, `ip_address`, `created_at`, `processed_at`""".trimMargin()))
    .updateReturningEach(PaymentsRow._rowParser, unsaved)
    .runUnchecked(c)
}