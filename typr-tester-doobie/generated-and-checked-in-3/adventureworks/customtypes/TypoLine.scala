/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.customtypes

import cats.data.NonEmptyList
import doobie.postgres.Text
import doobie.util.Get
import doobie.util.Put
import io.circe.Decoder
import io.circe.Encoder
import org.postgresql.geometric.PGline

/** This implements a line represented by the linear equation Ax + By + C = 0 */
case class TypoLine(
  a: Double,
  b: Double,
  c: Double
)

object TypoLine {
  given arrayGet: Get[Array[TypoLine]] = {
    Get.Advanced.array[AnyRef](NonEmptyList.one("line[]"))
      .map(_.map(v => new TypoLine(v.asInstanceOf[PGline].a, v.asInstanceOf[PGline].b, v.asInstanceOf[PGline].c)))
  }

  given arrayPut: Put[Array[TypoLine]] = {
    Put.Advanced.array[AnyRef](NonEmptyList.one("line[]"), "line")
      .contramap(_.map(v => new PGline(v.a, v.b, v.c)))
  }

  given decoder: Decoder[TypoLine] = Decoder.forProduct3[TypoLine, Double, Double, Double]("a", "b", "c")(TypoLine.apply)(using Decoder.decodeDouble, Decoder.decodeDouble, Decoder.decodeDouble)

  given encoder: Encoder[TypoLine] = Encoder.forProduct3[TypoLine, Double, Double, Double]("a", "b", "c")(x => (x.a, x.b, x.c))(using Encoder.encodeDouble, Encoder.encodeDouble, Encoder.encodeDouble)

  given get: Get[TypoLine] = {
    Get.Advanced.other[PGline](NonEmptyList.one("line"))
      .map(v => new TypoLine(v.a, v.b, v.c))
  }

  given pgText: Text[TypoLine] = {
    new Text[TypoLine] {
      override def unsafeEncode(v: TypoLine, sb: StringBuilder): Unit = Text.stringInstance.unsafeEncode(s"{${v.a},${v.b},${v.c}}", sb)
      override def unsafeArrayEncode(v: TypoLine, sb: StringBuilder): Unit = Text.stringInstance.unsafeArrayEncode(s"{${v.a},${v.b},${v.c}}", sb)
    }
  }

  given put: Put[TypoLine] = Put.Advanced.other[PGline](NonEmptyList.one("line")).contramap(v => new PGline(v.a, v.b, v.c))
}