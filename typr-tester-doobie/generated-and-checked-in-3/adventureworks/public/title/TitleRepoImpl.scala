/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.public.title

import cats.instances.list.catsStdInstancesForList
import doobie.free.connection.ConnectionIO
import doobie.postgres.syntax.FragmentOps
import doobie.syntax.SqlInterpolator.SingleFragment.fromWrite
import doobie.util.Write
import doobie.util.update.Update
import fs2.Stream
import typr.dsl.DeleteBuilder
import typr.dsl.SelectBuilder
import typr.dsl.UpdateBuilder
import doobie.syntax.string.toSqlInterpolator

class TitleRepoImpl extends TitleRepo {
  override def delete: DeleteBuilder[TitleFields, TitleRow] = DeleteBuilder.of(""""public"."title"""", TitleFields.structure, TitleRow.read)

  override def deleteById(code: TitleId): ConnectionIO[Boolean] = sql"""delete from "public"."title" where "code" = ${fromWrite(code)(using new Write.Single(TitleId.put))}""".update.run.map(_ > 0)

  override def deleteByIds(codes: Array[TitleId]): ConnectionIO[Int] = sql"""delete from "public"."title" where "code" = ANY(${fromWrite(codes)(using new Write.Single(TitleId.arrayPut))})""".update.run

  override def insert(unsaved: TitleRow): ConnectionIO[TitleRow] = {
    sql"""insert into "public"."title"("code")
    values (${fromWrite(unsaved.code)(using new Write.Single(TitleId.put))})
    returning "code"
    """.query(using TitleRow.read).unique
  }

  override def insertStreaming(
    unsaved: Stream[ConnectionIO, TitleRow],
    batchSize: Int = 10000
  ): ConnectionIO[Long] = new FragmentOps(sql"""COPY "public"."title"("code") FROM STDIN""").copyIn(unsaved, batchSize)(using TitleRow.pgText)

  override def select: SelectBuilder[TitleFields, TitleRow] = SelectBuilder.of(""""public"."title"""", TitleFields.structure, TitleRow.read)

  override def selectAll: Stream[ConnectionIO, TitleRow] = sql"""select "code" from "public"."title"""".query(using TitleRow.read).stream

  override def selectById(code: TitleId): ConnectionIO[Option[TitleRow]] = sql"""select "code" from "public"."title" where "code" = ${fromWrite(code)(using new Write.Single(TitleId.put))}""".query(using TitleRow.read).option

  override def selectByIds(codes: Array[TitleId]): Stream[ConnectionIO, TitleRow] = sql"""select "code" from "public"."title" where "code" = ANY(${fromWrite(codes)(using new Write.Single(TitleId.arrayPut))})""".query(using TitleRow.read).stream

  override def selectByIdsTracked(codes: Array[TitleId]): ConnectionIO[Map[TitleId, TitleRow]] = {
    selectByIds(codes).compile.toList.map { rows =>
      val byId = rows.view.map(x => (x.code, x)).toMap
      codes.view.flatMap(id => byId.get(id).map(x => (id, x))).toMap
    }
  }

  override def update: UpdateBuilder[TitleFields, TitleRow] = UpdateBuilder.of(""""public"."title"""", TitleFields.structure, TitleRow.read)

  override def upsert(unsaved: TitleRow): ConnectionIO[TitleRow] = {
    sql"""insert into "public"."title"("code")
    values (
      ${fromWrite(unsaved.code)(using new Write.Single(TitleId.put))}
    )
    on conflict ("code")
    do update set "code" = EXCLUDED."code"
    returning "code"
    """.query(using TitleRow.read).unique
  }

  override def upsertBatch(unsaved: List[TitleRow]): Stream[ConnectionIO, TitleRow] = {
    Update[TitleRow](
      s"""insert into "public"."title"("code")
      values (?)
      on conflict ("code")
      do nothing
      returning "code""""
    )(using TitleRow.write)
    .updateManyWithGeneratedKeys[TitleRow]("code")(unsaved)(using catsStdInstancesForList, TitleRow.read)
  }

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override def upsertStreaming(
    unsaved: Stream[ConnectionIO, TitleRow],
    batchSize: Int = 10000
  ): ConnectionIO[Int] = {
    for {
      _ <- sql"""create temporary table title_TEMP (like "public"."title") on commit drop""".update.run
      _ <- new FragmentOps(sql"""copy title_TEMP("code") from stdin""").copyIn(unsaved, batchSize)(using TitleRow.pgText)
      res <- sql"""insert into "public"."title"("code")
             select * from title_TEMP
             on conflict ("code")
             do nothing
             ;
             drop table title_TEMP;""".update.run
    } yield res
  }
}