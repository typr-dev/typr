/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.person.stateprovince

import adventureworks.person.countryregion.CountryregionId
import adventureworks.public.Flag
import adventureworks.public.Name
import adventureworks.sales.salesterritory.SalesterritoryId
import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.runtime.PgTypes
import typo.runtime.streamingInsert

class StateprovinceRepoImpl() : StateprovinceRepo {
  override fun delete(): DeleteBuilder<StateprovinceFields, StateprovinceRow> = DeleteBuilder.of("\"person\".\"stateprovince\"", StateprovinceFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    stateprovinceid: StateprovinceId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"person\".\"stateprovince\" where \"stateprovinceid\" = "), Fragment.encode(StateprovinceId.pgType, stateprovinceid), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    stateprovinceids: Array<StateprovinceId>,
    c: Connection
  ): Int = Fragment.interpolate(Fragment.lit("delete\nfrom \"person\".\"stateprovince\"\nwhere \"stateprovinceid\" = ANY("), Fragment.encode(StateprovinceId.pgTypeArray, stateprovinceids), Fragment.lit(")"))
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: StateprovinceRow,
    c: Connection
  ): StateprovinceRow = Fragment.interpolate(Fragment.lit("insert into \"person\".\"stateprovince\"(\"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\")\nvalues ("), Fragment.encode(StateprovinceId.pgType, unsaved.stateprovinceid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.bpchar, unsaved.stateprovincecode), Fragment.lit("::bpchar, "), Fragment.encode(CountryregionId.pgType, unsaved.countryregioncode), Fragment.lit(", "), Fragment.encode(Flag.pgType, unsaved.isonlystateprovinceflag), Fragment.lit("::bool, "), Fragment.encode(Name.pgType, unsaved.name), Fragment.lit("::varchar, "), Fragment.encode(SalesterritoryId.pgType, unsaved.territoryid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.uuid, unsaved.rowguid), Fragment.lit("::uuid, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp)\nreturning \"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\"\n"))
    .updateReturning(StateprovinceRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: StateprovinceRowUnsaved,
    c: Connection
  ): StateprovinceRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("\"stateprovincecode\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.bpchar, unsaved.stateprovincecode), Fragment.lit("::bpchar")))
    columns.add(Fragment.lit("\"countryregioncode\""))
    values.add(Fragment.interpolate(Fragment.encode(CountryregionId.pgType, unsaved.countryregioncode), Fragment.lit("")))
    columns.add(Fragment.lit("\"name\""))
    values.add(Fragment.interpolate(Fragment.encode(Name.pgType, unsaved.name), Fragment.lit("::varchar")))
    columns.add(Fragment.lit("\"territoryid\""))
    values.add(Fragment.interpolate(Fragment.encode(SalesterritoryId.pgType, unsaved.territoryid), Fragment.lit("::int4")))
    unsaved.stateprovinceid.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"stateprovinceid\""))
      values.add(Fragment.interpolate(Fragment.encode(StateprovinceId.pgType, value), Fragment.lit("::int4"))) }
    );
    unsaved.isonlystateprovinceflag.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"isonlystateprovinceflag\""))
      values.add(Fragment.interpolate(Fragment.encode(Flag.pgType, value), Fragment.lit("::bool"))) }
    );
    unsaved.rowguid.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"rowguid\""))
      values.add(Fragment.interpolate(Fragment.encode(PgTypes.uuid, value), Fragment.lit("::uuid"))) }
    );
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp, value), Fragment.lit("::timestamp"))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into \"person\".\"stateprovince\"("), Fragment.comma(columns), Fragment.lit(")\nvalues ("), Fragment.comma(values), Fragment.lit(")\nreturning \"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\"\n"))
    return q.updateReturning(StateprovinceRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: Iterator<StateprovinceRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"person\".\"stateprovince\"(\"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\") FROM STDIN", batchSize, unsaved, c, StateprovinceRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: Iterator<StateprovinceRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"person\".\"stateprovince\"(\"stateprovincecode\", \"countryregioncode\", \"name\", \"territoryid\", \"stateprovinceid\", \"isonlystateprovinceflag\", \"rowguid\", \"modifieddate\") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')", batchSize, unsaved, c, StateprovinceRowUnsaved.pgText)

  override fun select(): SelectBuilder<StateprovinceFields, StateprovinceRow> = SelectBuilder.of("\"person\".\"stateprovince\"", StateprovinceFields.structure, StateprovinceRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<StateprovinceRow> = Fragment.interpolate(Fragment.lit("select \"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\"\nfrom \"person\".\"stateprovince\"\n")).query(StateprovinceRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    stateprovinceid: StateprovinceId,
    c: Connection
  ): StateprovinceRow? = Fragment.interpolate(Fragment.lit("select \"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\"\nfrom \"person\".\"stateprovince\"\nwhere \"stateprovinceid\" = "), Fragment.encode(StateprovinceId.pgType, stateprovinceid), Fragment.lit("")).query(StateprovinceRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    stateprovinceids: Array<StateprovinceId>,
    c: Connection
  ): List<StateprovinceRow> = Fragment.interpolate(Fragment.lit("select \"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\"\nfrom \"person\".\"stateprovince\"\nwhere \"stateprovinceid\" = ANY("), Fragment.encode(StateprovinceId.pgTypeArray, stateprovinceids), Fragment.lit(")")).query(StateprovinceRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    stateprovinceids: Array<StateprovinceId>,
    c: Connection
  ): Map<StateprovinceId, StateprovinceRow> {
    val ret: MutableMap<StateprovinceId, StateprovinceRow> = mutableMapOf<StateprovinceId, StateprovinceRow>()
    selectByIds(stateprovinceids, c).forEach({ row -> ret.put(row.stateprovinceid, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<StateprovinceFields, StateprovinceRow> = UpdateBuilder.of("\"person\".\"stateprovince\"", StateprovinceFields.structure, StateprovinceRow._rowParser, Dialect.POSTGRESQL)

  override fun update(
    row: StateprovinceRow,
    c: Connection
  ): Boolean {
    val stateprovinceid: StateprovinceId = row.stateprovinceid
    return Fragment.interpolate(Fragment.lit("update \"person\".\"stateprovince\"\nset \"stateprovincecode\" = "), Fragment.encode(PgTypes.bpchar, row.stateprovincecode), Fragment.lit("::bpchar,\n\"countryregioncode\" = "), Fragment.encode(CountryregionId.pgType, row.countryregioncode), Fragment.lit(",\n\"isonlystateprovinceflag\" = "), Fragment.encode(Flag.pgType, row.isonlystateprovinceflag), Fragment.lit("::bool,\n\"name\" = "), Fragment.encode(Name.pgType, row.name), Fragment.lit("::varchar,\n\"territoryid\" = "), Fragment.encode(SalesterritoryId.pgType, row.territoryid), Fragment.lit("::int4,\n\"rowguid\" = "), Fragment.encode(PgTypes.uuid, row.rowguid), Fragment.lit("::uuid,\n\"modifieddate\" = "), Fragment.encode(PgTypes.timestamp, row.modifieddate), Fragment.lit("::timestamp\nwhere \"stateprovinceid\" = "), Fragment.encode(StateprovinceId.pgType, stateprovinceid), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: StateprovinceRow,
    c: Connection
  ): StateprovinceRow = Fragment.interpolate(Fragment.lit("insert into \"person\".\"stateprovince\"(\"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\")\nvalues ("), Fragment.encode(StateprovinceId.pgType, unsaved.stateprovinceid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.bpchar, unsaved.stateprovincecode), Fragment.lit("::bpchar, "), Fragment.encode(CountryregionId.pgType, unsaved.countryregioncode), Fragment.lit(", "), Fragment.encode(Flag.pgType, unsaved.isonlystateprovinceflag), Fragment.lit("::bool, "), Fragment.encode(Name.pgType, unsaved.name), Fragment.lit("::varchar, "), Fragment.encode(SalesterritoryId.pgType, unsaved.territoryid), Fragment.lit("::int4, "), Fragment.encode(PgTypes.uuid, unsaved.rowguid), Fragment.lit("::uuid, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp)\non conflict (\"stateprovinceid\")\ndo update set\n  \"stateprovincecode\" = EXCLUDED.\"stateprovincecode\",\n\"countryregioncode\" = EXCLUDED.\"countryregioncode\",\n\"isonlystateprovinceflag\" = EXCLUDED.\"isonlystateprovinceflag\",\n\"name\" = EXCLUDED.\"name\",\n\"territoryid\" = EXCLUDED.\"territoryid\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\""))
    .updateReturning(StateprovinceRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<StateprovinceRow>,
    c: Connection
  ): List<StateprovinceRow> = Fragment.interpolate(Fragment.lit("insert into \"person\".\"stateprovince\"(\"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\")\nvalues (?::int4, ?::bpchar, ?, ?::bool, ?::varchar, ?::int4, ?::uuid, ?::timestamp)\non conflict (\"stateprovinceid\")\ndo update set\n  \"stateprovincecode\" = EXCLUDED.\"stateprovincecode\",\n\"countryregioncode\" = EXCLUDED.\"countryregioncode\",\n\"isonlystateprovinceflag\" = EXCLUDED.\"isonlystateprovinceflag\",\n\"name\" = EXCLUDED.\"name\",\n\"territoryid\" = EXCLUDED.\"territoryid\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\""))
    .updateManyReturning(StateprovinceRow._rowParser, unsaved)
  .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: Iterator<StateprovinceRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    Fragment.interpolate(Fragment.lit("create temporary table stateprovince_TEMP (like \"person\".\"stateprovince\") on commit drop")).update().runUnchecked(c)
    streamingInsert.insertUnchecked("copy stateprovince_TEMP(\"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\") from stdin", batchSize, unsaved, c, StateprovinceRow.pgText)
    return Fragment.interpolate(Fragment.lit("insert into \"person\".\"stateprovince\"(\"stateprovinceid\", \"stateprovincecode\", \"countryregioncode\", \"isonlystateprovinceflag\", \"name\", \"territoryid\", \"rowguid\", \"modifieddate\")\nselect * from stateprovince_TEMP\non conflict (\"stateprovinceid\")\ndo update set\n  \"stateprovincecode\" = EXCLUDED.\"stateprovincecode\",\n\"countryregioncode\" = EXCLUDED.\"countryregioncode\",\n\"isonlystateprovinceflag\" = EXCLUDED.\"isonlystateprovinceflag\",\n\"name\" = EXCLUDED.\"name\",\n\"territoryid\" = EXCLUDED.\"territoryid\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\n;\ndrop table stateprovince_TEMP;")).update().runUnchecked(c)
  }
}