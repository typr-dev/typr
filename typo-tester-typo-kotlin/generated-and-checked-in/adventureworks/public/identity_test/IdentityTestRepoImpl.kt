/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.public.identity_test

import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.KotlinDbTypes
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.runtime.streamingInsert

class IdentityTestRepoImpl() : IdentityTestRepo {
  override fun delete(): DeleteBuilder<IdentityTestFields, IdentityTestRow> = DeleteBuilder.of("\"public\".\"identity-test\"", IdentityTestFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    name: IdentityTestId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"public\".\"identity-test\" where \"name\" = "), Fragment.encode(IdentityTestId.pgType, name), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    names: Array<IdentityTestId>,
    c: Connection
  ): Int = Fragment.interpolate(Fragment.lit("delete\nfrom \"public\".\"identity-test\"\nwhere \"name\" = ANY("), Fragment.encode(IdentityTestId.pgTypeArray, names), Fragment.lit(")"))
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: IdentityTestRow,
    c: Connection
  ): IdentityTestRow = Fragment.interpolate(Fragment.lit("insert into \"public\".\"identity-test\"(\"default_generated\", \"name\")\nvalues ("), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.defaultGenerated), Fragment.lit("::int4, "), Fragment.encode(IdentityTestId.pgType, unsaved.name), Fragment.lit(")\nRETURNING \"always_generated\", \"default_generated\", \"name\"\n"))
    .updateReturning(IdentityTestRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: IdentityTestRowUnsaved,
    c: Connection
  ): IdentityTestRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("\"name\""))
    values.add(Fragment.interpolate(Fragment.encode(IdentityTestId.pgType, unsaved.name), Fragment.lit("")))
    unsaved.defaultGenerated.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"default_generated\""))
      values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int4, value), Fragment.lit("::int4"))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into \"public\".\"identity-test\"("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING \"always_generated\", \"default_generated\", \"name\"\n"))
    return q.updateReturning(IdentityTestRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: Iterator<IdentityTestRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"public\".\"identity-test\"(\"default_generated\", \"name\") FROM STDIN", batchSize, unsaved, c, IdentityTestRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: Iterator<IdentityTestRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"public\".\"identity-test\"(\"name\", \"default_generated\") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')", batchSize, unsaved, c, IdentityTestRowUnsaved.pgText)

  override fun select(): SelectBuilder<IdentityTestFields, IdentityTestRow> = SelectBuilder.of("\"public\".\"identity-test\"", IdentityTestFields.structure, IdentityTestRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<IdentityTestRow> = Fragment.interpolate(Fragment.lit("select \"always_generated\", \"default_generated\", \"name\"\nfrom \"public\".\"identity-test\"\n")).query(IdentityTestRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    name: IdentityTestId,
    c: Connection
  ): IdentityTestRow? = Fragment.interpolate(Fragment.lit("select \"always_generated\", \"default_generated\", \"name\"\nfrom \"public\".\"identity-test\"\nwhere \"name\" = "), Fragment.encode(IdentityTestId.pgType, name), Fragment.lit("")).query(IdentityTestRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    names: Array<IdentityTestId>,
    c: Connection
  ): List<IdentityTestRow> = Fragment.interpolate(Fragment.lit("select \"always_generated\", \"default_generated\", \"name\"\nfrom \"public\".\"identity-test\"\nwhere \"name\" = ANY("), Fragment.encode(IdentityTestId.pgTypeArray, names), Fragment.lit(")")).query(IdentityTestRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    names: Array<IdentityTestId>,
    c: Connection
  ): Map<IdentityTestId, IdentityTestRow> {
    val ret: MutableMap<IdentityTestId, IdentityTestRow> = mutableMapOf<IdentityTestId, IdentityTestRow>()
    selectByIds(names, c).forEach({ row -> ret.put(row.name, row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<IdentityTestFields, IdentityTestRow> = UpdateBuilder.of("\"public\".\"identity-test\"", IdentityTestFields.structure, IdentityTestRow._rowParser, Dialect.POSTGRESQL)

  override fun update(
    row: IdentityTestRow,
    c: Connection
  ): Boolean {
    val name: IdentityTestId = row.name
    return Fragment.interpolate(Fragment.lit("update \"public\".\"identity-test\"\nset \"default_generated\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4, row.defaultGenerated), Fragment.lit("::int4\nwhere \"name\" = "), Fragment.encode(IdentityTestId.pgType, name), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: IdentityTestRow,
    c: Connection
  ): IdentityTestRow = Fragment.interpolate(Fragment.lit("insert into \"public\".\"identity-test\"(\"default_generated\", \"name\")\nvalues ("), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.defaultGenerated), Fragment.lit("::int4, "), Fragment.encode(IdentityTestId.pgType, unsaved.name), Fragment.lit(")\non conflict (\"name\")\ndo update set\n  \"default_generated\" = EXCLUDED.\"default_generated\"\nreturning \"always_generated\", \"default_generated\", \"name\""))
    .updateReturning(IdentityTestRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<IdentityTestRow>,
    c: Connection
  ): List<IdentityTestRow> = Fragment.interpolate(Fragment.lit("insert into \"public\".\"identity-test\"(\"default_generated\", \"name\")\nvalues (?::int4, ?)\non conflict (\"name\")\ndo update set\n  \"default_generated\" = EXCLUDED.\"default_generated\"\nreturning \"always_generated\", \"default_generated\", \"name\""))
    .updateManyReturning(IdentityTestRow._rowParser, unsaved)
  .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: Iterator<IdentityTestRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    Fragment.interpolate(Fragment.lit("create temporary table identity-test_TEMP (like \"public\".\"identity-test\") on commit drop")).update().runUnchecked(c)
    streamingInsert.insertUnchecked("copy identity-test_TEMP(\"default_generated\", \"name\") from stdin", batchSize, unsaved, c, IdentityTestRow.pgText)
    return Fragment.interpolate(Fragment.lit("insert into \"public\".\"identity-test\"(\"default_generated\", \"name\")\nselect * from identity-test_TEMP\non conflict (\"name\")\ndo update set\n  \"default_generated\" = EXCLUDED.\"default_generated\"\n;\ndrop table identity-test_TEMP;")).update().runUnchecked(c)
  }
}