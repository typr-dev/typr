/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.purchasing.productvendor

import adventureworks.customtypes.Defaulted
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.math.BigDecimal
import java.time.LocalDateTime
import typo.kotlindsl.KotlinDbTypes
import typo.kotlindsl.RowParser
import typo.kotlindsl.RowParsers
import typo.kotlindsl.nullable
import typo.runtime.PgText
import typo.runtime.PgTypes

/** Table: purchasing.productvendor
  * Cross-reference table mapping vendors with the products they supply.
  * Composite primary key: productid, businessentityid
  */
data class ProductvendorRow(
  /** Primary key. Foreign key to Product.ProductID.
    * Points to [adventureworks.production.product.ProductRow.productid]
    */
  val productid: ProductId,
  /** Primary key. Foreign key to Vendor.BusinessEntityID.
    * Points to [adventureworks.purchasing.vendor.VendorRow.businessentityid]
    */
  val businessentityid: BusinessentityId,
  /** The average span of time (in days) between placing an order with the vendor and receiving the purchased product.
    * Constraint CK_ProductVendor_AverageLeadTime affecting columns averageleadtime: ((averageleadtime >= 1))
    */
  val averageleadtime: Int,
  /** The vendor's usual selling price.
    * Constraint CK_ProductVendor_StandardPrice affecting columns standardprice: ((standardprice > 0.00))
    */
  val standardprice: BigDecimal,
  /** The selling price when last purchased.
    * Constraint CK_ProductVendor_LastReceiptCost affecting columns lastreceiptcost: ((lastreceiptcost > 0.00))
    */
  val lastreceiptcost: BigDecimal?,
  /** Date the product was last received by the vendor. */
  val lastreceiptdate: LocalDateTime?,
  /** The maximum quantity that should be ordered.
    * Constraint CK_ProductVendor_MinOrderQty affecting columns minorderqty: ((minorderqty >= 1))
    */
  val minorderqty: Int,
  /** The minimum quantity that should be ordered.
    * Constraint CK_ProductVendor_MaxOrderQty affecting columns maxorderqty: ((maxorderqty >= 1))
    */
  val maxorderqty: Int,
  /** The quantity currently on order.
    * Constraint CK_ProductVendor_OnOrderQty affecting columns onorderqty: ((onorderqty >= 0))
    */
  val onorderqty: Int?,
  /** The product's unit of measure.
    * Points to [adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]
    */
  val unitmeasurecode: UnitmeasureId,
  /** Default: now() */
  val modifieddate: LocalDateTime
) {
  fun compositeId(): ProductvendorId = ProductvendorId(productid, businessentityid)

  fun id(): ProductvendorId = this.compositeId()

  fun toUnsavedRow(modifieddate: Defaulted<LocalDateTime>): ProductvendorRowUnsaved = ProductvendorRowUnsaved(productid, businessentityid, averageleadtime, standardprice, lastreceiptcost, lastreceiptdate, minorderqty, maxorderqty, onorderqty, unitmeasurecode, modifieddate)

  companion object {
    val _rowParser: RowParser<ProductvendorRow> = RowParsers.of(ProductId.pgType, BusinessentityId.pgType, KotlinDbTypes.PgTypes.int4, PgTypes.numeric, PgTypes.numeric.nullable(), PgTypes.timestamp.nullable(), KotlinDbTypes.PgTypes.int4, KotlinDbTypes.PgTypes.int4, KotlinDbTypes.PgTypes.int4.nullable(), UnitmeasureId.pgType, PgTypes.timestamp, { t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10 -> ProductvendorRow(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) }, { row -> arrayOf<Any?>(row.productid, row.businessentityid, row.averageleadtime, row.standardprice, row.lastreceiptcost, row.lastreceiptdate, row.minorderqty, row.maxorderqty, row.onorderqty, row.unitmeasurecode, row.modifieddate) })

    fun apply(
      compositeId: ProductvendorId,
      averageleadtime: Int,
      standardprice: BigDecimal,
      lastreceiptcost: BigDecimal?,
      lastreceiptdate: LocalDateTime?,
      minorderqty: Int,
      maxorderqty: Int,
      onorderqty: Int?,
      unitmeasurecode: UnitmeasureId,
      modifieddate: LocalDateTime
    ): ProductvendorRow = ProductvendorRow(compositeId.productid, compositeId.businessentityid, averageleadtime, standardprice, lastreceiptcost, lastreceiptdate, minorderqty, maxorderqty, onorderqty, unitmeasurecode, modifieddate)

    val pgText: PgText<ProductvendorRow> =
      PgText.from(_rowParser.underlying)
  }
}