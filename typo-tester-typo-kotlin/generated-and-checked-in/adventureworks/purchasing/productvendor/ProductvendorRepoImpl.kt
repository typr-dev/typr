/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.purchasing.productvendor

import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.production.product.ProductId
import adventureworks.production.unitmeasure.UnitmeasureId
import java.sql.Connection
import java.util.ArrayList
import java.util.Optional
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableIterator
import kotlin.collections.MutableMap
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.PgTypes
import typo.runtime.internal.arrayMap
import typo.runtime.streamingInsert
import typo.runtime.Fragment.interpolate
import typo.runtime.internal.stringInterpolator.str

class ProductvendorRepoImpl() : ProductvendorRepo {
  override fun delete(): DeleteBuilder<ProductvendorFields, ProductvendorRow> = DeleteBuilder.of("\"purchasing\".\"productvendor\"", ProductvendorFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    compositeId: ProductvendorId,
    c: Connection
  ): Boolean = interpolate(
    typo.runtime.Fragment.lit("""
    delete from "purchasing"."productvendor" where "productid" = 
    """.trimMargin()),
    ProductId.pgType.encode(compositeId.productid),
    typo.runtime.Fragment.lit("""
     AND "businessentityid" = 
    """.trimMargin()),
    BusinessentityId.pgType.encode(compositeId.businessentityid),
    typo.runtime.Fragment.lit("")
  ).update().runUnchecked(c) > 0

  override fun deleteByIds(
    compositeIds: Array<ProductvendorId>,
    c: Connection
  ): Int {
    val productid: Array<ProductId> = arrayMap.map(compositeIds, ProductvendorId::productid, ProductId::class.java)
    val businessentityid: Array<BusinessentityId> = arrayMap.map(compositeIds, ProductvendorId::businessentityid, BusinessentityId::class.java)
    return interpolate(
      typo.runtime.Fragment.lit("""
        delete
        from "purchasing"."productvendor"
        where ("productid", "businessentityid")
        in (select unnest(""".trimMargin()),
      ProductId.pgTypeArray.encode(productid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      BusinessentityId.pgTypeArray.encode(businessentityid),
      typo.runtime.Fragment.lit("""
      ::int4[]))

      """.trimMargin())
    ).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: ProductvendorRow,
    c: Connection
  ): ProductvendorRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
      values (""".trimMargin()),
    ProductId.pgType.encode(unsaved.productid),
    typo.runtime.Fragment.lit("::int4, "),
    BusinessentityId.pgType.encode(unsaved.businessentityid),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.int4.encode(unsaved.averageleadtime),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.numeric.encode(unsaved.standardprice),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.opt().encode(unsaved.lastreceiptcost),
    typo.runtime.Fragment.lit("::numeric, "),
    TypoLocalDateTime.pgType.opt().encode(unsaved.lastreceiptdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    PgTypes.int4.encode(unsaved.minorderqty),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.int4.encode(unsaved.maxorderqty),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.int4.opt().encode(unsaved.onorderqty),
    typo.runtime.Fragment.lit("::int4, "),
    UnitmeasureId.pgType.encode(unsaved.unitmeasurecode),
    typo.runtime.Fragment.lit("::bpchar, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("""
      ::timestamp)
      returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
    """.trimMargin())
  )
    .updateReturning(ProductvendorRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: ProductvendorRowUnsaved,
    c: Connection
  ): ProductvendorRow {
    val columns: ArrayList<Literal> = ArrayList<Literal>()
    val values: ArrayList<Fragment> = ArrayList<Fragment>()
    columns.add(Fragment.lit("\"productid\""))
    values.add(interpolate(
      ProductId.pgType.encode(unsaved.productid),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"businessentityid\""))
    values.add(interpolate(
      BusinessentityId.pgType.encode(unsaved.businessentityid),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"averageleadtime\""))
    values.add(interpolate(
      PgTypes.int4.encode(unsaved.averageleadtime),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"standardprice\""))
    values.add(interpolate(
      PgTypes.numeric.encode(unsaved.standardprice),
      typo.runtime.Fragment.lit("::numeric")
    ))
    columns.add(Fragment.lit("\"lastreceiptcost\""))
    values.add(interpolate(
      PgTypes.numeric.opt().encode(unsaved.lastreceiptcost),
      typo.runtime.Fragment.lit("::numeric")
    ))
    columns.add(Fragment.lit("\"lastreceiptdate\""))
    values.add(interpolate(
      TypoLocalDateTime.pgType.opt().encode(unsaved.lastreceiptdate),
      typo.runtime.Fragment.lit("::timestamp")
    ))
    columns.add(Fragment.lit("\"minorderqty\""))
    values.add(interpolate(
      PgTypes.int4.encode(unsaved.minorderqty),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"maxorderqty\""))
    values.add(interpolate(
      PgTypes.int4.encode(unsaved.maxorderqty),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"onorderqty\""))
    values.add(interpolate(
      PgTypes.int4.opt().encode(unsaved.onorderqty),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"unitmeasurecode\""))
    values.add(interpolate(
      UnitmeasureId.pgType.encode(unsaved.unitmeasurecode),
      typo.runtime.Fragment.lit("::bpchar")
    ))
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(interpolate(
        TypoLocalDateTime.pgType.encode(value),
        typo.runtime.Fragment.lit("::timestamp")
      )) }
    );
    val q: Fragment = interpolate(
      typo.runtime.Fragment.lit("""
      insert into "purchasing"."productvendor"(
      """.trimMargin()),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
        )
        values (""".trimMargin()),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
        )
        returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
      """.trimMargin())
    )
    return q.updateReturning(ProductvendorRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: MutableIterator<ProductvendorRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") FROM STDIN
  """.trimMargin()), batchSize, unsaved, c, ProductvendorRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: MutableIterator<ProductvendorRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')
  """.trimMargin()), batchSize, unsaved, c, ProductvendorRowUnsaved.pgText)

  override fun select(): SelectBuilder<ProductvendorFields, ProductvendorRow> = SelectBuilder.of("\"purchasing\".\"productvendor\"", ProductvendorFields.structure, ProductvendorRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<ProductvendorRow> = interpolate(typo.runtime.Fragment.lit("""
    select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
    from "purchasing"."productvendor"
  """.trimMargin())).query(ProductvendorRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    compositeId: ProductvendorId,
    c: Connection
  ): Optional<ProductvendorRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
      from "purchasing"."productvendor"
      where "productid" = """.trimMargin()),
    ProductId.pgType.encode(compositeId.productid),
    typo.runtime.Fragment.lit("""
     AND "businessentityid" = 
    """.trimMargin()),
    BusinessentityId.pgType.encode(compositeId.businessentityid),
    typo.runtime.Fragment.lit("")
  ).query(ProductvendorRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    compositeIds: Array<ProductvendorId>,
    c: Connection
  ): List<ProductvendorRow> {
    val productid: Array<ProductId> = arrayMap.map(compositeIds, ProductvendorId::productid, ProductId::class.java)
    val businessentityid: Array<BusinessentityId> = arrayMap.map(compositeIds, ProductvendorId::businessentityid, BusinessentityId::class.java)
    return interpolate(
      typo.runtime.Fragment.lit("""
        select "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text
        from "purchasing"."productvendor"
        where ("productid", "businessentityid")
        in (select unnest(""".trimMargin()),
      ProductId.pgTypeArray.encode(productid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      BusinessentityId.pgTypeArray.encode(businessentityid),
      typo.runtime.Fragment.lit("""
      ::int4[]))

      """.trimMargin())
    ).query(ProductvendorRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    compositeIds: Array<ProductvendorId>,
    c: Connection
  ): Map<ProductvendorId, ProductvendorRow> {
    val ret: MutableMap<ProductvendorId, ProductvendorRow> = mutableMapOf<ProductvendorId, ProductvendorRow>()
    selectByIds(compositeIds, c).forEach({ row -> ret.put(row.compositeId(), row) })
    return ret
  }

  override fun update(): UpdateBuilder<ProductvendorFields, ProductvendorRow> = UpdateBuilder.of("\"purchasing\".\"productvendor\"", ProductvendorFields.structure, ProductvendorRow._rowParser.all(), Dialect.POSTGRESQL)

  override fun update(
    row: ProductvendorRow,
    c: Connection
  ): Boolean {
    val compositeId: ProductvendorId = row.compositeId()
    return interpolate(
      typo.runtime.Fragment.lit("""
        update "purchasing"."productvendor"
        set "averageleadtime" = """.trimMargin()),
      PgTypes.int4.encode(row.averageleadtime),
      typo.runtime.Fragment.lit("""
        ::int4,
        "standardprice" = """.trimMargin()),
      PgTypes.numeric.encode(row.standardprice),
      typo.runtime.Fragment.lit("""
        ::numeric,
        "lastreceiptcost" = """.trimMargin()),
      PgTypes.numeric.opt().encode(row.lastreceiptcost),
      typo.runtime.Fragment.lit("""
        ::numeric,
        "lastreceiptdate" = """.trimMargin()),
      TypoLocalDateTime.pgType.opt().encode(row.lastreceiptdate),
      typo.runtime.Fragment.lit("""
        ::timestamp,
        "minorderqty" = """.trimMargin()),
      PgTypes.int4.encode(row.minorderqty),
      typo.runtime.Fragment.lit("""
        ::int4,
        "maxorderqty" = """.trimMargin()),
      PgTypes.int4.encode(row.maxorderqty),
      typo.runtime.Fragment.lit("""
        ::int4,
        "onorderqty" = """.trimMargin()),
      PgTypes.int4.opt().encode(row.onorderqty),
      typo.runtime.Fragment.lit("""
        ::int4,
        "unitmeasurecode" = """.trimMargin()),
      UnitmeasureId.pgType.encode(row.unitmeasurecode),
      typo.runtime.Fragment.lit("""
        ::bpchar,
        "modifieddate" = """.trimMargin()),
      TypoLocalDateTime.pgType.encode(row.modifieddate),
      typo.runtime.Fragment.lit("""
        ::timestamp
        where "productid" = """.trimMargin()),
      ProductId.pgType.encode(compositeId.productid),
      typo.runtime.Fragment.lit("""
       AND "businessentityid" = 
      """.trimMargin()),
      BusinessentityId.pgType.encode(compositeId.businessentityid),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: ProductvendorRow,
    c: Connection
  ): ProductvendorRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
      values (""".trimMargin()),
    ProductId.pgType.encode(unsaved.productid),
    typo.runtime.Fragment.lit("::int4, "),
    BusinessentityId.pgType.encode(unsaved.businessentityid),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.int4.encode(unsaved.averageleadtime),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.numeric.encode(unsaved.standardprice),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.opt().encode(unsaved.lastreceiptcost),
    typo.runtime.Fragment.lit("::numeric, "),
    TypoLocalDateTime.pgType.opt().encode(unsaved.lastreceiptdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    PgTypes.int4.encode(unsaved.minorderqty),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.int4.encode(unsaved.maxorderqty),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.int4.opt().encode(unsaved.onorderqty),
    typo.runtime.Fragment.lit("::int4, "),
    UnitmeasureId.pgType.encode(unsaved.unitmeasurecode),
    typo.runtime.Fragment.lit("::bpchar, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("""
      ::timestamp)
      on conflict ("productid", "businessentityid")
      do update set
        "averageleadtime" = EXCLUDED."averageleadtime",
      "standardprice" = EXCLUDED."standardprice",
      "lastreceiptcost" = EXCLUDED."lastreceiptcost",
      "lastreceiptdate" = EXCLUDED."lastreceiptdate",
      "minorderqty" = EXCLUDED."minorderqty",
      "maxorderqty" = EXCLUDED."maxorderqty",
      "onorderqty" = EXCLUDED."onorderqty",
      "unitmeasurecode" = EXCLUDED."unitmeasurecode",
      "modifieddate" = EXCLUDED."modifieddate"
      returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text""".trimMargin())
  )
    .updateReturning(ProductvendorRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: MutableIterator<ProductvendorRow>,
    c: Connection
  ): List<ProductvendorRow> = interpolate(typo.runtime.Fragment.lit("""
                                insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
                                values (?::int4, ?::int4, ?::int4, ?::numeric, ?::numeric, ?::timestamp, ?::int4, ?::int4, ?::int4, ?::bpchar, ?::timestamp)
                                on conflict ("productid", "businessentityid")
                                do update set
                                  "averageleadtime" = EXCLUDED."averageleadtime",
                                "standardprice" = EXCLUDED."standardprice",
                                "lastreceiptcost" = EXCLUDED."lastreceiptcost",
                                "lastreceiptdate" = EXCLUDED."lastreceiptdate",
                                "minorderqty" = EXCLUDED."minorderqty",
                                "maxorderqty" = EXCLUDED."maxorderqty",
                                "onorderqty" = EXCLUDED."onorderqty",
                                "unitmeasurecode" = EXCLUDED."unitmeasurecode",
                                "modifieddate" = EXCLUDED."modifieddate"
                                returning "productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate"::text, "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate"::text""".trimMargin()))
    .updateManyReturning(ProductvendorRow._rowParser, unsaved)
    .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: MutableIterator<ProductvendorRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    interpolate(typo.runtime.Fragment.lit("""
    create temporary table productvendor_TEMP (like "purchasing"."productvendor") on commit drop
    """.trimMargin())).update().runUnchecked(c)
    streamingInsert.insertUnchecked(str("""
    copy productvendor_TEMP("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate") from stdin
    """.trimMargin()), batchSize, unsaved, c, ProductvendorRow.pgText)
    return interpolate(typo.runtime.Fragment.lit("""
      insert into "purchasing"."productvendor"("productid", "businessentityid", "averageleadtime", "standardprice", "lastreceiptcost", "lastreceiptdate", "minorderqty", "maxorderqty", "onorderqty", "unitmeasurecode", "modifieddate")
      select * from productvendor_TEMP
      on conflict ("productid", "businessentityid")
      do update set
        "averageleadtime" = EXCLUDED."averageleadtime",
      "standardprice" = EXCLUDED."standardprice",
      "lastreceiptcost" = EXCLUDED."lastreceiptcost",
      "lastreceiptdate" = EXCLUDED."lastreceiptdate",
      "minorderqty" = EXCLUDED."minorderqty",
      "maxorderqty" = EXCLUDED."maxorderqty",
      "onorderqty" = EXCLUDED."onorderqty",
      "unitmeasurecode" = EXCLUDED."unitmeasurecode",
      "modifieddate" = EXCLUDED."modifieddate"
      ;
      drop table productvendor_TEMP;""".trimMargin())).update().runUnchecked(c)
  }
}