/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.purchasing.purchaseorderheader

import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.customtypes.TypoShort
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.purchasing.shipmethod.ShipmethodId
import java.sql.Connection
import java.util.ArrayList
import java.util.Optional
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableIterator
import kotlin.collections.MutableMap
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.PgTypes
import typo.runtime.streamingInsert
import typo.runtime.Fragment.interpolate
import typo.runtime.internal.stringInterpolator.str

class PurchaseorderheaderRepoImpl() : PurchaseorderheaderRepo {
  override fun delete(): DeleteBuilder<PurchaseorderheaderFields, PurchaseorderheaderRow> = DeleteBuilder.of("\"purchasing\".\"purchaseorderheader\"", PurchaseorderheaderFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    purchaseorderid: PurchaseorderheaderId,
    c: Connection
  ): Boolean = interpolate(
    typo.runtime.Fragment.lit("""
    delete from "purchasing"."purchaseorderheader" where "purchaseorderid" = 
    """.trimMargin()),
    PurchaseorderheaderId.pgType.encode(purchaseorderid),
    typo.runtime.Fragment.lit("")
  ).update().runUnchecked(c) > 0

  override fun deleteByIds(
    purchaseorderids: Array<PurchaseorderheaderId>,
    c: Connection
  ): Int = interpolate(
             typo.runtime.Fragment.lit("""
               delete
               from "purchasing"."purchaseorderheader"
               where "purchaseorderid" = ANY(""".trimMargin()),
             PurchaseorderheaderId.pgTypeArray.encode(purchaseorderids),
             typo.runtime.Fragment.lit(")")
           )
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: PurchaseorderheaderRow,
    c: Connection
  ): PurchaseorderheaderRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "purchasing"."purchaseorderheader"("purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate", "shipdate", "subtotal", "taxamt", "freight", "modifieddate")
      values (""".trimMargin()),
    PurchaseorderheaderId.pgType.encode(unsaved.purchaseorderid),
    typo.runtime.Fragment.lit("::int4, "),
    TypoShort.pgType.encode(unsaved.revisionnumber),
    typo.runtime.Fragment.lit("::int2, "),
    TypoShort.pgType.encode(unsaved.status),
    typo.runtime.Fragment.lit("::int2, "),
    BusinessentityId.pgType.encode(unsaved.employeeid),
    typo.runtime.Fragment.lit("::int4, "),
    BusinessentityId.pgType.encode(unsaved.vendorid),
    typo.runtime.Fragment.lit("::int4, "),
    ShipmethodId.pgType.encode(unsaved.shipmethodid),
    typo.runtime.Fragment.lit("::int4, "),
    TypoLocalDateTime.pgType.encode(unsaved.orderdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    TypoLocalDateTime.pgType.opt().encode(unsaved.shipdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    PgTypes.numeric.encode(unsaved.subtotal),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.encode(unsaved.taxamt),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.encode(unsaved.freight),
    typo.runtime.Fragment.lit("::numeric, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("""
      ::timestamp)
      returning "purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate"::text, "shipdate"::text, "subtotal", "taxamt", "freight", "modifieddate"::text
    """.trimMargin())
  )
    .updateReturning(PurchaseorderheaderRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: PurchaseorderheaderRowUnsaved,
    c: Connection
  ): PurchaseorderheaderRow {
    val columns: ArrayList<Literal> = ArrayList<Literal>()
    val values: ArrayList<Fragment> = ArrayList<Fragment>()
    columns.add(Fragment.lit("\"employeeid\""))
    values.add(interpolate(
      BusinessentityId.pgType.encode(unsaved.employeeid),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"vendorid\""))
    values.add(interpolate(
      BusinessentityId.pgType.encode(unsaved.vendorid),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"shipmethodid\""))
    values.add(interpolate(
      ShipmethodId.pgType.encode(unsaved.shipmethodid),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"shipdate\""))
    values.add(interpolate(
      TypoLocalDateTime.pgType.opt().encode(unsaved.shipdate),
      typo.runtime.Fragment.lit("::timestamp")
    ))
    unsaved.purchaseorderid.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"purchaseorderid\""))
      values.add(interpolate(
        PurchaseorderheaderId.pgType.encode(value),
        typo.runtime.Fragment.lit("::int4")
      )) }
    );
    unsaved.revisionnumber.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"revisionnumber\""))
      values.add(interpolate(
        TypoShort.pgType.encode(value),
        typo.runtime.Fragment.lit("::int2")
      )) }
    );
    unsaved.status.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"status\""))
      values.add(interpolate(
        TypoShort.pgType.encode(value),
        typo.runtime.Fragment.lit("::int2")
      )) }
    );
    unsaved.orderdate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"orderdate\""))
      values.add(interpolate(
        TypoLocalDateTime.pgType.encode(value),
        typo.runtime.Fragment.lit("::timestamp")
      )) }
    );
    unsaved.subtotal.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"subtotal\""))
      values.add(interpolate(
        PgTypes.numeric.encode(value),
        typo.runtime.Fragment.lit("::numeric")
      )) }
    );
    unsaved.taxamt.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"taxamt\""))
      values.add(interpolate(
        PgTypes.numeric.encode(value),
        typo.runtime.Fragment.lit("::numeric")
      )) }
    );
    unsaved.freight.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"freight\""))
      values.add(interpolate(
        PgTypes.numeric.encode(value),
        typo.runtime.Fragment.lit("::numeric")
      )) }
    );
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(interpolate(
        TypoLocalDateTime.pgType.encode(value),
        typo.runtime.Fragment.lit("::timestamp")
      )) }
    );
    val q: Fragment = interpolate(
      typo.runtime.Fragment.lit("""
      insert into "purchasing"."purchaseorderheader"(
      """.trimMargin()),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
        )
        values (""".trimMargin()),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
        )
        returning "purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate"::text, "shipdate"::text, "subtotal", "taxamt", "freight", "modifieddate"::text
      """.trimMargin())
    )
    return q.updateReturning(PurchaseorderheaderRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: MutableIterator<PurchaseorderheaderRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "purchasing"."purchaseorderheader"("purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate", "shipdate", "subtotal", "taxamt", "freight", "modifieddate") FROM STDIN
  """.trimMargin()), batchSize, unsaved, c, PurchaseorderheaderRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: MutableIterator<PurchaseorderheaderRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "purchasing"."purchaseorderheader"("employeeid", "vendorid", "shipmethodid", "shipdate", "purchaseorderid", "revisionnumber", "status", "orderdate", "subtotal", "taxamt", "freight", "modifieddate") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')
  """.trimMargin()), batchSize, unsaved, c, PurchaseorderheaderRowUnsaved.pgText)

  override fun select(): SelectBuilder<PurchaseorderheaderFields, PurchaseorderheaderRow> = SelectBuilder.of("\"purchasing\".\"purchaseorderheader\"", PurchaseorderheaderFields.structure, PurchaseorderheaderRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<PurchaseorderheaderRow> = interpolate(typo.runtime.Fragment.lit("""
    select "purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate"::text, "shipdate"::text, "subtotal", "taxamt", "freight", "modifieddate"::text
    from "purchasing"."purchaseorderheader"
  """.trimMargin())).query(PurchaseorderheaderRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    purchaseorderid: PurchaseorderheaderId,
    c: Connection
  ): Optional<PurchaseorderheaderRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select "purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate"::text, "shipdate"::text, "subtotal", "taxamt", "freight", "modifieddate"::text
      from "purchasing"."purchaseorderheader"
      where "purchaseorderid" = """.trimMargin()),
    PurchaseorderheaderId.pgType.encode(purchaseorderid),
    typo.runtime.Fragment.lit("")
  ).query(PurchaseorderheaderRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    purchaseorderids: Array<PurchaseorderheaderId>,
    c: Connection
  ): List<PurchaseorderheaderRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select "purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate"::text, "shipdate"::text, "subtotal", "taxamt", "freight", "modifieddate"::text
      from "purchasing"."purchaseorderheader"
      where "purchaseorderid" = ANY(""".trimMargin()),
    PurchaseorderheaderId.pgTypeArray.encode(purchaseorderids),
    typo.runtime.Fragment.lit(")")
  ).query(PurchaseorderheaderRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    purchaseorderids: Array<PurchaseorderheaderId>,
    c: Connection
  ): Map<PurchaseorderheaderId, PurchaseorderheaderRow> {
    val ret: MutableMap<PurchaseorderheaderId, PurchaseorderheaderRow> = mutableMapOf<PurchaseorderheaderId, PurchaseorderheaderRow>()
    selectByIds(purchaseorderids, c).forEach({ row -> ret.put(row.purchaseorderid, row) })
    return ret
  }

  override fun update(): UpdateBuilder<PurchaseorderheaderFields, PurchaseorderheaderRow> = UpdateBuilder.of("\"purchasing\".\"purchaseorderheader\"", PurchaseorderheaderFields.structure, PurchaseorderheaderRow._rowParser.all(), Dialect.POSTGRESQL)

  override fun update(
    row: PurchaseorderheaderRow,
    c: Connection
  ): Boolean {
    val purchaseorderid: PurchaseorderheaderId = row.purchaseorderid
    return interpolate(
      typo.runtime.Fragment.lit("""
        update "purchasing"."purchaseorderheader"
        set "revisionnumber" = """.trimMargin()),
      TypoShort.pgType.encode(row.revisionnumber),
      typo.runtime.Fragment.lit("""
        ::int2,
        "status" = """.trimMargin()),
      TypoShort.pgType.encode(row.status),
      typo.runtime.Fragment.lit("""
        ::int2,
        "employeeid" = """.trimMargin()),
      BusinessentityId.pgType.encode(row.employeeid),
      typo.runtime.Fragment.lit("""
        ::int4,
        "vendorid" = """.trimMargin()),
      BusinessentityId.pgType.encode(row.vendorid),
      typo.runtime.Fragment.lit("""
        ::int4,
        "shipmethodid" = """.trimMargin()),
      ShipmethodId.pgType.encode(row.shipmethodid),
      typo.runtime.Fragment.lit("""
        ::int4,
        "orderdate" = """.trimMargin()),
      TypoLocalDateTime.pgType.encode(row.orderdate),
      typo.runtime.Fragment.lit("""
        ::timestamp,
        "shipdate" = """.trimMargin()),
      TypoLocalDateTime.pgType.opt().encode(row.shipdate),
      typo.runtime.Fragment.lit("""
        ::timestamp,
        "subtotal" = """.trimMargin()),
      PgTypes.numeric.encode(row.subtotal),
      typo.runtime.Fragment.lit("""
        ::numeric,
        "taxamt" = """.trimMargin()),
      PgTypes.numeric.encode(row.taxamt),
      typo.runtime.Fragment.lit("""
        ::numeric,
        "freight" = """.trimMargin()),
      PgTypes.numeric.encode(row.freight),
      typo.runtime.Fragment.lit("""
        ::numeric,
        "modifieddate" = """.trimMargin()),
      TypoLocalDateTime.pgType.encode(row.modifieddate),
      typo.runtime.Fragment.lit("""
        ::timestamp
        where "purchaseorderid" = """.trimMargin()),
      PurchaseorderheaderId.pgType.encode(purchaseorderid),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: PurchaseorderheaderRow,
    c: Connection
  ): PurchaseorderheaderRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "purchasing"."purchaseorderheader"("purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate", "shipdate", "subtotal", "taxamt", "freight", "modifieddate")
      values (""".trimMargin()),
    PurchaseorderheaderId.pgType.encode(unsaved.purchaseorderid),
    typo.runtime.Fragment.lit("::int4, "),
    TypoShort.pgType.encode(unsaved.revisionnumber),
    typo.runtime.Fragment.lit("::int2, "),
    TypoShort.pgType.encode(unsaved.status),
    typo.runtime.Fragment.lit("::int2, "),
    BusinessentityId.pgType.encode(unsaved.employeeid),
    typo.runtime.Fragment.lit("::int4, "),
    BusinessentityId.pgType.encode(unsaved.vendorid),
    typo.runtime.Fragment.lit("::int4, "),
    ShipmethodId.pgType.encode(unsaved.shipmethodid),
    typo.runtime.Fragment.lit("::int4, "),
    TypoLocalDateTime.pgType.encode(unsaved.orderdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    TypoLocalDateTime.pgType.opt().encode(unsaved.shipdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    PgTypes.numeric.encode(unsaved.subtotal),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.encode(unsaved.taxamt),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.encode(unsaved.freight),
    typo.runtime.Fragment.lit("::numeric, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("""
      ::timestamp)
      on conflict ("purchaseorderid")
      do update set
        "revisionnumber" = EXCLUDED."revisionnumber",
      "status" = EXCLUDED."status",
      "employeeid" = EXCLUDED."employeeid",
      "vendorid" = EXCLUDED."vendorid",
      "shipmethodid" = EXCLUDED."shipmethodid",
      "orderdate" = EXCLUDED."orderdate",
      "shipdate" = EXCLUDED."shipdate",
      "subtotal" = EXCLUDED."subtotal",
      "taxamt" = EXCLUDED."taxamt",
      "freight" = EXCLUDED."freight",
      "modifieddate" = EXCLUDED."modifieddate"
      returning "purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate"::text, "shipdate"::text, "subtotal", "taxamt", "freight", "modifieddate"::text""".trimMargin())
  )
    .updateReturning(PurchaseorderheaderRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: MutableIterator<PurchaseorderheaderRow>,
    c: Connection
  ): List<PurchaseorderheaderRow> = interpolate(typo.runtime.Fragment.lit("""
                                      insert into "purchasing"."purchaseorderheader"("purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate", "shipdate", "subtotal", "taxamt", "freight", "modifieddate")
                                      values (?::int4, ?::int2, ?::int2, ?::int4, ?::int4, ?::int4, ?::timestamp, ?::timestamp, ?::numeric, ?::numeric, ?::numeric, ?::timestamp)
                                      on conflict ("purchaseorderid")
                                      do update set
                                        "revisionnumber" = EXCLUDED."revisionnumber",
                                      "status" = EXCLUDED."status",
                                      "employeeid" = EXCLUDED."employeeid",
                                      "vendorid" = EXCLUDED."vendorid",
                                      "shipmethodid" = EXCLUDED."shipmethodid",
                                      "orderdate" = EXCLUDED."orderdate",
                                      "shipdate" = EXCLUDED."shipdate",
                                      "subtotal" = EXCLUDED."subtotal",
                                      "taxamt" = EXCLUDED."taxamt",
                                      "freight" = EXCLUDED."freight",
                                      "modifieddate" = EXCLUDED."modifieddate"
                                      returning "purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate"::text, "shipdate"::text, "subtotal", "taxamt", "freight", "modifieddate"::text""".trimMargin()))
    .updateManyReturning(PurchaseorderheaderRow._rowParser, unsaved)
    .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: MutableIterator<PurchaseorderheaderRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    interpolate(typo.runtime.Fragment.lit("""
    create temporary table purchaseorderheader_TEMP (like "purchasing"."purchaseorderheader") on commit drop
    """.trimMargin())).update().runUnchecked(c)
    streamingInsert.insertUnchecked(str("""
    copy purchaseorderheader_TEMP("purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate", "shipdate", "subtotal", "taxamt", "freight", "modifieddate") from stdin
    """.trimMargin()), batchSize, unsaved, c, PurchaseorderheaderRow.pgText)
    return interpolate(typo.runtime.Fragment.lit("""
      insert into "purchasing"."purchaseorderheader"("purchaseorderid", "revisionnumber", "status", "employeeid", "vendorid", "shipmethodid", "orderdate", "shipdate", "subtotal", "taxamt", "freight", "modifieddate")
      select * from purchaseorderheader_TEMP
      on conflict ("purchaseorderid")
      do update set
        "revisionnumber" = EXCLUDED."revisionnumber",
      "status" = EXCLUDED."status",
      "employeeid" = EXCLUDED."employeeid",
      "vendorid" = EXCLUDED."vendorid",
      "shipmethodid" = EXCLUDED."shipmethodid",
      "orderdate" = EXCLUDED."orderdate",
      "shipdate" = EXCLUDED."shipdate",
      "subtotal" = EXCLUDED."subtotal",
      "taxamt" = EXCLUDED."taxamt",
      "freight" = EXCLUDED."freight",
      "modifieddate" = EXCLUDED."modifieddate"
      ;
      drop table purchaseorderheader_TEMP;""".trimMargin())).update().runUnchecked(c)
  }
}