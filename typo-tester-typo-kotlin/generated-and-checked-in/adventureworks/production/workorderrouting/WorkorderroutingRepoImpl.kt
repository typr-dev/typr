/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.workorderrouting

import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.customtypes.TypoShort
import adventureworks.production.location.LocationId
import adventureworks.production.workorder.WorkorderId
import java.sql.Connection
import java.util.ArrayList
import java.util.Optional
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableIterator
import kotlin.collections.MutableMap
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.PgTypes
import typo.runtime.internal.arrayMap
import typo.runtime.streamingInsert
import typo.runtime.Fragment.interpolate
import typo.runtime.internal.stringInterpolator.str

class WorkorderroutingRepoImpl() : WorkorderroutingRepo {
  override fun delete(): DeleteBuilder<WorkorderroutingFields, WorkorderroutingRow> = DeleteBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    compositeId: WorkorderroutingId,
    c: Connection
  ): Boolean = interpolate(
    typo.runtime.Fragment.lit("""
    delete from "production"."workorderrouting" where "workorderid" = 
    """.trimMargin()),
    WorkorderId.pgType.encode(compositeId.workorderid),
    typo.runtime.Fragment.lit("""
     AND "productid" = 
    """.trimMargin()),
    PgTypes.int4.encode(compositeId.productid),
    typo.runtime.Fragment.lit("""
     AND "operationsequence" = 
    """.trimMargin()),
    TypoShort.pgType.encode(compositeId.operationsequence),
    typo.runtime.Fragment.lit("")
  ).update().runUnchecked(c) > 0

  override fun deleteByIds(
    compositeIds: Array<WorkorderroutingId>,
    c: Connection
  ): Int {
    val workorderid: Array<WorkorderId> = arrayMap.map(compositeIds, WorkorderroutingId::workorderid, WorkorderId::class.java)
    val productid: Array<Int> = arrayMap.map(compositeIds, WorkorderroutingId::productid, Int::class.javaObjectType)
    val operationsequence: Array<TypoShort> = arrayMap.map(compositeIds, WorkorderroutingId::operationsequence, TypoShort::class.java)
    return interpolate(
      typo.runtime.Fragment.lit("""
        delete
        from "production"."workorderrouting"
        where ("workorderid", "productid", "operationsequence")
        in (select unnest(""".trimMargin()),
      WorkorderId.pgTypeArray.encode(workorderid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      PgTypes.int4Array.encode(productid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      TypoShort.pgTypeArray.encode(operationsequence),
      typo.runtime.Fragment.lit("""
      ::int2[]))

      """.trimMargin())
    ).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: WorkorderroutingRow,
    c: Connection
  ): WorkorderroutingRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate")
      values (""".trimMargin()),
    WorkorderId.pgType.encode(unsaved.workorderid),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.int4.encode(unsaved.productid),
    typo.runtime.Fragment.lit("::int4, "),
    TypoShort.pgType.encode(unsaved.operationsequence),
    typo.runtime.Fragment.lit("::int2, "),
    LocationId.pgType.encode(unsaved.locationid),
    typo.runtime.Fragment.lit("::int2, "),
    TypoLocalDateTime.pgType.encode(unsaved.scheduledstartdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    TypoLocalDateTime.pgType.encode(unsaved.scheduledenddate),
    typo.runtime.Fragment.lit("::timestamp, "),
    TypoLocalDateTime.pgType.opt().encode(unsaved.actualstartdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    TypoLocalDateTime.pgType.opt().encode(unsaved.actualenddate),
    typo.runtime.Fragment.lit("::timestamp, "),
    PgTypes.numeric.opt().encode(unsaved.actualresourcehrs),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.encode(unsaved.plannedcost),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.opt().encode(unsaved.actualcost),
    typo.runtime.Fragment.lit("::numeric, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("""
      ::timestamp)
      returning "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
    """.trimMargin())
  )
    .updateReturning(WorkorderroutingRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: WorkorderroutingRowUnsaved,
    c: Connection
  ): WorkorderroutingRow {
    val columns: ArrayList<Literal> = ArrayList<Literal>()
    val values: ArrayList<Fragment> = ArrayList<Fragment>()
    columns.add(Fragment.lit("\"workorderid\""))
    values.add(interpolate(
      WorkorderId.pgType.encode(unsaved.workorderid),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"productid\""))
    values.add(interpolate(
      PgTypes.int4.encode(unsaved.productid),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"operationsequence\""))
    values.add(interpolate(
      TypoShort.pgType.encode(unsaved.operationsequence),
      typo.runtime.Fragment.lit("::int2")
    ))
    columns.add(Fragment.lit("\"locationid\""))
    values.add(interpolate(
      LocationId.pgType.encode(unsaved.locationid),
      typo.runtime.Fragment.lit("::int2")
    ))
    columns.add(Fragment.lit("\"scheduledstartdate\""))
    values.add(interpolate(
      TypoLocalDateTime.pgType.encode(unsaved.scheduledstartdate),
      typo.runtime.Fragment.lit("::timestamp")
    ))
    columns.add(Fragment.lit("\"scheduledenddate\""))
    values.add(interpolate(
      TypoLocalDateTime.pgType.encode(unsaved.scheduledenddate),
      typo.runtime.Fragment.lit("::timestamp")
    ))
    columns.add(Fragment.lit("\"actualstartdate\""))
    values.add(interpolate(
      TypoLocalDateTime.pgType.opt().encode(unsaved.actualstartdate),
      typo.runtime.Fragment.lit("::timestamp")
    ))
    columns.add(Fragment.lit("\"actualenddate\""))
    values.add(interpolate(
      TypoLocalDateTime.pgType.opt().encode(unsaved.actualenddate),
      typo.runtime.Fragment.lit("::timestamp")
    ))
    columns.add(Fragment.lit("\"actualresourcehrs\""))
    values.add(interpolate(
      PgTypes.numeric.opt().encode(unsaved.actualresourcehrs),
      typo.runtime.Fragment.lit("::numeric")
    ))
    columns.add(Fragment.lit("\"plannedcost\""))
    values.add(interpolate(
      PgTypes.numeric.encode(unsaved.plannedcost),
      typo.runtime.Fragment.lit("::numeric")
    ))
    columns.add(Fragment.lit("\"actualcost\""))
    values.add(interpolate(
      PgTypes.numeric.opt().encode(unsaved.actualcost),
      typo.runtime.Fragment.lit("::numeric")
    ))
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(interpolate(
        TypoLocalDateTime.pgType.encode(value),
        typo.runtime.Fragment.lit("::timestamp")
      )) }
    );
    val q: Fragment = interpolate(
      typo.runtime.Fragment.lit("""
      insert into "production"."workorderrouting"(
      """.trimMargin()),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
        )
        values (""".trimMargin()),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
        )
        returning "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
      """.trimMargin())
    )
    return q.updateReturning(WorkorderroutingRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: MutableIterator<WorkorderroutingRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate") FROM STDIN
  """.trimMargin()), batchSize, unsaved, c, WorkorderroutingRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: MutableIterator<WorkorderroutingRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')
  """.trimMargin()), batchSize, unsaved, c, WorkorderroutingRowUnsaved.pgText)

  override fun select(): SelectBuilder<WorkorderroutingFields, WorkorderroutingRow> = SelectBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure, WorkorderroutingRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<WorkorderroutingRow> = interpolate(typo.runtime.Fragment.lit("""
    select "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
    from "production"."workorderrouting"
  """.trimMargin())).query(WorkorderroutingRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    compositeId: WorkorderroutingId,
    c: Connection
  ): Optional<WorkorderroutingRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
      from "production"."workorderrouting"
      where "workorderid" = """.trimMargin()),
    WorkorderId.pgType.encode(compositeId.workorderid),
    typo.runtime.Fragment.lit("""
     AND "productid" = 
    """.trimMargin()),
    PgTypes.int4.encode(compositeId.productid),
    typo.runtime.Fragment.lit("""
     AND "operationsequence" = 
    """.trimMargin()),
    TypoShort.pgType.encode(compositeId.operationsequence),
    typo.runtime.Fragment.lit("")
  ).query(WorkorderroutingRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    compositeIds: Array<WorkorderroutingId>,
    c: Connection
  ): List<WorkorderroutingRow> {
    val workorderid: Array<WorkorderId> = arrayMap.map(compositeIds, WorkorderroutingId::workorderid, WorkorderId::class.java)
    val productid: Array<Int> = arrayMap.map(compositeIds, WorkorderroutingId::productid, Int::class.javaObjectType)
    val operationsequence: Array<TypoShort> = arrayMap.map(compositeIds, WorkorderroutingId::operationsequence, TypoShort::class.java)
    return interpolate(
      typo.runtime.Fragment.lit("""
        select "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text
        from "production"."workorderrouting"
        where ("workorderid", "productid", "operationsequence")
        in (select unnest(""".trimMargin()),
      WorkorderId.pgTypeArray.encode(workorderid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      PgTypes.int4Array.encode(productid),
      typo.runtime.Fragment.lit("::int4[]), unnest("),
      TypoShort.pgTypeArray.encode(operationsequence),
      typo.runtime.Fragment.lit("""
      ::int2[]))

      """.trimMargin())
    ).query(WorkorderroutingRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    compositeIds: Array<WorkorderroutingId>,
    c: Connection
  ): Map<WorkorderroutingId, WorkorderroutingRow> {
    val ret: MutableMap<WorkorderroutingId, WorkorderroutingRow> = mutableMapOf<WorkorderroutingId, WorkorderroutingRow>()
    selectByIds(compositeIds, c).forEach({ row -> ret.put(row.compositeId(), row) })
    return ret
  }

  override fun update(): UpdateBuilder<WorkorderroutingFields, WorkorderroutingRow> = UpdateBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure, WorkorderroutingRow._rowParser.all(), Dialect.POSTGRESQL)

  override fun update(
    row: WorkorderroutingRow,
    c: Connection
  ): Boolean {
    val compositeId: WorkorderroutingId = row.compositeId()
    return interpolate(
      typo.runtime.Fragment.lit("""
        update "production"."workorderrouting"
        set "locationid" = """.trimMargin()),
      LocationId.pgType.encode(row.locationid),
      typo.runtime.Fragment.lit("""
        ::int2,
        "scheduledstartdate" = """.trimMargin()),
      TypoLocalDateTime.pgType.encode(row.scheduledstartdate),
      typo.runtime.Fragment.lit("""
        ::timestamp,
        "scheduledenddate" = """.trimMargin()),
      TypoLocalDateTime.pgType.encode(row.scheduledenddate),
      typo.runtime.Fragment.lit("""
        ::timestamp,
        "actualstartdate" = """.trimMargin()),
      TypoLocalDateTime.pgType.opt().encode(row.actualstartdate),
      typo.runtime.Fragment.lit("""
        ::timestamp,
        "actualenddate" = """.trimMargin()),
      TypoLocalDateTime.pgType.opt().encode(row.actualenddate),
      typo.runtime.Fragment.lit("""
        ::timestamp,
        "actualresourcehrs" = """.trimMargin()),
      PgTypes.numeric.opt().encode(row.actualresourcehrs),
      typo.runtime.Fragment.lit("""
        ::numeric,
        "plannedcost" = """.trimMargin()),
      PgTypes.numeric.encode(row.plannedcost),
      typo.runtime.Fragment.lit("""
        ::numeric,
        "actualcost" = """.trimMargin()),
      PgTypes.numeric.opt().encode(row.actualcost),
      typo.runtime.Fragment.lit("""
        ::numeric,
        "modifieddate" = """.trimMargin()),
      TypoLocalDateTime.pgType.encode(row.modifieddate),
      typo.runtime.Fragment.lit("""
        ::timestamp
        where "workorderid" = """.trimMargin()),
      WorkorderId.pgType.encode(compositeId.workorderid),
      typo.runtime.Fragment.lit("""
       AND "productid" = 
      """.trimMargin()),
      PgTypes.int4.encode(compositeId.productid),
      typo.runtime.Fragment.lit("""
       AND "operationsequence" = 
      """.trimMargin()),
      TypoShort.pgType.encode(compositeId.operationsequence),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: WorkorderroutingRow,
    c: Connection
  ): WorkorderroutingRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate")
      values (""".trimMargin()),
    WorkorderId.pgType.encode(unsaved.workorderid),
    typo.runtime.Fragment.lit("::int4, "),
    PgTypes.int4.encode(unsaved.productid),
    typo.runtime.Fragment.lit("::int4, "),
    TypoShort.pgType.encode(unsaved.operationsequence),
    typo.runtime.Fragment.lit("::int2, "),
    LocationId.pgType.encode(unsaved.locationid),
    typo.runtime.Fragment.lit("::int2, "),
    TypoLocalDateTime.pgType.encode(unsaved.scheduledstartdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    TypoLocalDateTime.pgType.encode(unsaved.scheduledenddate),
    typo.runtime.Fragment.lit("::timestamp, "),
    TypoLocalDateTime.pgType.opt().encode(unsaved.actualstartdate),
    typo.runtime.Fragment.lit("::timestamp, "),
    TypoLocalDateTime.pgType.opt().encode(unsaved.actualenddate),
    typo.runtime.Fragment.lit("::timestamp, "),
    PgTypes.numeric.opt().encode(unsaved.actualresourcehrs),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.encode(unsaved.plannedcost),
    typo.runtime.Fragment.lit("::numeric, "),
    PgTypes.numeric.opt().encode(unsaved.actualcost),
    typo.runtime.Fragment.lit("::numeric, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("""
      ::timestamp)
      on conflict ("workorderid", "productid", "operationsequence")
      do update set
        "locationid" = EXCLUDED."locationid",
      "scheduledstartdate" = EXCLUDED."scheduledstartdate",
      "scheduledenddate" = EXCLUDED."scheduledenddate",
      "actualstartdate" = EXCLUDED."actualstartdate",
      "actualenddate" = EXCLUDED."actualenddate",
      "actualresourcehrs" = EXCLUDED."actualresourcehrs",
      "plannedcost" = EXCLUDED."plannedcost",
      "actualcost" = EXCLUDED."actualcost",
      "modifieddate" = EXCLUDED."modifieddate"
      returning "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text""".trimMargin())
  )
    .updateReturning(WorkorderroutingRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: MutableIterator<WorkorderroutingRow>,
    c: Connection
  ): List<WorkorderroutingRow> = interpolate(typo.runtime.Fragment.lit("""
                                   insert into "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate")
                                   values (?::int4, ?::int4, ?::int2, ?::int2, ?::timestamp, ?::timestamp, ?::timestamp, ?::timestamp, ?::numeric, ?::numeric, ?::numeric, ?::timestamp)
                                   on conflict ("workorderid", "productid", "operationsequence")
                                   do update set
                                     "locationid" = EXCLUDED."locationid",
                                   "scheduledstartdate" = EXCLUDED."scheduledstartdate",
                                   "scheduledenddate" = EXCLUDED."scheduledenddate",
                                   "actualstartdate" = EXCLUDED."actualstartdate",
                                   "actualenddate" = EXCLUDED."actualenddate",
                                   "actualresourcehrs" = EXCLUDED."actualresourcehrs",
                                   "plannedcost" = EXCLUDED."plannedcost",
                                   "actualcost" = EXCLUDED."actualcost",
                                   "modifieddate" = EXCLUDED."modifieddate"
                                   returning "workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate"::text, "scheduledenddate"::text, "actualstartdate"::text, "actualenddate"::text, "actualresourcehrs", "plannedcost", "actualcost", "modifieddate"::text""".trimMargin()))
    .updateManyReturning(WorkorderroutingRow._rowParser, unsaved)
    .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: MutableIterator<WorkorderroutingRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    interpolate(typo.runtime.Fragment.lit("""
    create temporary table workorderrouting_TEMP (like "production"."workorderrouting") on commit drop
    """.trimMargin())).update().runUnchecked(c)
    streamingInsert.insertUnchecked(str("""
    copy workorderrouting_TEMP("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate") from stdin
    """.trimMargin()), batchSize, unsaved, c, WorkorderroutingRow.pgText)
    return interpolate(typo.runtime.Fragment.lit("""
      insert into "production"."workorderrouting"("workorderid", "productid", "operationsequence", "locationid", "scheduledstartdate", "scheduledenddate", "actualstartdate", "actualenddate", "actualresourcehrs", "plannedcost", "actualcost", "modifieddate")
      select * from workorderrouting_TEMP
      on conflict ("workorderid", "productid", "operationsequence")
      do update set
        "locationid" = EXCLUDED."locationid",
      "scheduledstartdate" = EXCLUDED."scheduledstartdate",
      "scheduledenddate" = EXCLUDED."scheduledenddate",
      "actualstartdate" = EXCLUDED."actualstartdate",
      "actualenddate" = EXCLUDED."actualenddate",
      "actualresourcehrs" = EXCLUDED."actualresourcehrs",
      "plannedcost" = EXCLUDED."plannedcost",
      "actualcost" = EXCLUDED."actualcost",
      "modifieddate" = EXCLUDED."modifieddate"
      ;
      drop table workorderrouting_TEMP;""".trimMargin())).update().runUnchecked(c)
  }
}