/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.workorderrouting

import adventureworks.production.location.LocationId
import adventureworks.production.workorder.WorkorderId
import java.sql.Connection
import java.util.ArrayList
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.KotlinDbTypes
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.kotlindsl.nullable
import typo.runtime.PgTypes
import typo.runtime.internal.arrayMap
import typo.runtime.streamingInsert

class WorkorderroutingRepoImpl() : WorkorderroutingRepo {
  override fun delete(): DeleteBuilder<WorkorderroutingFields, WorkorderroutingRow> = DeleteBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    compositeId: WorkorderroutingId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"production\".\"workorderrouting\" where \"workorderid\" = "), Fragment.encode(WorkorderId.pgType, compositeId.workorderid), Fragment.lit(" AND \"productid\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4, compositeId.productid), Fragment.lit(" AND \"operationsequence\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int2, compositeId.operationsequence), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    compositeIds: Array<WorkorderroutingId>,
    c: Connection
  ): Int {
    val workorderid: Array<WorkorderId> = arrayMap.map(compositeIds, WorkorderroutingId::workorderid, WorkorderId::class.java)
    val productid: Array<Int> = arrayMap.map(compositeIds, WorkorderroutingId::productid, Int::class.javaObjectType)
    val operationsequence: Array<Short> = arrayMap.map(compositeIds, WorkorderroutingId::operationsequence, Short::class.javaObjectType)
    return Fragment.interpolate(Fragment.lit("delete\nfrom \"production\".\"workorderrouting\"\nwhere (\"workorderid\", \"productid\", \"operationsequence\")\nin (select * from unnest("), Fragment.encode(WorkorderId.pgTypeArray, workorderid), Fragment.lit(", "), Fragment.encode(PgTypes.int4Array, productid), Fragment.lit(", "), Fragment.encode(PgTypes.int2Array, operationsequence), Fragment.lit("))\n")).update().runUnchecked(c)
  }

  override fun insert(
    unsaved: WorkorderroutingRow,
    c: Connection
  ): WorkorderroutingRow = Fragment.interpolate(Fragment.lit("insert into \"production\".\"workorderrouting\"(\"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\")\nvalues ("), Fragment.encode(WorkorderId.pgType, unsaved.workorderid), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.productid), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int2, unsaved.operationsequence), Fragment.lit("::int2, "), Fragment.encode(LocationId.pgType, unsaved.locationid), Fragment.lit("::int2, "), Fragment.encode(PgTypes.timestamp, unsaved.scheduledstartdate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.timestamp, unsaved.scheduledenddate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.timestamp.nullable(), unsaved.actualstartdate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.timestamp.nullable(), unsaved.actualenddate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.numeric.nullable(), unsaved.actualresourcehrs), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.numeric, unsaved.plannedcost), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.numeric.nullable(), unsaved.actualcost), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp)\nRETURNING \"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\"\n"))
    .updateReturning(WorkorderroutingRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: WorkorderroutingRowUnsaved,
    c: Connection
  ): WorkorderroutingRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("\"workorderid\""))
    values.add(Fragment.interpolate(Fragment.encode(WorkorderId.pgType, unsaved.workorderid), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"productid\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.productid), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"operationsequence\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int2, unsaved.operationsequence), Fragment.lit("::int2")))
    columns.add(Fragment.lit("\"locationid\""))
    values.add(Fragment.interpolate(Fragment.encode(LocationId.pgType, unsaved.locationid), Fragment.lit("::int2")))
    columns.add(Fragment.lit("\"scheduledstartdate\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp, unsaved.scheduledstartdate), Fragment.lit("::timestamp")))
    columns.add(Fragment.lit("\"scheduledenddate\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp, unsaved.scheduledenddate), Fragment.lit("::timestamp")))
    columns.add(Fragment.lit("\"actualstartdate\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp.nullable(), unsaved.actualstartdate), Fragment.lit("::timestamp")))
    columns.add(Fragment.lit("\"actualenddate\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp.nullable(), unsaved.actualenddate), Fragment.lit("::timestamp")))
    columns.add(Fragment.lit("\"actualresourcehrs\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.numeric.nullable(), unsaved.actualresourcehrs), Fragment.lit("::numeric")))
    columns.add(Fragment.lit("\"plannedcost\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.numeric, unsaved.plannedcost), Fragment.lit("::numeric")))
    columns.add(Fragment.lit("\"actualcost\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.numeric.nullable(), unsaved.actualcost), Fragment.lit("::numeric")))
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp, value), Fragment.lit("::timestamp"))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into \"production\".\"workorderrouting\"("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING \"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\"\n"))
    return q.updateReturning(WorkorderroutingRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: Iterator<WorkorderroutingRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"production\".\"workorderrouting\"(\"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\") FROM STDIN", batchSize, unsaved, c, WorkorderroutingRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: Iterator<WorkorderroutingRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"production\".\"workorderrouting\"(\"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')", batchSize, unsaved, c, WorkorderroutingRowUnsaved.pgText)

  override fun select(): SelectBuilder<WorkorderroutingFields, WorkorderroutingRow> = SelectBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure, WorkorderroutingRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<WorkorderroutingRow> = Fragment.interpolate(Fragment.lit("select \"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\"\nfrom \"production\".\"workorderrouting\"\n")).query(WorkorderroutingRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    compositeId: WorkorderroutingId,
    c: Connection
  ): WorkorderroutingRow? = Fragment.interpolate(Fragment.lit("select \"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\"\nfrom \"production\".\"workorderrouting\"\nwhere \"workorderid\" = "), Fragment.encode(WorkorderId.pgType, compositeId.workorderid), Fragment.lit(" AND \"productid\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4, compositeId.productid), Fragment.lit(" AND \"operationsequence\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int2, compositeId.operationsequence), Fragment.lit("")).query(WorkorderroutingRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    compositeIds: Array<WorkorderroutingId>,
    c: Connection
  ): List<WorkorderroutingRow> {
    val workorderid: Array<WorkorderId> = arrayMap.map(compositeIds, WorkorderroutingId::workorderid, WorkorderId::class.java)
    val productid: Array<Int> = arrayMap.map(compositeIds, WorkorderroutingId::productid, Int::class.javaObjectType)
    val operationsequence: Array<Short> = arrayMap.map(compositeIds, WorkorderroutingId::operationsequence, Short::class.javaObjectType)
    return Fragment.interpolate(Fragment.lit("select \"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\"\nfrom \"production\".\"workorderrouting\"\nwhere (\"workorderid\", \"productid\", \"operationsequence\")\nin (select * from unnest("), Fragment.encode(WorkorderId.pgTypeArray, workorderid), Fragment.lit(", "), Fragment.encode(PgTypes.int4Array, productid), Fragment.lit(", "), Fragment.encode(PgTypes.int2Array, operationsequence), Fragment.lit("))\n")).query(WorkorderroutingRow._rowParser.all()).runUnchecked(c)
  }

  override fun selectByIdsTracked(
    compositeIds: Array<WorkorderroutingId>,
    c: Connection
  ): Map<WorkorderroutingId, WorkorderroutingRow> {
    val ret: MutableMap<WorkorderroutingId, WorkorderroutingRow> = mutableMapOf<WorkorderroutingId, WorkorderroutingRow>()
    selectByIds(compositeIds, c).forEach({ row -> ret.put(row.compositeId(), row) })
    return ret.toMap()
  }

  override fun update(): UpdateBuilder<WorkorderroutingFields, WorkorderroutingRow> = UpdateBuilder.of("\"production\".\"workorderrouting\"", WorkorderroutingFields.structure, WorkorderroutingRow._rowParser, Dialect.POSTGRESQL)

  override fun update(
    row: WorkorderroutingRow,
    c: Connection
  ): Boolean {
    val compositeId: WorkorderroutingId = row.compositeId()
    return Fragment.interpolate(Fragment.lit("update \"production\".\"workorderrouting\"\nset \"locationid\" = "), Fragment.encode(LocationId.pgType, row.locationid), Fragment.lit("::int2,\n\"scheduledstartdate\" = "), Fragment.encode(PgTypes.timestamp, row.scheduledstartdate), Fragment.lit("::timestamp,\n\"scheduledenddate\" = "), Fragment.encode(PgTypes.timestamp, row.scheduledenddate), Fragment.lit("::timestamp,\n\"actualstartdate\" = "), Fragment.encode(PgTypes.timestamp.nullable(), row.actualstartdate), Fragment.lit("::timestamp,\n\"actualenddate\" = "), Fragment.encode(PgTypes.timestamp.nullable(), row.actualenddate), Fragment.lit("::timestamp,\n\"actualresourcehrs\" = "), Fragment.encode(PgTypes.numeric.nullable(), row.actualresourcehrs), Fragment.lit("::numeric,\n\"plannedcost\" = "), Fragment.encode(PgTypes.numeric, row.plannedcost), Fragment.lit("::numeric,\n\"actualcost\" = "), Fragment.encode(PgTypes.numeric.nullable(), row.actualcost), Fragment.lit("::numeric,\n\"modifieddate\" = "), Fragment.encode(PgTypes.timestamp, row.modifieddate), Fragment.lit("::timestamp\nwhere \"workorderid\" = "), Fragment.encode(WorkorderId.pgType, compositeId.workorderid), Fragment.lit(" AND \"productid\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4, compositeId.productid), Fragment.lit(" AND \"operationsequence\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int2, compositeId.operationsequence), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: WorkorderroutingRow,
    c: Connection
  ): WorkorderroutingRow = Fragment.interpolate(Fragment.lit("insert into \"production\".\"workorderrouting\"(\"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\")\nvalues ("), Fragment.encode(WorkorderId.pgType, unsaved.workorderid), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.productid), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int2, unsaved.operationsequence), Fragment.lit("::int2, "), Fragment.encode(LocationId.pgType, unsaved.locationid), Fragment.lit("::int2, "), Fragment.encode(PgTypes.timestamp, unsaved.scheduledstartdate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.timestamp, unsaved.scheduledenddate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.timestamp.nullable(), unsaved.actualstartdate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.timestamp.nullable(), unsaved.actualenddate), Fragment.lit("::timestamp, "), Fragment.encode(PgTypes.numeric.nullable(), unsaved.actualresourcehrs), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.numeric, unsaved.plannedcost), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.numeric.nullable(), unsaved.actualcost), Fragment.lit("::numeric, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp)\non conflict (\"workorderid\", \"productid\", \"operationsequence\")\ndo update set\n  \"locationid\" = EXCLUDED.\"locationid\",\n\"scheduledstartdate\" = EXCLUDED.\"scheduledstartdate\",\n\"scheduledenddate\" = EXCLUDED.\"scheduledenddate\",\n\"actualstartdate\" = EXCLUDED.\"actualstartdate\",\n\"actualenddate\" = EXCLUDED.\"actualenddate\",\n\"actualresourcehrs\" = EXCLUDED.\"actualresourcehrs\",\n\"plannedcost\" = EXCLUDED.\"plannedcost\",\n\"actualcost\" = EXCLUDED.\"actualcost\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\""))
    .updateReturning(WorkorderroutingRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<WorkorderroutingRow>,
    c: Connection
  ): List<WorkorderroutingRow> = Fragment.interpolate(Fragment.lit("insert into \"production\".\"workorderrouting\"(\"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\")\nvalues (?::int4, ?::int4, ?::int2, ?::int2, ?::timestamp, ?::timestamp, ?::timestamp, ?::timestamp, ?::numeric, ?::numeric, ?::numeric, ?::timestamp)\non conflict (\"workorderid\", \"productid\", \"operationsequence\")\ndo update set\n  \"locationid\" = EXCLUDED.\"locationid\",\n\"scheduledstartdate\" = EXCLUDED.\"scheduledstartdate\",\n\"scheduledenddate\" = EXCLUDED.\"scheduledenddate\",\n\"actualstartdate\" = EXCLUDED.\"actualstartdate\",\n\"actualenddate\" = EXCLUDED.\"actualenddate\",\n\"actualresourcehrs\" = EXCLUDED.\"actualresourcehrs\",\n\"plannedcost\" = EXCLUDED.\"plannedcost\",\n\"actualcost\" = EXCLUDED.\"actualcost\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\""))
    .updateManyReturning(WorkorderroutingRow._rowParser, unsaved)
  .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: Iterator<WorkorderroutingRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    Fragment.interpolate(Fragment.lit("create temporary table workorderrouting_TEMP (like \"production\".\"workorderrouting\") on commit drop")).update().runUnchecked(c)
    streamingInsert.insertUnchecked("copy workorderrouting_TEMP(\"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\") from stdin", batchSize, unsaved, c, WorkorderroutingRow.pgText)
    return Fragment.interpolate(Fragment.lit("insert into \"production\".\"workorderrouting\"(\"workorderid\", \"productid\", \"operationsequence\", \"locationid\", \"scheduledstartdate\", \"scheduledenddate\", \"actualstartdate\", \"actualenddate\", \"actualresourcehrs\", \"plannedcost\", \"actualcost\", \"modifieddate\")\nselect * from workorderrouting_TEMP\non conflict (\"workorderid\", \"productid\", \"operationsequence\")\ndo update set\n  \"locationid\" = EXCLUDED.\"locationid\",\n\"scheduledstartdate\" = EXCLUDED.\"scheduledstartdate\",\n\"scheduledenddate\" = EXCLUDED.\"scheduledenddate\",\n\"actualstartdate\" = EXCLUDED.\"actualstartdate\",\n\"actualenddate\" = EXCLUDED.\"actualenddate\",\n\"actualresourcehrs\" = EXCLUDED.\"actualresourcehrs\",\n\"plannedcost\" = EXCLUDED.\"plannedcost\",\n\"actualcost\" = EXCLUDED.\"actualcost\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\n;\ndrop table workorderrouting_TEMP;")).update().runUnchecked(c)
  }
}