/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.document

import adventureworks.person.businessentity.BusinessentityId
import adventureworks.public.Flag
import java.sql.Connection
import java.util.ArrayList
import java.util.UUID
import kotlin.collections.Iterator
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableMap
import typo.kotlindsl.DeleteBuilder
import typo.kotlindsl.Dialect
import typo.kotlindsl.Fragment
import typo.kotlindsl.KotlinDbTypes
import typo.kotlindsl.SelectBuilder
import typo.kotlindsl.UpdateBuilder
import typo.kotlindsl.nullable
import typo.runtime.PgTypes
import typo.runtime.streamingInsert

class DocumentRepoImpl() : DocumentRepo {
  override fun delete(): DeleteBuilder<DocumentFields, DocumentRow> = DeleteBuilder.of("\"production\".\"document\"", DocumentFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    documentnode: DocumentId,
    c: Connection
  ): Boolean = Fragment.interpolate(Fragment.lit("delete from \"production\".\"document\" where \"documentnode\" = "), Fragment.encode(DocumentId.pgType, documentnode), Fragment.lit("")).update().runUnchecked(c) > 0

  override fun deleteByIds(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): Int = Fragment.interpolate(Fragment.lit("delete\nfrom \"production\".\"document\"\nwhere \"documentnode\" = ANY("), Fragment.encode(DocumentId.pgTypeArray, documentnodes), Fragment.lit(")"))
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: DocumentRow,
    c: Connection
  ): DocumentRow = Fragment.interpolate(Fragment.lit("insert into \"production\".\"document\"(\"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\")\nvalues ("), Fragment.encode(PgTypes.text, unsaved.title), Fragment.lit(", "), Fragment.encode(BusinessentityId.pgType, unsaved.owner), Fragment.lit("::int4, "), Fragment.encode(Flag.pgType, unsaved.folderflag), Fragment.lit("::bool, "), Fragment.encode(PgTypes.text, unsaved.filename), Fragment.lit(", "), Fragment.encode(PgTypes.text.nullable(), unsaved.fileextension), Fragment.lit(", "), Fragment.encode(PgTypes.bpchar, unsaved.revision), Fragment.lit("::bpchar, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.changenumber), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int2, unsaved.status), Fragment.lit("::int2, "), Fragment.encode(PgTypes.text.nullable(), unsaved.documentsummary), Fragment.lit(", "), Fragment.encode(PgTypes.bytea.nullable(), unsaved.document), Fragment.lit("::bytea, "), Fragment.encode(PgTypes.uuid, unsaved.rowguid), Fragment.lit("::uuid, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp, "), Fragment.encode(DocumentId.pgType, unsaved.documentnode), Fragment.lit(")\nRETURNING \"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\"\n"))
    .updateReturning(DocumentRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: DocumentRowUnsaved,
    c: Connection
  ): DocumentRow {
    val columns: ArrayList<Fragment> = ArrayList()
    val values: ArrayList<Fragment> = ArrayList()
    columns.add(Fragment.lit("\"title\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.text, unsaved.title), Fragment.lit("")))
    columns.add(Fragment.lit("\"owner\""))
    values.add(Fragment.interpolate(Fragment.encode(BusinessentityId.pgType, unsaved.owner), Fragment.lit("::int4")))
    columns.add(Fragment.lit("\"filename\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.text, unsaved.filename), Fragment.lit("")))
    columns.add(Fragment.lit("\"fileextension\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.text.nullable(), unsaved.fileextension), Fragment.lit("")))
    columns.add(Fragment.lit("\"revision\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.bpchar, unsaved.revision), Fragment.lit("::bpchar")))
    columns.add(Fragment.lit("\"status\""))
    values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int2, unsaved.status), Fragment.lit("::int2")))
    columns.add(Fragment.lit("\"documentsummary\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.text.nullable(), unsaved.documentsummary), Fragment.lit("")))
    columns.add(Fragment.lit("\"document\""))
    values.add(Fragment.interpolate(Fragment.encode(PgTypes.bytea.nullable(), unsaved.document), Fragment.lit("::bytea")))
    unsaved.folderflag.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"folderflag\""))
      values.add(Fragment.interpolate(Fragment.encode(Flag.pgType, value), Fragment.lit("::bool"))) }
    );
    unsaved.changenumber.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"changenumber\""))
      values.add(Fragment.interpolate(Fragment.encode(KotlinDbTypes.PgTypes.int4, value), Fragment.lit("::int4"))) }
    );
    unsaved.rowguid.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"rowguid\""))
      values.add(Fragment.interpolate(Fragment.encode(PgTypes.uuid, value), Fragment.lit("::uuid"))) }
    );
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(Fragment.interpolate(Fragment.encode(PgTypes.timestamp, value), Fragment.lit("::timestamp"))) }
    );
    unsaved.documentnode.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"documentnode\""))
      values.add(Fragment.interpolate(Fragment.encode(DocumentId.pgType, value), Fragment.lit(""))) }
    );
    val q: Fragment = Fragment.interpolate(Fragment.lit("insert into \"production\".\"document\"("), Fragment.comma(columns.toMutableList()), Fragment.lit(")\nvalues ("), Fragment.comma(values.toMutableList()), Fragment.lit(")\nRETURNING \"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\"\n"))
    return q.updateReturning(DocumentRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: Iterator<DocumentRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"production\".\"document\"(\"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\") FROM STDIN", batchSize, unsaved, c, DocumentRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: Iterator<DocumentRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked("COPY \"production\".\"document\"(\"title\", \"owner\", \"filename\", \"fileextension\", \"revision\", \"status\", \"documentsummary\", \"document\", \"folderflag\", \"changenumber\", \"rowguid\", \"modifieddate\", \"documentnode\") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')", batchSize, unsaved, c, DocumentRowUnsaved.pgText)

  override fun select(): SelectBuilder<DocumentFields, DocumentRow> = SelectBuilder.of("\"production\".\"document\"", DocumentFields.structure, DocumentRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<DocumentRow> = Fragment.interpolate(Fragment.lit("select \"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\"\nfrom \"production\".\"document\"\n")).query(DocumentRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    documentnode: DocumentId,
    c: Connection
  ): DocumentRow? = Fragment.interpolate(Fragment.lit("select \"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\"\nfrom \"production\".\"document\"\nwhere \"documentnode\" = "), Fragment.encode(DocumentId.pgType, documentnode), Fragment.lit("")).query(DocumentRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): List<DocumentRow> = Fragment.interpolate(Fragment.lit("select \"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\"\nfrom \"production\".\"document\"\nwhere \"documentnode\" = ANY("), Fragment.encode(DocumentId.pgTypeArray, documentnodes), Fragment.lit(")")).query(DocumentRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): Map<DocumentId, DocumentRow> {
    val ret: MutableMap<DocumentId, DocumentRow> = mutableMapOf<DocumentId, DocumentRow>()
    selectByIds(documentnodes, c).forEach({ row -> ret.put(row.documentnode, row) })
    return ret.toMap()
  }

  override fun selectByUniqueRowguid(
    rowguid: UUID,
    c: Connection
  ): DocumentRow? = Fragment.interpolate(Fragment.lit("select \"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\"\nfrom \"production\".\"document\"\nwhere \"rowguid\" = "), Fragment.encode(PgTypes.uuid, rowguid), Fragment.lit("\n")).query(DocumentRow._rowParser.first()).runUnchecked(c)

  override fun update(): UpdateBuilder<DocumentFields, DocumentRow> = UpdateBuilder.of("\"production\".\"document\"", DocumentFields.structure, DocumentRow._rowParser, Dialect.POSTGRESQL)

  override fun update(
    row: DocumentRow,
    c: Connection
  ): Boolean {
    val documentnode: DocumentId = row.documentnode
    return Fragment.interpolate(Fragment.lit("update \"production\".\"document\"\nset \"title\" = "), Fragment.encode(PgTypes.text, row.title), Fragment.lit(",\n\"owner\" = "), Fragment.encode(BusinessentityId.pgType, row.owner), Fragment.lit("::int4,\n\"folderflag\" = "), Fragment.encode(Flag.pgType, row.folderflag), Fragment.lit("::bool,\n\"filename\" = "), Fragment.encode(PgTypes.text, row.filename), Fragment.lit(",\n\"fileextension\" = "), Fragment.encode(PgTypes.text.nullable(), row.fileextension), Fragment.lit(",\n\"revision\" = "), Fragment.encode(PgTypes.bpchar, row.revision), Fragment.lit("::bpchar,\n\"changenumber\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int4, row.changenumber), Fragment.lit("::int4,\n\"status\" = "), Fragment.encode(KotlinDbTypes.PgTypes.int2, row.status), Fragment.lit("::int2,\n\"documentsummary\" = "), Fragment.encode(PgTypes.text.nullable(), row.documentsummary), Fragment.lit(",\n\"document\" = "), Fragment.encode(PgTypes.bytea.nullable(), row.document), Fragment.lit("::bytea,\n\"rowguid\" = "), Fragment.encode(PgTypes.uuid, row.rowguid), Fragment.lit("::uuid,\n\"modifieddate\" = "), Fragment.encode(PgTypes.timestamp, row.modifieddate), Fragment.lit("::timestamp\nwhere \"documentnode\" = "), Fragment.encode(DocumentId.pgType, documentnode), Fragment.lit("")).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: DocumentRow,
    c: Connection
  ): DocumentRow = Fragment.interpolate(Fragment.lit("insert into \"production\".\"document\"(\"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\")\nvalues ("), Fragment.encode(PgTypes.text, unsaved.title), Fragment.lit(", "), Fragment.encode(BusinessentityId.pgType, unsaved.owner), Fragment.lit("::int4, "), Fragment.encode(Flag.pgType, unsaved.folderflag), Fragment.lit("::bool, "), Fragment.encode(PgTypes.text, unsaved.filename), Fragment.lit(", "), Fragment.encode(PgTypes.text.nullable(), unsaved.fileextension), Fragment.lit(", "), Fragment.encode(PgTypes.bpchar, unsaved.revision), Fragment.lit("::bpchar, "), Fragment.encode(KotlinDbTypes.PgTypes.int4, unsaved.changenumber), Fragment.lit("::int4, "), Fragment.encode(KotlinDbTypes.PgTypes.int2, unsaved.status), Fragment.lit("::int2, "), Fragment.encode(PgTypes.text.nullable(), unsaved.documentsummary), Fragment.lit(", "), Fragment.encode(PgTypes.bytea.nullable(), unsaved.document), Fragment.lit("::bytea, "), Fragment.encode(PgTypes.uuid, unsaved.rowguid), Fragment.lit("::uuid, "), Fragment.encode(PgTypes.timestamp, unsaved.modifieddate), Fragment.lit("::timestamp, "), Fragment.encode(DocumentId.pgType, unsaved.documentnode), Fragment.lit(")\non conflict (\"documentnode\")\ndo update set\n  \"title\" = EXCLUDED.\"title\",\n\"owner\" = EXCLUDED.\"owner\",\n\"folderflag\" = EXCLUDED.\"folderflag\",\n\"filename\" = EXCLUDED.\"filename\",\n\"fileextension\" = EXCLUDED.\"fileextension\",\n\"revision\" = EXCLUDED.\"revision\",\n\"changenumber\" = EXCLUDED.\"changenumber\",\n\"status\" = EXCLUDED.\"status\",\n\"documentsummary\" = EXCLUDED.\"documentsummary\",\n\"document\" = EXCLUDED.\"document\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\""))
    .updateReturning(DocumentRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: Iterator<DocumentRow>,
    c: Connection
  ): List<DocumentRow> = Fragment.interpolate(Fragment.lit("insert into \"production\".\"document\"(\"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\")\nvalues (?, ?::int4, ?::bool, ?, ?, ?::bpchar, ?::int4, ?::int2, ?, ?::bytea, ?::uuid, ?::timestamp, ?)\non conflict (\"documentnode\")\ndo update set\n  \"title\" = EXCLUDED.\"title\",\n\"owner\" = EXCLUDED.\"owner\",\n\"folderflag\" = EXCLUDED.\"folderflag\",\n\"filename\" = EXCLUDED.\"filename\",\n\"fileextension\" = EXCLUDED.\"fileextension\",\n\"revision\" = EXCLUDED.\"revision\",\n\"changenumber\" = EXCLUDED.\"changenumber\",\n\"status\" = EXCLUDED.\"status\",\n\"documentsummary\" = EXCLUDED.\"documentsummary\",\n\"document\" = EXCLUDED.\"document\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\nreturning \"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\""))
    .updateManyReturning(DocumentRow._rowParser, unsaved)
  .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: Iterator<DocumentRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    Fragment.interpolate(Fragment.lit("create temporary table document_TEMP (like \"production\".\"document\") on commit drop")).update().runUnchecked(c)
    streamingInsert.insertUnchecked("copy document_TEMP(\"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\") from stdin", batchSize, unsaved, c, DocumentRow.pgText)
    return Fragment.interpolate(Fragment.lit("insert into \"production\".\"document\"(\"title\", \"owner\", \"folderflag\", \"filename\", \"fileextension\", \"revision\", \"changenumber\", \"status\", \"documentsummary\", \"document\", \"rowguid\", \"modifieddate\", \"documentnode\")\nselect * from document_TEMP\non conflict (\"documentnode\")\ndo update set\n  \"title\" = EXCLUDED.\"title\",\n\"owner\" = EXCLUDED.\"owner\",\n\"folderflag\" = EXCLUDED.\"folderflag\",\n\"filename\" = EXCLUDED.\"filename\",\n\"fileextension\" = EXCLUDED.\"fileextension\",\n\"revision\" = EXCLUDED.\"revision\",\n\"changenumber\" = EXCLUDED.\"changenumber\",\n\"status\" = EXCLUDED.\"status\",\n\"documentsummary\" = EXCLUDED.\"documentsummary\",\n\"document\" = EXCLUDED.\"document\",\n\"rowguid\" = EXCLUDED.\"rowguid\",\n\"modifieddate\" = EXCLUDED.\"modifieddate\"\n;\ndrop table document_TEMP;")).update().runUnchecked(c)
  }
}