/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.document

import adventureworks.customtypes.TypoBytea
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.customtypes.TypoShort
import adventureworks.customtypes.TypoUUID
import adventureworks.person.businessentity.BusinessentityId
import adventureworks.public.Flag
import java.sql.Connection
import java.util.ArrayList
import java.util.Optional
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.collections.MutableIterator
import kotlin.collections.MutableMap
import typo.dsl.DeleteBuilder
import typo.dsl.Dialect
import typo.dsl.SelectBuilder
import typo.dsl.UpdateBuilder
import typo.runtime.Fragment
import typo.runtime.Fragment.Literal
import typo.runtime.PgTypes
import typo.runtime.streamingInsert
import typo.runtime.Fragment.interpolate
import typo.runtime.internal.stringInterpolator.str

class DocumentRepoImpl() : DocumentRepo {
  override fun delete(): DeleteBuilder<DocumentFields, DocumentRow> = DeleteBuilder.of("\"production\".\"document\"", DocumentFields.structure, Dialect.POSTGRESQL)

  override fun deleteById(
    documentnode: DocumentId,
    c: Connection
  ): Boolean = interpolate(
    typo.runtime.Fragment.lit("""
    delete from "production"."document" where "documentnode" = 
    """.trimMargin()),
    DocumentId.pgType.encode(documentnode),
    typo.runtime.Fragment.lit("")
  ).update().runUnchecked(c) > 0

  override fun deleteByIds(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): Int = interpolate(
             typo.runtime.Fragment.lit("""
               delete
               from "production"."document"
               where "documentnode" = ANY(""".trimMargin()),
             DocumentId.pgTypeArray.encode(documentnodes),
             typo.runtime.Fragment.lit(")")
           )
    .update()
    .runUnchecked(c)

  override fun insert(
    unsaved: DocumentRow,
    c: Connection
  ): DocumentRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode")
      values (""".trimMargin()),
    PgTypes.text.encode(unsaved.title),
    typo.runtime.Fragment.lit(", "),
    BusinessentityId.pgType.encode(unsaved.owner),
    typo.runtime.Fragment.lit("::int4, "),
    Flag.pgType.encode(unsaved.folderflag),
    typo.runtime.Fragment.lit("::bool, "),
    PgTypes.text.encode(unsaved.filename),
    typo.runtime.Fragment.lit(", "),
    PgTypes.text.opt().encode(unsaved.fileextension),
    typo.runtime.Fragment.lit(", "),
    PgTypes.text.encode(unsaved.revision),
    typo.runtime.Fragment.lit("::bpchar, "),
    PgTypes.int4.encode(unsaved.changenumber),
    typo.runtime.Fragment.lit("::int4, "),
    TypoShort.pgType.encode(unsaved.status),
    typo.runtime.Fragment.lit("::int2, "),
    PgTypes.text.opt().encode(unsaved.documentsummary),
    typo.runtime.Fragment.lit(", "),
    TypoBytea.pgType.opt().encode(unsaved.document),
    typo.runtime.Fragment.lit("::bytea, "),
    TypoUUID.pgType.encode(unsaved.rowguid),
    typo.runtime.Fragment.lit("::uuid, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("::timestamp, "),
    DocumentId.pgType.encode(unsaved.documentnode),
    typo.runtime.Fragment.lit("""
      )
      returning "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
    """.trimMargin())
  )
    .updateReturning(DocumentRow._rowParser.exactlyOne()).runUnchecked(c)

  override fun insert(
    unsaved: DocumentRowUnsaved,
    c: Connection
  ): DocumentRow {
    val columns: ArrayList<Literal> = ArrayList<Literal>()
    val values: ArrayList<Fragment> = ArrayList<Fragment>()
    columns.add(Fragment.lit("\"title\""))
    values.add(interpolate(
      PgTypes.text.encode(unsaved.title),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("\"owner\""))
    values.add(interpolate(
      BusinessentityId.pgType.encode(unsaved.owner),
      typo.runtime.Fragment.lit("::int4")
    ))
    columns.add(Fragment.lit("\"filename\""))
    values.add(interpolate(
      PgTypes.text.encode(unsaved.filename),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("\"fileextension\""))
    values.add(interpolate(
      PgTypes.text.opt().encode(unsaved.fileextension),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("\"revision\""))
    values.add(interpolate(
      PgTypes.text.encode(unsaved.revision),
      typo.runtime.Fragment.lit("::bpchar")
    ))
    columns.add(Fragment.lit("\"status\""))
    values.add(interpolate(
      TypoShort.pgType.encode(unsaved.status),
      typo.runtime.Fragment.lit("::int2")
    ))
    columns.add(Fragment.lit("\"documentsummary\""))
    values.add(interpolate(
      PgTypes.text.opt().encode(unsaved.documentsummary),
      typo.runtime.Fragment.lit("""
      """.trimMargin())
    ))
    columns.add(Fragment.lit("\"document\""))
    values.add(interpolate(
      TypoBytea.pgType.opt().encode(unsaved.document),
      typo.runtime.Fragment.lit("::bytea")
    ))
    unsaved.folderflag.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"folderflag\""))
      values.add(interpolate(
        Flag.pgType.encode(value),
        typo.runtime.Fragment.lit("::bool")
      )) }
    );
    unsaved.changenumber.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"changenumber\""))
      values.add(interpolate(
        PgTypes.int4.encode(value),
        typo.runtime.Fragment.lit("::int4")
      )) }
    );
    unsaved.rowguid.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"rowguid\""))
      values.add(interpolate(
        TypoUUID.pgType.encode(value),
        typo.runtime.Fragment.lit("::uuid")
      )) }
    );
    unsaved.modifieddate.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"modifieddate\""))
      values.add(interpolate(
        TypoLocalDateTime.pgType.encode(value),
        typo.runtime.Fragment.lit("::timestamp")
      )) }
    );
    unsaved.documentnode.visit(
      {  },
      { value -> columns.add(Fragment.lit("\"documentnode\""))
      values.add(interpolate(
        DocumentId.pgType.encode(value),
        typo.runtime.Fragment.lit("""
        """.trimMargin())
      )) }
    );
    val q: Fragment = interpolate(
      typo.runtime.Fragment.lit("""
      insert into "production"."document"(
      """.trimMargin()),
      Fragment.comma(columns),
      typo.runtime.Fragment.lit("""
        )
        values (""".trimMargin()),
      Fragment.comma(values),
      typo.runtime.Fragment.lit("""
        )
        returning "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
      """.trimMargin())
    )
    return q.updateReturning(DocumentRow._rowParser.exactlyOne()).runUnchecked(c)
  }

  override fun insertStreaming(
    unsaved: MutableIterator<DocumentRow>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode") FROM STDIN
  """.trimMargin()), batchSize, unsaved, c, DocumentRow.pgText)

  /** NOTE: this functionality requires PostgreSQL 16 or later! */
  override fun insertUnsavedStreaming(
    unsaved: MutableIterator<DocumentRowUnsaved>,
    batchSize: Int,
    c: Connection
  ): Long = streamingInsert.insertUnchecked(str("""
  COPY "production"."document"("title", "owner", "filename", "fileextension", "revision", "status", "documentsummary", "document", "folderflag", "changenumber", "rowguid", "modifieddate", "documentnode") FROM STDIN (DEFAULT '__DEFAULT_VALUE__')
  """.trimMargin()), batchSize, unsaved, c, DocumentRowUnsaved.pgText)

  override fun select(): SelectBuilder<DocumentFields, DocumentRow> = SelectBuilder.of("\"production\".\"document\"", DocumentFields.structure, DocumentRow._rowParser, Dialect.POSTGRESQL)

  override fun selectAll(c: Connection): List<DocumentRow> = interpolate(typo.runtime.Fragment.lit("""
    select "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
    from "production"."document"
  """.trimMargin())).query(DocumentRow._rowParser.all()).runUnchecked(c)

  override fun selectById(
    documentnode: DocumentId,
    c: Connection
  ): Optional<DocumentRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
      from "production"."document"
      where "documentnode" = """.trimMargin()),
    DocumentId.pgType.encode(documentnode),
    typo.runtime.Fragment.lit("")
  ).query(DocumentRow._rowParser.first()).runUnchecked(c)

  override fun selectByIds(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): List<DocumentRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
      from "production"."document"
      where "documentnode" = ANY(""".trimMargin()),
    DocumentId.pgTypeArray.encode(documentnodes),
    typo.runtime.Fragment.lit(")")
  ).query(DocumentRow._rowParser.all()).runUnchecked(c)

  override fun selectByIdsTracked(
    documentnodes: Array<DocumentId>,
    c: Connection
  ): Map<DocumentId, DocumentRow> {
    val ret: MutableMap<DocumentId, DocumentRow> = mutableMapOf<DocumentId, DocumentRow>()
    selectByIds(documentnodes, c).forEach({ row -> ret.put(row.documentnode, row) })
    return ret
  }

  override fun selectByUniqueRowguid(
    rowguid: TypoUUID,
    c: Connection
  ): Optional<DocumentRow> = interpolate(
    typo.runtime.Fragment.lit("""
      select "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"
      from "production"."document"
      where "rowguid" = """.trimMargin()),
    TypoUUID.pgType.encode(rowguid),
    typo.runtime.Fragment.lit("""


    """.trimMargin())
  ).query(DocumentRow._rowParser.first()).runUnchecked(c)

  override fun update(): UpdateBuilder<DocumentFields, DocumentRow> = UpdateBuilder.of("\"production\".\"document\"", DocumentFields.structure, DocumentRow._rowParser.all(), Dialect.POSTGRESQL)

  override fun update(
    row: DocumentRow,
    c: Connection
  ): Boolean {
    val documentnode: DocumentId = row.documentnode
    return interpolate(
      typo.runtime.Fragment.lit("""
        update "production"."document"
        set "title" = """.trimMargin()),
      PgTypes.text.encode(row.title),
      typo.runtime.Fragment.lit("""
        ,
        "owner" = """.trimMargin()),
      BusinessentityId.pgType.encode(row.owner),
      typo.runtime.Fragment.lit("""
        ::int4,
        "folderflag" = """.trimMargin()),
      Flag.pgType.encode(row.folderflag),
      typo.runtime.Fragment.lit("""
        ::bool,
        "filename" = """.trimMargin()),
      PgTypes.text.encode(row.filename),
      typo.runtime.Fragment.lit("""
        ,
        "fileextension" = """.trimMargin()),
      PgTypes.text.opt().encode(row.fileextension),
      typo.runtime.Fragment.lit("""
        ,
        "revision" = """.trimMargin()),
      PgTypes.text.encode(row.revision),
      typo.runtime.Fragment.lit("""
        ::bpchar,
        "changenumber" = """.trimMargin()),
      PgTypes.int4.encode(row.changenumber),
      typo.runtime.Fragment.lit("""
        ::int4,
        "status" = """.trimMargin()),
      TypoShort.pgType.encode(row.status),
      typo.runtime.Fragment.lit("""
        ::int2,
        "documentsummary" = """.trimMargin()),
      PgTypes.text.opt().encode(row.documentsummary),
      typo.runtime.Fragment.lit("""
        ,
        "document" = """.trimMargin()),
      TypoBytea.pgType.opt().encode(row.document),
      typo.runtime.Fragment.lit("""
        ::bytea,
        "rowguid" = """.trimMargin()),
      TypoUUID.pgType.encode(row.rowguid),
      typo.runtime.Fragment.lit("""
        ::uuid,
        "modifieddate" = """.trimMargin()),
      TypoLocalDateTime.pgType.encode(row.modifieddate),
      typo.runtime.Fragment.lit("""
        ::timestamp
        where "documentnode" = """.trimMargin()),
      DocumentId.pgType.encode(documentnode),
      typo.runtime.Fragment.lit("")
    ).update().runUnchecked(c) > 0
  }

  override fun upsert(
    unsaved: DocumentRow,
    c: Connection
  ): DocumentRow = interpolate(
    typo.runtime.Fragment.lit("""
      insert into "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode")
      values (""".trimMargin()),
    PgTypes.text.encode(unsaved.title),
    typo.runtime.Fragment.lit(", "),
    BusinessentityId.pgType.encode(unsaved.owner),
    typo.runtime.Fragment.lit("::int4, "),
    Flag.pgType.encode(unsaved.folderflag),
    typo.runtime.Fragment.lit("::bool, "),
    PgTypes.text.encode(unsaved.filename),
    typo.runtime.Fragment.lit(", "),
    PgTypes.text.opt().encode(unsaved.fileextension),
    typo.runtime.Fragment.lit(", "),
    PgTypes.text.encode(unsaved.revision),
    typo.runtime.Fragment.lit("::bpchar, "),
    PgTypes.int4.encode(unsaved.changenumber),
    typo.runtime.Fragment.lit("::int4, "),
    TypoShort.pgType.encode(unsaved.status),
    typo.runtime.Fragment.lit("::int2, "),
    PgTypes.text.opt().encode(unsaved.documentsummary),
    typo.runtime.Fragment.lit(", "),
    TypoBytea.pgType.opt().encode(unsaved.document),
    typo.runtime.Fragment.lit("::bytea, "),
    TypoUUID.pgType.encode(unsaved.rowguid),
    typo.runtime.Fragment.lit("::uuid, "),
    TypoLocalDateTime.pgType.encode(unsaved.modifieddate),
    typo.runtime.Fragment.lit("::timestamp, "),
    DocumentId.pgType.encode(unsaved.documentnode),
    typo.runtime.Fragment.lit("""
      )
      on conflict ("documentnode")
      do update set
        "title" = EXCLUDED."title",
      "owner" = EXCLUDED."owner",
      "folderflag" = EXCLUDED."folderflag",
      "filename" = EXCLUDED."filename",
      "fileextension" = EXCLUDED."fileextension",
      "revision" = EXCLUDED."revision",
      "changenumber" = EXCLUDED."changenumber",
      "status" = EXCLUDED."status",
      "documentsummary" = EXCLUDED."documentsummary",
      "document" = EXCLUDED."document",
      "rowguid" = EXCLUDED."rowguid",
      "modifieddate" = EXCLUDED."modifieddate"
      returning "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"""".trimMargin())
  )
    .updateReturning(DocumentRow._rowParser.exactlyOne())
    .runUnchecked(c)

  override fun upsertBatch(
    unsaved: MutableIterator<DocumentRow>,
    c: Connection
  ): List<DocumentRow> = interpolate(typo.runtime.Fragment.lit("""
                           insert into "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode")
                           values (?, ?::int4, ?::bool, ?, ?, ?::bpchar, ?::int4, ?::int2, ?, ?::bytea, ?::uuid, ?::timestamp, ?)
                           on conflict ("documentnode")
                           do update set
                             "title" = EXCLUDED."title",
                           "owner" = EXCLUDED."owner",
                           "folderflag" = EXCLUDED."folderflag",
                           "filename" = EXCLUDED."filename",
                           "fileextension" = EXCLUDED."fileextension",
                           "revision" = EXCLUDED."revision",
                           "changenumber" = EXCLUDED."changenumber",
                           "status" = EXCLUDED."status",
                           "documentsummary" = EXCLUDED."documentsummary",
                           "document" = EXCLUDED."document",
                           "rowguid" = EXCLUDED."rowguid",
                           "modifieddate" = EXCLUDED."modifieddate"
                           returning "title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate"::text, "documentnode"""".trimMargin()))
    .updateManyReturning(DocumentRow._rowParser, unsaved)
    .runUnchecked(c)

  /** NOTE: this functionality is not safe if you use auto-commit mode! it runs 3 SQL statements */
  override fun upsertStreaming(
    unsaved: MutableIterator<DocumentRow>,
    batchSize: Int,
    c: Connection
  ): Int {
    interpolate(typo.runtime.Fragment.lit("""
    create temporary table document_TEMP (like "production"."document") on commit drop
    """.trimMargin())).update().runUnchecked(c)
    streamingInsert.insertUnchecked(str("""
    copy document_TEMP("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode") from stdin
    """.trimMargin()), batchSize, unsaved, c, DocumentRow.pgText)
    return interpolate(typo.runtime.Fragment.lit("""
      insert into "production"."document"("title", "owner", "folderflag", "filename", "fileextension", "revision", "changenumber", "status", "documentsummary", "document", "rowguid", "modifieddate", "documentnode")
      select * from document_TEMP
      on conflict ("documentnode")
      do update set
        "title" = EXCLUDED."title",
      "owner" = EXCLUDED."owner",
      "folderflag" = EXCLUDED."folderflag",
      "filename" = EXCLUDED."filename",
      "fileextension" = EXCLUDED."fileextension",
      "revision" = EXCLUDED."revision",
      "changenumber" = EXCLUDED."changenumber",
      "status" = EXCLUDED."status",
      "documentsummary" = EXCLUDED."documentsummary",
      "document" = EXCLUDED."document",
      "rowguid" = EXCLUDED."rowguid",
      "modifieddate" = EXCLUDED."modifieddate"
      ;
      drop table document_TEMP;""".trimMargin())).update().runUnchecked(c)
  }
}