/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.product

import adventureworks.customtypes.Defaulted
import adventureworks.production.productmodel.ProductmodelId
import adventureworks.production.productsubcategory.ProductsubcategoryId
import adventureworks.production.unitmeasure.UnitmeasureId
import adventureworks.public.Flag
import adventureworks.public.Name
import java.math.BigDecimal
import java.time.LocalDateTime
import java.util.UUID
import typo.kotlindsl.KotlinDbTypes
import typo.kotlindsl.RowParser
import typo.kotlindsl.RowParsers
import typo.kotlindsl.nullable
import typo.runtime.PgText
import typo.runtime.PgTypes

/** Table: production.product
  * Products sold or used in the manfacturing of sold products.
  * Primary key: productid
  */
data class ProductRow(
  /** Primary key for Product records.
    * Default: nextval('production.product_productid_seq'::regclass)
    */
  val productid: ProductId,
  /** Name of the product. */
  val name: Name,
  /** Unique product identification number. */
  val productnumber: String,
  /** 0 = Product is purchased, 1 = Product is manufactured in-house.
    * Default: true
    */
  val makeflag: Flag,
  /** 0 = Product is not a salable item. 1 = Product is salable.
    * Default: true
    */
  val finishedgoodsflag: Flag,
  /** Product color. */
  val color: /* max 15 chars */ String?,
  /** Minimum inventory quantity.
    * Constraint CK_Product_SafetyStockLevel affecting columns safetystocklevel: ((safetystocklevel > 0))
    */
  val safetystocklevel: Short,
  /** Inventory level that triggers a purchase order or work order.
    * Constraint CK_Product_ReorderPoint affecting columns reorderpoint: ((reorderpoint > 0))
    */
  val reorderpoint: Short,
  /** Standard cost of the product.
    * Constraint CK_Product_StandardCost affecting columns standardcost: ((standardcost >= 0.00))
    */
  val standardcost: BigDecimal,
  /** Selling price.
    * Constraint CK_Product_ListPrice affecting columns listprice: ((listprice >= 0.00))
    */
  val listprice: BigDecimal,
  /** Product size. */
  val size: /* max 5 chars */ String?,
  /** Unit of measure for Size column.
    * Points to [adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]
    */
  val sizeunitmeasurecode: UnitmeasureId?,
  /** Unit of measure for Weight column.
    * Points to [adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]
    */
  val weightunitmeasurecode: UnitmeasureId?,
  /** Product weight.
    * Constraint CK_Product_Weight affecting columns weight: ((weight > 0.00))
    */
  val weight: BigDecimal?,
  /** Number of days required to manufacture the product.
    * Constraint CK_Product_DaysToManufacture affecting columns daystomanufacture: ((daystomanufacture >= 0))
    */
  val daystomanufacture: Int,
  /** R = Road, M = Mountain, T = Touring, S = Standard
    * Constraint CK_Product_ProductLine affecting columns productline: (((upper((productline)::text) = ANY (ARRAY['S'::text, 'T'::text, 'M'::text, 'R'::text])) OR (productline IS NULL)))
    */
  val productline: /* bpchar, max 2 chars */ String?,
  /** H = High, M = Medium, L = Low
    * Constraint CK_Product_Class affecting columns class: (((upper((class)::text) = ANY (ARRAY['L'::text, 'M'::text, 'H'::text])) OR (class IS NULL)))
    */
  val `class`: /* bpchar, max 2 chars */ String?,
  /** W = Womens, M = Mens, U = Universal
    * Constraint CK_Product_Style affecting columns style: (((upper((style)::text) = ANY (ARRAY['W'::text, 'M'::text, 'U'::text])) OR (style IS NULL)))
    */
  val style: /* bpchar, max 2 chars */ String?,
  /** Product is a member of this product subcategory. Foreign key to ProductSubCategory.ProductSubCategoryID.
    * Points to [adventureworks.production.productsubcategory.ProductsubcategoryRow.productsubcategoryid]
    */
  val productsubcategoryid: ProductsubcategoryId?,
  /** Product is a member of this product model. Foreign key to ProductModel.ProductModelID.
    * Points to [adventureworks.production.productmodel.ProductmodelRow.productmodelid]
    */
  val productmodelid: ProductmodelId?,
  /** Date the product was available for sale.
    * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate: (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
    */
  val sellstartdate: LocalDateTime,
  /** Date the product was no longer available for sale.
    * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate: (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
    */
  val sellenddate: LocalDateTime?,
  /** Date the product was discontinued. */
  val discontinueddate: LocalDateTime?,
  /** Default: uuid_generate_v1() */
  val rowguid: UUID,
  /** Default: now() */
  val modifieddate: LocalDateTime
) {
  fun id(): ProductId = productid

  fun toUnsavedRow(
    productid: Defaulted<ProductId>,
    makeflag: Defaulted<Flag>,
    finishedgoodsflag: Defaulted<Flag>,
    rowguid: Defaulted<UUID>,
    modifieddate: Defaulted<LocalDateTime>
  ): ProductRowUnsaved = ProductRowUnsaved(name, productnumber, color, safetystocklevel, reorderpoint, standardcost, listprice, size, sizeunitmeasurecode, weightunitmeasurecode, weight, daystomanufacture, productline, `class`, style, productsubcategoryid, productmodelid, sellstartdate, sellenddate, discontinueddate, productid, makeflag, finishedgoodsflag, rowguid, modifieddate)

  companion object {
    val _rowParser: RowParser<ProductRow> = RowParsers.of(ProductId.pgType, Name.pgType, PgTypes.text, Flag.pgType, Flag.pgType, PgTypes.text.nullable(), KotlinDbTypes.PgTypes.int2, KotlinDbTypes.PgTypes.int2, PgTypes.numeric, PgTypes.numeric, PgTypes.text.nullable(), UnitmeasureId.pgType.nullable(), UnitmeasureId.pgType.nullable(), PgTypes.numeric.nullable(), KotlinDbTypes.PgTypes.int4, PgTypes.bpchar.nullable(), PgTypes.bpchar.nullable(), PgTypes.bpchar.nullable(), ProductsubcategoryId.pgType.nullable(), ProductmodelId.pgType.nullable(), PgTypes.timestamp, PgTypes.timestamp.nullable(), PgTypes.timestamp.nullable(), PgTypes.uuid, PgTypes.timestamp, { t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24 -> ProductRow(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24) }, { row -> arrayOf<Any?>(row.productid, row.name, row.productnumber, row.makeflag, row.finishedgoodsflag, row.color, row.safetystocklevel, row.reorderpoint, row.standardcost, row.listprice, row.size, row.sizeunitmeasurecode, row.weightunitmeasurecode, row.weight, row.daystomanufacture, row.productline, row.`class`, row.style, row.productsubcategoryid, row.productmodelid, row.sellstartdate, row.sellenddate, row.discontinueddate, row.rowguid, row.modifieddate) })

    val pgText: PgText<ProductRow> =
      PgText.from(_rowParser.underlying)
  }
}