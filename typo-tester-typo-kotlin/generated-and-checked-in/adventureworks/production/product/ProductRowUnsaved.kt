/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.product

import adventureworks.customtypes.Defaulted
import adventureworks.customtypes.Defaulted.UseDefault
import adventureworks.customtypes.TypoLocalDateTime
import adventureworks.customtypes.TypoShort
import adventureworks.customtypes.TypoUUID
import adventureworks.production.productmodel.ProductmodelId
import adventureworks.production.productsubcategory.ProductsubcategoryId
import adventureworks.production.unitmeasure.UnitmeasureId
import adventureworks.public.Flag
import adventureworks.public.Name
import java.math.BigDecimal
import java.util.Optional
import typo.runtime.PgText
import typo.runtime.PgTypes

/** This class corresponds to a row in table `production.product` which has not been persisted yet */
data class ProductRowUnsaved(
  /** Name of the product. */
  val name: Name,
  /** Unique product identification number. */
  val productnumber: /* max 25 chars */ String,
  /** Product color. */
  val color: Optional</* max 15 chars */ String> = Optional.empty(),
  /** Minimum inventory quantity.
    * Constraint CK_Product_SafetyStockLevel affecting columns safetystocklevel:  ((safetystocklevel > 0))
    */
  val safetystocklevel: TypoShort,
  /** Inventory level that triggers a purchase order or work order.
    * Constraint CK_Product_ReorderPoint affecting columns reorderpoint:  ((reorderpoint > 0))
    */
  val reorderpoint: TypoShort,
  /** Standard cost of the product.
    * Constraint CK_Product_StandardCost affecting columns standardcost:  ((standardcost >= 0.00))
    */
  val standardcost: BigDecimal,
  /** Selling price.
    * Constraint CK_Product_ListPrice affecting columns listprice:  ((listprice >= 0.00))
    */
  val listprice: BigDecimal,
  /** Product size. */
  val size: Optional</* max 5 chars */ String> = Optional.empty(),
  /** Unit of measure for Size column.
    * Points to [adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]
    */
  val sizeunitmeasurecode: Optional<UnitmeasureId> = Optional.empty(),
  /** Unit of measure for Weight column.
    * Points to [adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]
    */
  val weightunitmeasurecode: Optional<UnitmeasureId> = Optional.empty(),
  /** Product weight.
    * Constraint CK_Product_Weight affecting columns weight:  ((weight > 0.00))
    */
  val weight: Optional<BigDecimal> = Optional.empty(),
  /** Number of days required to manufacture the product.
    * Constraint CK_Product_DaysToManufacture affecting columns daystomanufacture:  ((daystomanufacture >= 0))
    */
  val daystomanufacture: Int,
  /** R = Road, M = Mountain, T = Touring, S = Standard
    * Constraint CK_Product_ProductLine affecting columns productline:  (((upper((productline)::text) = ANY (ARRAY['S'::text, 'T'::text, 'M'::text, 'R'::text])) OR (productline IS NULL)))
    */
  val productline: Optional</* bpchar, max 2 chars */ String> = Optional.empty(),
  /** H = High, M = Medium, L = Low
    * Constraint CK_Product_Class affecting columns class:  (((upper((class)::text) = ANY (ARRAY['L'::text, 'M'::text, 'H'::text])) OR (class IS NULL)))
    */
  val `class`: Optional</* bpchar, max 2 chars */ String> = Optional.empty(),
  /** W = Womens, M = Mens, U = Universal
    * Constraint CK_Product_Style affecting columns style:  (((upper((style)::text) = ANY (ARRAY['W'::text, 'M'::text, 'U'::text])) OR (style IS NULL)))
    */
  val style: Optional</* bpchar, max 2 chars */ String> = Optional.empty(),
  /** Product is a member of this product subcategory. Foreign key to ProductSubCategory.ProductSubCategoryID.
    * Points to [adventureworks.production.productsubcategory.ProductsubcategoryRow.productsubcategoryid]
    */
  val productsubcategoryid: Optional<ProductsubcategoryId> = Optional.empty(),
  /** Product is a member of this product model. Foreign key to ProductModel.ProductModelID.
    * Points to [adventureworks.production.productmodel.ProductmodelRow.productmodelid]
    */
  val productmodelid: Optional<ProductmodelId> = Optional.empty(),
  /** Date the product was available for sale.
    * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate:  (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
    */
  val sellstartdate: TypoLocalDateTime,
  /** Date the product was no longer available for sale.
    * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate:  (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
    */
  val sellenddate: Optional<TypoLocalDateTime> = Optional.empty(),
  /** Date the product was discontinued. */
  val discontinueddate: Optional<TypoLocalDateTime> = Optional.empty(),
  /** Default: nextval('production.product_productid_seq'::regclass)
    * Primary key for Product records.
    */
  val productid: Defaulted<ProductId> = UseDefault(),
  /** Default: true
    * 0 = Product is purchased, 1 = Product is manufactured in-house.
    */
  val makeflag: Defaulted<Flag> = UseDefault(),
  /** Default: true
    * 0 = Product is not a salable item. 1 = Product is salable.
    */
  val finishedgoodsflag: Defaulted<Flag> = UseDefault(),
  /** Default: uuid_generate_v1() */
  val rowguid: Defaulted<TypoUUID> = UseDefault(),
  /** Default: now() */
  val modifieddate: Defaulted<TypoLocalDateTime> = UseDefault()
) {
  fun toRow(
    productidDefault: () -> ProductId,
    makeflagDefault: () -> Flag,
    finishedgoodsflagDefault: () -> Flag,
    rowguidDefault: () -> TypoUUID,
    modifieddateDefault: () -> TypoLocalDateTime
  ): ProductRow = ProductRow(productid = productid.getOrElse(productidDefault), name = name, productnumber = productnumber, makeflag = makeflag.getOrElse(makeflagDefault), finishedgoodsflag = finishedgoodsflag.getOrElse(finishedgoodsflagDefault), color = color, safetystocklevel = safetystocklevel, reorderpoint = reorderpoint, standardcost = standardcost, listprice = listprice, size = size, sizeunitmeasurecode = sizeunitmeasurecode, weightunitmeasurecode = weightunitmeasurecode, weight = weight, daystomanufacture = daystomanufacture, productline = productline, `class` = `class`, style = style, productsubcategoryid = productsubcategoryid, productmodelid = productmodelid, sellstartdate = sellstartdate, sellenddate = sellenddate, discontinueddate = discontinueddate, rowguid = rowguid.getOrElse(rowguidDefault), modifieddate = modifieddate.getOrElse(modifieddateDefault))

  companion object {
    val pgText: PgText<ProductRowUnsaved> =
      PgText.instance({ row, sb -> Name.pgType.pgText().unsafeEncode(row.name, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.text.pgText().unsafeEncode(row.productnumber, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.text.opt().pgText().unsafeEncode(row.color, sb)
      sb.append(PgText.DELIMETER)
      TypoShort.pgType.pgText().unsafeEncode(row.safetystocklevel, sb)
      sb.append(PgText.DELIMETER)
      TypoShort.pgType.pgText().unsafeEncode(row.reorderpoint, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.numeric.pgText().unsafeEncode(row.standardcost, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.numeric.pgText().unsafeEncode(row.listprice, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.text.opt().pgText().unsafeEncode(row.size, sb)
      sb.append(PgText.DELIMETER)
      UnitmeasureId.pgType.opt().pgText().unsafeEncode(row.sizeunitmeasurecode, sb)
      sb.append(PgText.DELIMETER)
      UnitmeasureId.pgType.opt().pgText().unsafeEncode(row.weightunitmeasurecode, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.numeric.opt().pgText().unsafeEncode(row.weight, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.int4.pgText().unsafeEncode(row.daystomanufacture, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.bpchar.opt().pgText().unsafeEncode(row.productline, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.bpchar.opt().pgText().unsafeEncode(row.`class`, sb)
      sb.append(PgText.DELIMETER)
      PgTypes.bpchar.opt().pgText().unsafeEncode(row.style, sb)
      sb.append(PgText.DELIMETER)
      ProductsubcategoryId.pgType.opt().pgText().unsafeEncode(row.productsubcategoryid, sb)
      sb.append(PgText.DELIMETER)
      ProductmodelId.pgType.opt().pgText().unsafeEncode(row.productmodelid, sb)
      sb.append(PgText.DELIMETER)
      TypoLocalDateTime.pgType.pgText().unsafeEncode(row.sellstartdate, sb)
      sb.append(PgText.DELIMETER)
      TypoLocalDateTime.pgType.opt().pgText().unsafeEncode(row.sellenddate, sb)
      sb.append(PgText.DELIMETER)
      TypoLocalDateTime.pgType.opt().pgText().unsafeEncode(row.discontinueddate, sb)
      sb.append(PgText.DELIMETER)
      Defaulted.pgText(ProductId.pgType.pgText()).unsafeEncode(row.productid, sb)
      sb.append(PgText.DELIMETER)
      Defaulted.pgText(Flag.pgType.pgText()).unsafeEncode(row.makeflag, sb)
      sb.append(PgText.DELIMETER)
      Defaulted.pgText(Flag.pgType.pgText()).unsafeEncode(row.finishedgoodsflag, sb)
      sb.append(PgText.DELIMETER)
      Defaulted.pgText(TypoUUID.pgType.pgText()).unsafeEncode(row.rowguid, sb)
      sb.append(PgText.DELIMETER)
      Defaulted.pgText(TypoLocalDateTime.pgType.pgText()).unsafeEncode(row.modifieddate, sb) })
  }
}