package testdb

import dev.typr.foundations.data.{HierarchyId, Xml}
import org.junit.Assert._
import org.junit.Test
import testdb.all_scalar_types._
import testdb.customer_orders_view._
import testdb.userdefined.Email

import java.time._
import java.util.UUID
import scala.util.Random

/** Tests for SQL Server-specific features: MONEY, ROWVERSION, XML, JSON, UUID, DATETIMEOFFSET, HIERARCHYID, and Views.
  */
class DatabaseFeaturesTest {
  private val testInsert = TestInsert(Random(42))
  private val allTypesRepo = AllScalarTypesRepoImpl()
  private val customerOrdersViewRepo = CustomerOrdersViewViewRepoImpl()

  // ==================== Money Type Tests ====================

  @Test
  def testMoneyType(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val money = BigDecimal("922337203685477.5807")
    val row = testInsert.AllScalarTypes(colMoney = Some(money))

    assertTrue(row.colMoney.isDefined)
    assertEquals(0, money.compareTo(row.colMoney.get))
  }

  @Test
  def testSmallmoneyType(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val smallmoney = BigDecimal("214748.3647")
    val row = testInsert.AllScalarTypes(colSmallmoney = Some(smallmoney))

    assertTrue(row.colSmallmoney.isDefined)
    assertEquals(0, smallmoney.compareTo(row.colSmallmoney.get))
  }

  @Test
  def testMoneyPrecision(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val money = BigDecimal("1234.5678")
    val row = testInsert.AllScalarTypes(colMoney = Some(money))

    assertTrue(row.colMoney.isDefined)
    assertEquals(0, money.compareTo(row.colMoney.get))
  }

  // ==================== ROWVERSION Tests ====================

  @Test
  def testRowversionAutoGenerated(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val row = testInsert.AllScalarTypes()

    assertNotNull(row.colRowversion)
    assertTrue(row.colRowversion.length > 0)
  }

  @Test
  def testRowversionUniquePerRow(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val row1 = testInsert.AllScalarTypes()
    val row2 = testInsert.AllScalarTypes()

    assertNotNull(row1.colRowversion)
    assertNotNull(row2.colRowversion)
    assertFalse(java.util.Arrays.equals(row1.colRowversion, row2.colRowversion))
  }

  @Test
  def testRowversionChangesOnUpdate(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val inserted = testInsert.AllScalarTypes()
    val originalRowversion = inserted.colRowversion.clone()

    val updated = inserted.copy(colVarchar = Some("updated value"))
    val _ = allTypesRepo.update(updated)

    val found = allTypesRepo.selectById(inserted.id).get

    assertFalse(java.util.Arrays.equals(originalRowversion, found.colRowversion))
  }

  // ==================== XML Tests ====================

  @Test
  def testXmlType(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val xml = Xml("<root><element attr=\"value\">content</element></root>")
    val row = testInsert.AllScalarTypes(colXml = Some(xml))

    assertTrue(row.colXml.isDefined)
    assertTrue(row.colXml.get.value.contains("root"))
    assertTrue(row.colXml.get.value.contains("element"))
  }

  @Test
  def testXmlNestedStructure(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val xml = Xml("<catalog><book id=\"1\"><title>SQL Server</title><price>29.99</price></book></catalog>")
    val row = testInsert.AllScalarTypes(colXml = Some(xml))

    assertTrue(row.colXml.isDefined)
    assertTrue(row.colXml.get.value.contains("catalog"))
    assertTrue(row.colXml.get.value.contains("book"))
  }

  // ==================== JSON Tests ====================

  @Test
  def testJsonType(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val json = new dev.typr.foundations.data.Json("{\"name\": \"test\", \"values\": [1, 2, 3], \"nested\": {\"key\": \"value\"}}")
    val row = testInsert.AllScalarTypes(colJson = Some(json))

    assertTrue(row.colJson.isDefined)
    assertTrue(row.colJson.get.value.contains("name"))
    assertTrue(row.colJson.get.value.contains("nested"))
  }

  // ==================== UUID (UNIQUEIDENTIFIER) Tests ====================

  @Test
  def testUniqueidentifierType(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val uuid = UUID.randomUUID()
    val row = testInsert.AllScalarTypes(colUniqueidentifier = Some(uuid))

    assertEquals(Some(uuid), row.colUniqueidentifier)
  }

  @Test
  def testUniqueidentifierUniqueness(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val uuid1 = UUID.randomUUID()
    val uuid2 = UUID.randomUUID()

    val row1 = testInsert.AllScalarTypes(colUniqueidentifier = Some(uuid1))
    val row2 = testInsert.AllScalarTypes(colUniqueidentifier = Some(uuid2))

    assertNotEquals(row1.colUniqueidentifier, row2.colUniqueidentifier)
  }

  // ==================== DATETIMEOFFSET Tests ====================

  @Test
  def testDatetimeoffsetType(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val datetimeoffset = OffsetDateTime.of(2025, 6, 15, 14, 30, 45, 0, ZoneOffset.ofHours(-5))
    val row = testInsert.AllScalarTypes(colDatetimeoffset = Some(datetimeoffset))

    assertTrue(row.colDatetimeoffset.isDefined)
  }

  @Test
  def testDatetimeoffsetDifferentTimezones(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val utc = OffsetDateTime.of(2025, 6, 15, 12, 0, 0, 0, ZoneOffset.UTC)
    val pst = OffsetDateTime.of(2025, 6, 15, 5, 0, 0, 0, ZoneOffset.ofHours(-7))

    val rowUtc = testInsert.AllScalarTypes(colDatetimeoffset = Some(utc))
    val rowPst = testInsert.AllScalarTypes(colDatetimeoffset = Some(pst))

    assertTrue(rowUtc.colDatetimeoffset.isDefined)
    assertTrue(rowPst.colDatetimeoffset.isDefined)
  }

  // ==================== HIERARCHYID Tests ====================

  @Test
  def testHierarchyidType(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val hierarchyid = HierarchyId.parse("/1/2/3/")
    val row = testInsert.AllScalarTypes(colHierarchyid = Some(hierarchyid))

    assertTrue(row.colHierarchyid.isDefined)
    assertEquals(hierarchyid.toString, row.colHierarchyid.get.toString)
  }

  @Test
  def testHierarchyidRootLevel(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val hierarchyid = HierarchyId.ROOT
    val row = testInsert.AllScalarTypes(colHierarchyid = Some(hierarchyid))

    assertTrue(row.colHierarchyid.isDefined)
    assertEquals(hierarchyid.toString, row.colHierarchyid.get.toString)
  }

  // ==================== View Tests ====================

  @Test
  def testCustomerOrdersView(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val customer = testInsert.Customers(email = Email("viewtest@example.com"), name = "View Test Customer")
    val _ = testInsert.Orders(customer.customerId, totalAmount = BigDecimal("199.99"))

    val viewResults = customerOrdersViewRepo.select.toList

    assertTrue(viewResults.nonEmpty)
    val customerView = viewResults.find(_.customerId == customer.customerId.value)
    assertTrue(customerView.isDefined)
    assertEquals("View Test Customer", customerView.get.customerName)
    assertEquals("viewtest@example.com", customerView.get.customerEmail)
  }

  @Test
  def testViewDSLFilter(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val customer1 = testInsert.Customers(email = Email("filter-a@example.com"), name = "View Filter A")
    val customer2 = testInsert.Customers(email = Email("filter-b@example.com"), name = "View Filter B")
    val _ = testInsert.Orders(customer1.customerId)
    val _ = testInsert.Orders(customer2.customerId)

    val filtered = customerOrdersViewRepo.select
      .where(_.customerName.isEqual("View Filter A"))
      .toList

    assertTrue(filtered.forall(_.customerName == "View Filter A"))
  }

  // ==================== Date/Time Tests ====================

  @Test
  def testDatetimeTypes(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val date = LocalDate.of(2025, 6, 15)
    val time = LocalTime.of(14, 30, 45)
    val datetime = LocalDateTime.of(2025, 6, 15, 14, 30, 45)
    val datetime2 = LocalDateTime.of(2025, 6, 15, 14, 30, 45, 123456700)

    val row = testInsert.AllScalarTypes(
      colDate = Some(date),
      colTime = Some(time),
      colDatetime = Some(datetime),
      colDatetime2 = Some(datetime2)
    )

    assertEquals(Some(date), row.colDate)
    assertEquals(Some(time), row.colTime)
  }

  @Test
  def testSmalldatetimeType(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val smalldatetime = LocalDateTime.of(2025, 6, 15, 14, 30, 0)
    val row = testInsert.AllScalarTypes(colSmalldatetime = Some(smalldatetime))

    assertTrue(row.colSmalldatetime.isDefined)
  }

  // ==================== Default Value Tests ====================

  @Test
  def testDefaultValueApplied(): Unit = withConnection { c =>
    given java.sql.Connection = c

    val row = testInsert.AllScalarTypes()

    assertEquals("default_value", row.colNotNull)
  }
}
