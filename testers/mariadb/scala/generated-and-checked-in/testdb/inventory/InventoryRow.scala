/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.inventory

import com.fasterxml.jackson.annotation.JsonProperty
import dev.typr.foundations.MariaTypes
import dev.typr.foundations.Tuple.Tuple11
import dev.typr.foundations.scala.DbTypeOps
import dev.typr.foundations.scala.RowParser
import dev.typr.foundations.scala.RowParsers
import dev.typr.foundations.scala.ScalaDbTypes
import java.time.LocalDateTime
import testdb.customtypes.Defaulted
import testdb.products.ProductsId
import testdb.warehouses.WarehousesId

/** Table: inventory
 * Primary key: inventory_id
 */
case class InventoryRow(
  /** 
   * AUTO_INCREMENT
   */
  @JsonProperty("inventory_id") inventoryId: InventoryId,
  /** 
   * Points to [[testdb.products.ProductsRow.productId]]
   */
  @JsonProperty("product_id") productId: ProductsId,
  /** 
   * Points to [[testdb.warehouses.WarehousesRow.warehouseId]]
   */
  @JsonProperty("warehouse_id") warehouseId: WarehousesId,
  /** 
   * Default: 0
   */
  @JsonProperty("quantity_on_hand") quantityOnHand: Int,
  /** 
   * Default: 0
   */
  @JsonProperty("quantity_reserved") quantityReserved: Int,
  /** 
   * Default: 0
   */
  @JsonProperty("quantity_on_order") quantityOnOrder: Int,
  /** 
   * Default: 0
   */
  @JsonProperty("reorder_point") reorderPoint: Int,
  /** 
   * Default: 0
   */
  @JsonProperty("reorder_quantity") reorderQuantity: Int,
  /** 
   * Default: NULL
   */
  @JsonProperty("bin_location") binLocation: Option[String],
  /** 
   * Default: NULL
   */
  @JsonProperty("last_counted_at") lastCountedAt: Option[LocalDateTime],
  /** 
   * Default: current_timestamp(6)
   */
  @JsonProperty("updated_at") updatedAt: LocalDateTime
) extends Tuple11[InventoryId, ProductsId, WarehousesId, Int, Int, Int, Int, Int, Option[String], Option[LocalDateTime], LocalDateTime] {
  def id: InventoryId = inventoryId

  def toUnsavedRow(
    quantityOnHand: Defaulted[Int] = Defaulted.Provided(this.quantityOnHand),
    quantityReserved: Defaulted[Int] = Defaulted.Provided(this.quantityReserved),
    quantityOnOrder: Defaulted[Int] = Defaulted.Provided(this.quantityOnOrder),
    reorderPoint: Defaulted[Int] = Defaulted.Provided(this.reorderPoint),
    reorderQuantity: Defaulted[Int] = Defaulted.Provided(this.reorderQuantity),
    binLocation: Defaulted[Option[String]] = Defaulted.Provided(this.binLocation),
    lastCountedAt: Defaulted[Option[LocalDateTime]] = Defaulted.Provided(this.lastCountedAt),
    updatedAt: Defaulted[LocalDateTime] = Defaulted.Provided(this.updatedAt)
  ): InventoryRowUnsaved = {
    new InventoryRowUnsaved(
      productId,
      warehouseId,
      quantityOnHand,
      quantityReserved,
      quantityOnOrder,
      reorderPoint,
      reorderQuantity,
      binLocation,
      lastCountedAt,
      updatedAt
    )
  }

  override def `_1`: InventoryId = inventoryId

  override def `_2`: ProductsId = productId

  override def `_3`: WarehousesId = warehouseId

  override def `_4`: Int = quantityOnHand

  override def `_5`: Int = quantityReserved

  override def `_6`: Int = quantityOnOrder

  override def `_7`: Int = reorderPoint

  override def `_8`: Int = reorderQuantity

  override def `_9`: Option[String] = binLocation

  override def `_10`: Option[LocalDateTime] = lastCountedAt

  override def `_11`: LocalDateTime = updatedAt
}

object InventoryRow {
  val `_rowParser`: RowParser[InventoryRow] = RowParsers.of(InventoryId.mariaType, ProductsId.mariaType, WarehousesId.mariaType, ScalaDbTypes.MariaTypes.int_, ScalaDbTypes.MariaTypes.int_, ScalaDbTypes.MariaTypes.int_, ScalaDbTypes.MariaTypes.int_, ScalaDbTypes.MariaTypes.int_, MariaTypes.varchar.nullable, MariaTypes.datetime.nullable, MariaTypes.datetime)(InventoryRow.apply)(row => Array[Any](row.inventoryId, row.productId, row.warehouseId, row.quantityOnHand, row.quantityReserved, row.quantityOnOrder, row.reorderPoint, row.reorderQuantity, row.binLocation, row.lastCountedAt, row.updatedAt))
}