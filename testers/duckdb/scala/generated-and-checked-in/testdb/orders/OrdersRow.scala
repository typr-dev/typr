/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package testdb.orders

import com.fasterxml.jackson.annotation.JsonProperty
import dev.typr.foundations.DuckDbTypes
import dev.typr.foundations.scala.DuckDbTypeOps
import dev.typr.foundations.scala.RowParser
import dev.typr.foundations.scala.RowParsers
import dev.typr.foundations.scala.ScalaDbTypes
import java.time.LocalDate
import testdb.customtypes.Defaulted

/** Table: orders
 * Primary key: order_id
 */
case class OrdersRow(
  @JsonProperty("order_id") orderId: OrdersId,
  @JsonProperty("customer_id") customerId: Int,
  /** Default: current_date */
  @JsonProperty("order_date") orderDate: LocalDate,
  @JsonProperty("total_amount") totalAmount: Option[BigDecimal],
  /** Default: 'pending' */
  status: Option[String]
) {
  def id: OrdersId = orderId

  def toUnsavedRow(
    orderDate: Defaulted[LocalDate] = Defaulted.Provided(this.orderDate),
    status: Defaulted[Option[String]] = Defaulted.Provided(this.status)
  ): OrdersRowUnsaved = {
    new OrdersRowUnsaved(
      orderId,
      customerId,
      totalAmount,
      orderDate,
      status
    )
  }
}

object OrdersRow {
  val `_rowParser`: RowParser[OrdersRow] = RowParsers.of(OrdersId.duckDbType, ScalaDbTypes.DuckDbTypes.integer, DuckDbTypes.date, ScalaDbTypes.DuckDbTypes.numeric.nullable, DuckDbTypes.varchar.nullable)(OrdersRow.apply)(row => Array[Any](row.orderId, row.customerId, row.orderDate, row.totalAmount, row.status))
}