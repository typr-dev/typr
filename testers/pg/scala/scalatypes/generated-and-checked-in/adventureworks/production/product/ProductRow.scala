/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.production.product

import adventureworks.customtypes.Defaulted
import adventureworks.production.productmodel.ProductmodelId
import adventureworks.production.productsubcategory.ProductsubcategoryId
import adventureworks.production.unitmeasure.UnitmeasureId
import adventureworks.public.Flag
import adventureworks.public.Name
import dev.typr.foundations.PgText
import dev.typr.foundations.PgTypes
import dev.typr.foundations.Tuple.Tuple25
import dev.typr.foundations.scala.DbTypeOps
import dev.typr.foundations.scala.RowParser
import dev.typr.foundations.scala.RowParsers
import dev.typr.foundations.scala.ScalaDbTypes
import java.time.LocalDateTime
import java.util.UUID

/** Table: production.product
 * Products sold or used in the manfacturing of sold products.
 * Primary key: productid
 */
case class ProductRow(
  /** Primary key for Product records.
   * Default: nextval('production.product_productid_seq'::regclass)
   */
  productid: ProductId,
  /** Name of the product. */
  name: Name,
  /** Unique product identification number. */
  productnumber: String,
  /** 0 = Product is purchased, 1 = Product is manufactured in-house.
   * Default: true
   */
  makeflag: Flag,
  /** 0 = Product is not a salable item. 1 = Product is salable.
   * Default: true
   */
  finishedgoodsflag: Flag,
  /** Product color. */
  color: Option[/* max 15 chars */ String],
  /** Minimum inventory quantity.
   * Constraint CK_Product_SafetyStockLevel affecting columns safetystocklevel: ((safetystocklevel > 0))
   */
  safetystocklevel: Short,
  /** Inventory level that triggers a purchase order or work order.
   * Constraint CK_Product_ReorderPoint affecting columns reorderpoint: ((reorderpoint > 0))
   */
  reorderpoint: Short,
  /** Standard cost of the product.
   * Constraint CK_Product_StandardCost affecting columns standardcost: ((standardcost >= 0.00))
   */
  standardcost: BigDecimal,
  /** Selling price.
   * Constraint CK_Product_ListPrice affecting columns listprice: ((listprice >= 0.00))
   */
  listprice: BigDecimal,
  /** Product size. */
  size: Option[/* max 5 chars */ String],
  /** Unit of measure for Size column.
   * Points to [[adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]]
   */
  sizeunitmeasurecode: Option[UnitmeasureId],
  /** Unit of measure for Weight column.
   * Points to [[adventureworks.production.unitmeasure.UnitmeasureRow.unitmeasurecode]]
   */
  weightunitmeasurecode: Option[UnitmeasureId],
  /** Product weight.
   * Constraint CK_Product_Weight affecting columns weight: ((weight > 0.00))
   */
  weight: Option[BigDecimal],
  /** Number of days required to manufacture the product.
   * Constraint CK_Product_DaysToManufacture affecting columns daystomanufacture: ((daystomanufacture >= 0))
   */
  daystomanufacture: Int,
  /** R = Road, M = Mountain, T = Touring, S = Standard
   * Constraint CK_Product_ProductLine affecting columns productline: (((upper((productline)::text) = ANY (ARRAY['S'::text, 'T'::text, 'M'::text, 'R'::text])) OR (productline IS NULL)))
   */
  productline: Option[/* bpchar, max 2 chars */ String],
  /** H = High, M = Medium, L = Low
   * Constraint CK_Product_Class affecting columns class: (((upper((class)::text) = ANY (ARRAY['L'::text, 'M'::text, 'H'::text])) OR (class IS NULL)))
   */
  `class`: Option[/* bpchar, max 2 chars */ String],
  /** W = Womens, M = Mens, U = Universal
   * Constraint CK_Product_Style affecting columns style: (((upper((style)::text) = ANY (ARRAY['W'::text, 'M'::text, 'U'::text])) OR (style IS NULL)))
   */
  style: Option[/* bpchar, max 2 chars */ String],
  /** Product is a member of this product subcategory. Foreign key to ProductSubCategory.ProductSubCategoryID.
   * Points to [[adventureworks.production.productsubcategory.ProductsubcategoryRow.productsubcategoryid]]
   */
  productsubcategoryid: Option[ProductsubcategoryId],
  /** Product is a member of this product model. Foreign key to ProductModel.ProductModelID.
   * Points to [[adventureworks.production.productmodel.ProductmodelRow.productmodelid]]
   */
  productmodelid: Option[ProductmodelId],
  /** Date the product was available for sale.
   * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate: (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
   */
  sellstartdate: LocalDateTime,
  /** Date the product was no longer available for sale.
   * Constraint CK_Product_SellEndDate affecting columns sellenddate, sellstartdate: (((sellenddate >= sellstartdate) OR (sellenddate IS NULL)))
   */
  sellenddate: Option[LocalDateTime],
  /** Date the product was discontinued. */
  discontinueddate: Option[LocalDateTime],
  /** Default: uuid_generate_v1() */
  rowguid: UUID,
  /** Default: now() */
  modifieddate: LocalDateTime
) extends Tuple25[ProductId, Name, String, Flag, Flag, Option[/* max 15 chars */ String], Short, Short, BigDecimal, BigDecimal, Option[/* max 5 chars */ String], Option[UnitmeasureId], Option[UnitmeasureId], Option[BigDecimal], Int, Option[/* bpchar, max 2 chars */ String], Option[/* bpchar, max 2 chars */ String], Option[/* bpchar, max 2 chars */ String], Option[ProductsubcategoryId], Option[ProductmodelId], LocalDateTime, Option[LocalDateTime], Option[LocalDateTime], UUID, LocalDateTime] {
  def id: ProductId = productid

  def toUnsavedRow(
    productid: Defaulted[ProductId],
    makeflag: Defaulted[Flag] = Defaulted.Provided(this.makeflag),
    finishedgoodsflag: Defaulted[Flag] = Defaulted.Provided(this.finishedgoodsflag),
    rowguid: Defaulted[UUID] = Defaulted.Provided(this.rowguid),
    modifieddate: Defaulted[LocalDateTime] = Defaulted.Provided(this.modifieddate)
  ): ProductRowUnsaved = {
    new ProductRowUnsaved(
      name,
      productnumber,
      color,
      safetystocklevel,
      reorderpoint,
      standardcost,
      listprice,
      size,
      sizeunitmeasurecode,
      weightunitmeasurecode,
      weight,
      daystomanufacture,
      productline,
      `class`,
      style,
      productsubcategoryid,
      productmodelid,
      sellstartdate,
      sellenddate,
      discontinueddate,
      productid,
      makeflag,
      finishedgoodsflag,
      rowguid,
      modifieddate
    )
  }

  override def `_1`: ProductId = productid

  override def `_2`: Name = name

  override def `_3`: String = productnumber

  override def `_4`: Flag = makeflag

  override def `_5`: Flag = finishedgoodsflag

  override def `_6`: Option[/* max 15 chars */ String] = color

  override def `_7`: Short = safetystocklevel

  override def `_8`: Short = reorderpoint

  override def `_9`: BigDecimal = standardcost

  override def `_10`: BigDecimal = listprice

  override def `_11`: Option[/* max 5 chars */ String] = size

  override def `_12`: Option[UnitmeasureId] = sizeunitmeasurecode

  override def `_13`: Option[UnitmeasureId] = weightunitmeasurecode

  override def `_14`: Option[BigDecimal] = weight

  override def `_15`: Int = daystomanufacture

  override def `_16`: Option[/* bpchar, max 2 chars */ String] = productline

  override def `_17`: Option[/* bpchar, max 2 chars */ String] = `class`

  override def `_18`: Option[/* bpchar, max 2 chars */ String] = style

  override def `_19`: Option[ProductsubcategoryId] = productsubcategoryid

  override def `_20`: Option[ProductmodelId] = productmodelid

  override def `_21`: LocalDateTime = sellstartdate

  override def `_22`: Option[LocalDateTime] = sellenddate

  override def `_23`: Option[LocalDateTime] = discontinueddate

  override def `_24`: UUID = rowguid

  override def `_25`: LocalDateTime = modifieddate
}

object ProductRow {
  val `_rowParser`: RowParser[ProductRow] = RowParsers.of(ProductId.pgType, Name.pgType, PgTypes.text, Flag.pgType, Flag.pgType, PgTypes.text.nullable, ScalaDbTypes.PgTypes.int2, ScalaDbTypes.PgTypes.int2, ScalaDbTypes.PgTypes.numeric, ScalaDbTypes.PgTypes.numeric, PgTypes.text.nullable, UnitmeasureId.pgType.nullable, UnitmeasureId.pgType.nullable, ScalaDbTypes.PgTypes.numeric.nullable, ScalaDbTypes.PgTypes.int4, PgTypes.bpchar.nullable, PgTypes.bpchar.nullable, PgTypes.bpchar.nullable, ProductsubcategoryId.pgType.nullable, ProductmodelId.pgType.nullable, PgTypes.timestamp, PgTypes.timestamp.nullable, PgTypes.timestamp.nullable, PgTypes.uuid, PgTypes.timestamp)(ProductRow.apply)(row => Array[Any](row.productid, row.name, row.productnumber, row.makeflag, row.finishedgoodsflag, row.color, row.safetystocklevel, row.reorderpoint, row.standardcost, row.listprice, row.size, row.sizeunitmeasurecode, row.weightunitmeasurecode, row.weight, row.daystomanufacture, row.productline, row.`class`, row.style, row.productsubcategoryid, row.productmodelid, row.sellstartdate, row.sellenddate, row.discontinueddate, row.rowguid, row.modifieddate))

  given pgText: PgText[ProductRow] = PgText.from(`_rowParser`.underlying)
}