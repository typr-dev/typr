/**
 * File has been automatically generated by `typo`.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.humanresources.employeedepartmenthistory

import adventureworks.customtypes.Defaulted
import adventureworks.humanresources.department.DepartmentId
import adventureworks.humanresources.shift.ShiftId
import adventureworks.person.businessentity.BusinessentityId
import dev.typr.foundations.PgText
import dev.typr.foundations.PgTypes
import dev.typr.foundations.kotlin.RowParser
import dev.typr.foundations.kotlin.RowParsers
import dev.typr.foundations.kotlin.nullable
import java.time.LocalDate
import java.time.LocalDateTime

/** Table: humanresources.employeedepartmenthistory
  * Employee department transfers.
  * Composite primary key: businessentityid, startdate, departmentid, shiftid
  */
data class EmployeedepartmenthistoryRow(
  /** Employee identification number. Foreign key to Employee.BusinessEntityID.
    * Points to [adventureworks.humanresources.employee.EmployeeRow.businessentityid]
    */
  val businessentityid: BusinessentityId,
  /** Department in which the employee worked including currently. Foreign key to Department.DepartmentID.
    * Points to [adventureworks.humanresources.department.DepartmentRow.departmentid]
    */
  val departmentid: DepartmentId,
  /** Identifies which 8-hour shift the employee works. Foreign key to Shift.Shift.ID.
    * Points to [adventureworks.humanresources.shift.ShiftRow.shiftid]
    */
  val shiftid: ShiftId,
  /** Date the employee started work in the department.
    * Constraint CK_EmployeeDepartmentHistory_EndDate affecting columns enddate, startdate: (((enddate >= startdate) OR (enddate IS NULL)))
    */
  val startdate: LocalDate,
  /** Date the employee left the department. NULL = Current department.
    * Constraint CK_EmployeeDepartmentHistory_EndDate affecting columns enddate, startdate: (((enddate >= startdate) OR (enddate IS NULL)))
    */
  val enddate: LocalDate?,
  /** Default: now() */
  val modifieddate: LocalDateTime
) {
  fun compositeId(): EmployeedepartmenthistoryId = EmployeedepartmenthistoryId(businessentityid, startdate, departmentid, shiftid)

  fun id(): EmployeedepartmenthistoryId = this.compositeId()

  fun toUnsavedRow(modifieddate: Defaulted<LocalDateTime> = Defaulted.Provided(this.modifieddate)): EmployeedepartmenthistoryRowUnsaved = EmployeedepartmenthistoryRowUnsaved(businessentityid, departmentid, shiftid, startdate, enddate, modifieddate)

  companion object {
    val _rowParser: RowParser<EmployeedepartmenthistoryRow> = RowParsers.of(BusinessentityId.pgType, DepartmentId.pgType, ShiftId.pgType, PgTypes.date, PgTypes.date.nullable(), PgTypes.timestamp, { t0, t1, t2, t3, t4, t5 -> EmployeedepartmenthistoryRow(t0, t1, t2, t3, t4, t5) }, { row -> arrayOf<Any?>(row.businessentityid, row.departmentid, row.shiftid, row.startdate, row.enddate, row.modifieddate) })

    fun apply(
      compositeId: EmployeedepartmenthistoryId,
      enddate: LocalDate?,
      modifieddate: LocalDateTime
    ): EmployeedepartmenthistoryRow = EmployeedepartmenthistoryRow(compositeId.businessentityid, compositeId.departmentid, compositeId.shiftid, compositeId.startdate, enddate, modifieddate)

    val pgText: PgText<EmployeedepartmenthistoryRow> =
      PgText.from(_rowParser.underlying)
  }
}