/**
 * File has been automatically generated by `typo`.
 *
 * <p>IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 */
package adventureworks.person.address;

import adventureworks.person.stateprovince.StateprovinceFields;
import adventureworks.person.stateprovince.StateprovinceId;
import adventureworks.person.stateprovince.StateprovinceRow;
import dev.typr.foundations.PgTypes;
import dev.typr.foundations.RowParser;
import dev.typr.foundations.dsl.FieldsBase;
import dev.typr.foundations.dsl.ForeignKey;
import dev.typr.foundations.dsl.Path;
import dev.typr.foundations.dsl.RelationStructure;
import dev.typr.foundations.dsl.SqlExpr;
import dev.typr.foundations.dsl.SqlExpr.Field;
import dev.typr.foundations.dsl.SqlExpr.FieldLike;
import dev.typr.foundations.dsl.SqlExpr.IdField;
import dev.typr.foundations.dsl.SqlExpr.OptField;
import dev.typr.foundations.dsl.TupleExpr.TupleExpr9;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public class AddressFields
    extends TupleExpr9<
        AddressId,
        String, /* max 60 chars */
        String,
        String,
        StateprovinceId,
        String,
        byte[],
        UUID,
        LocalDateTime>
    implements RelationStructure<AddressFields, AddressRow>, FieldsBase<AddressRow> {
  List<Path> _path;

  public AddressFields(List<Path> _path) {
    this._path = _path;
  }

  public static AddressFields structure = new AddressFields(java.util.Collections.emptyList());

  public IdField<AddressId, AddressRow> addressid() {
    return new IdField<AddressId, AddressRow>(
        _path,
        "addressid",
        AddressRow::addressid,
        Optional.empty(),
        Optional.of("int4"),
        (row, value) -> row.withAddressid(value),
        AddressId.dbType);
  }

  public Field<String, AddressRow> addressline1() {
    return new Field<String, AddressRow>(
        _path,
        "addressline1",
        AddressRow::addressline1,
        Optional.empty(),
        Optional.empty(),
        (row, value) -> row.withAddressline1(value),
        PgTypes.text);
  }

  public OptField<String, AddressRow> addressline2() {
    return new OptField<String, AddressRow>(
        _path,
        "addressline2",
        AddressRow::addressline2,
        Optional.empty(),
        Optional.empty(),
        (row, value) -> row.withAddressline2(value),
        PgTypes.text);
  }

  public Field<String, AddressRow> city() {
    return new Field<String, AddressRow>(
        _path,
        "city",
        AddressRow::city,
        Optional.empty(),
        Optional.empty(),
        (row, value) -> row.withCity(value),
        PgTypes.text);
  }

  public Field<StateprovinceId, AddressRow> stateprovinceid() {
    return new Field<StateprovinceId, AddressRow>(
        _path,
        "stateprovinceid",
        AddressRow::stateprovinceid,
        Optional.empty(),
        Optional.of("int4"),
        (row, value) -> row.withStateprovinceid(value),
        StateprovinceId.dbType);
  }

  public Field<String, AddressRow> postalcode() {
    return new Field<String, AddressRow>(
        _path,
        "postalcode",
        AddressRow::postalcode,
        Optional.empty(),
        Optional.empty(),
        (row, value) -> row.withPostalcode(value),
        PgTypes.text);
  }

  public OptField<byte[], AddressRow> spatiallocation() {
    return new OptField<byte[], AddressRow>(
        _path,
        "spatiallocation",
        AddressRow::spatiallocation,
        Optional.empty(),
        Optional.of("bytea"),
        (row, value) -> row.withSpatiallocation(value),
        PgTypes.bytea);
  }

  public Field<UUID, AddressRow> rowguid() {
    return new Field<UUID, AddressRow>(
        _path,
        "rowguid",
        AddressRow::rowguid,
        Optional.empty(),
        Optional.of("uuid"),
        (row, value) -> row.withRowguid(value),
        PgTypes.uuid);
  }

  public Field<LocalDateTime, AddressRow> modifieddate() {
    return new Field<LocalDateTime, AddressRow>(
        _path,
        "modifieddate",
        AddressRow::modifieddate,
        Optional.empty(),
        Optional.of("timestamp"),
        (row, value) -> row.withModifieddate(value),
        PgTypes.timestamp);
  }

  @Override
  public List<Path> _path() {
    return _path;
  }

  public ForeignKey<StateprovinceFields, StateprovinceRow> fkStateprovince() {
    return ForeignKey.<StateprovinceFields, StateprovinceRow>of(
            "person.FK_Address_StateProvince_StateProvinceID")
        .<StateprovinceId>withColumnPair(stateprovinceid(), StateprovinceFields::stateprovinceid);
  }

  @Override
  public List<FieldLike<?, AddressRow>> columns() {
    return java.util.List.of(
        this.addressid(),
        this.addressline1(),
        this.addressline2(),
        this.city(),
        this.stateprovinceid(),
        this.postalcode(),
        this.spatiallocation(),
        this.rowguid(),
        this.modifieddate());
  }

  @Override
  public RowParser<AddressRow> rowParser() {
    return AddressRow._rowParser;
  }

  @Override
  public RelationStructure<AddressFields, AddressRow> withPaths(List<Path> _path) {
    return new AddressFields(_path);
  }

  @Override
  public SqlExpr<AddressId> _1() {
    return addressid();
  }

  @Override
  public SqlExpr<String> _2() {
    return addressline1();
  }

  @Override
  public SqlExpr</* max 60 chars */ String> _3() {
    return addressline2();
  }

  @Override
  public SqlExpr<String> _4() {
    return city();
  }

  @Override
  public SqlExpr<StateprovinceId> _5() {
    return stateprovinceid();
  }

  @Override
  public SqlExpr<String> _6() {
    return postalcode();
  }

  @Override
  public SqlExpr<byte[]> _7() {
    return spatiallocation();
  }

  @Override
  public SqlExpr<UUID> _8() {
    return rowguid();
  }

  @Override
  public SqlExpr<LocalDateTime> _9() {
    return modifieddate();
  }
}
